//*********************************************************定义*********************************************************//
#define DEBUG		0
#define WQX			20	//文曲星平台[0:TC800,6:LavaX all,8:LavaX 8K,20:LavaX 20K]
//-----------------------------------------------------------------------
//*********************************************************定义*********************************************************//
#ifndef WQX
#define WQX         8                                                    //默认文曲星平台
#endif
//********************************************************TC 800********************************************************//
#if WQX == 0
#define PUBLIC      11800                                                //公共缓冲区
//帮助
#define HLP_L_SIZE  11500                                                //文字行数
//编辑
#define TXT_SIZE    10000                                                //缓冲区长度
#define TXT_T_SIZE  150                                                  //表大小
#define TXT_C_SIZE  512                                                  //临时缓冲区大小
#define CLI_SIZE    1024                                                 //剪切板长度
#define SKFUN_L_LEN 150                                                  //检索个数
//编译
#define FB_C_SIZE   3000                                                 //总缓冲区长度
#define VAR_SIZE    700                                                  //变量链表大小
#define LIB_SIZE    20                                                   //链接个数
//查看
#define TIME_DELAY  64                                                   //输入时间延迟
#define DOC_D_SIZE  255                                                  //文件表长度<=256
#define MAC_M_SIZE  255                                                  //宏表长度<=256
//链接
#define LIB_N_LEN   240                                                  //子程序个数
#define LIB_C_LEN   10000                                                //缓冲区大小
//预处理
#define FY_C_SIZE   4200                                                 //缓冲区长度
#define FY_C_REL    800                                                  //缓冲偏移量
#endif
//******************************************************LavaX  20K******************************************************//
#if WQX == 20
#define PUBLIC      13000                                                //公共缓冲区
//帮助
#define HLP_L_SIZE  12700                                                //文字行数
//编辑
#define TXT_SIZE    10000                                                //缓冲区长度
#define TXT_T_SIZE  200                                                  //表大小
#define TXT_C_SIZE  512                                                  //临时缓冲区大小
#define CLI_SIZE    1800                                                 //剪切板长度
#define SKFUN_L_LEN 150                                                  //检索个数
//编译
#define FB_C_SIZE   3000                                                 //总缓冲区长度
#define VAR_SIZE    700                                                  //变量链表大小
#define LIB_SIZE    20                                                   //链接个数
//查看
#define DOC_D_SIZE  255                                                  //文件表长度<=256
#define MAC_M_SIZE  255                                                  //宏表长度<=256
//链接
#define LIB_N_LEN   316                                                  //子程序个数
#define LIB_C_LEN   10000                                                //缓冲区大小
//预处理
#define FY_C_SIZE   5400                                                 //缓冲区长度
#define FY_C_REL    1000                                                 //缓冲偏移量
#endif
//******************************************************LavaX  6K******************************************************//
#if WQX == 6
#define PUBLIC      3500                                                 //公共缓冲区
//帮助
#define HLP_L_SIZE  2300                                                 //文字行数
//编辑
#define TXT_SIZE    2450                                                 //缓冲区长度
#define TXT_T_SIZE  55                                                   //表大小
//编译
#define VAR_SIZE    160                                                  //变量链表大小
//查看
#define DOC_D_SIZE  240                                                  //文件表长度<=256
#define MAC_M_SIZE  85                                                   //宏表长度<=256
//链接
#define LIB_N_LEN   90                                                   //子程序个数
#endif
//**********************************************************************************************************************//
#ifndef PUBLIC
#define PUBLIC      5500                                                 //默认公共缓冲区
#endif
#define TABLE_SEK   2                                                    //表格查找
#define TABLE_INS   4                                                    //表格插入
#define TABLE_DEL   6                                                    //表格删除
#define TABLE_RED   8                                                    //表格读取
//******************************************************资源偏移量******************************************************//
//-----------------------------------------------------------------------
#define JUMP_SIZE   20                                                   //跳转表大小[资源器－变]
//*******************************************************目录表格*******************************************************//
#define CATAL_TABLE 0x2000                                               //目录地址
//-----------------------------------------------------------------------
#define CAT_N_LEN   11                                                   //名称长度
#define CAT_E_LEN   15                                                   //解释长度
#define CAT_C_SIZE  4                                                    //目录长度

#define CAT_HELP    1                                                    //帮助目录
#define CAT_SET     2                                                    //设置目录
//======================================================================================================================//
struct CATUNIT                                                           //基本结构
{
	char name[CAT_N_LEN];                                                   //名称
	char msg[3][CAT_E_LEN];                                                 //解释[3行]
};

struct CATTABLE
{
	struct CATUNIT dat[CAT_C_SIZE];                                         //数据域
};
//*******************************************************错误代码*******************************************************//
#define E_OPEN      0													//无法打开文件
#define E_CATA      1													//无法进入目录
#define E_CREAT     2													//无法创建文件
#define E_SEEK      3													//断点读取错误
#define E_WRITE     4													//文件写入错误
#define E_JMPM      5													//跳转个数太多
#define E_OFFSET    6													//文件偏移错误
#define E_USIGN     7													//不支持该符号
#define E_LONG      8													//数组数据超长
#define E_WBIG      9													//数组维数太大
#define E_PVAR      10													//变量无法赋值
#define E_SIZE      11													//无法确定大小
#define E_RVAR      12													//变量重复定义
#define E_RSTU      13													//引用重复定义
#define E_RSUB      14													//函数重复定义
#define E_DEFI      15													//函数定义错误
#define E_USTU      16													//构造体未定义
#define E_RLAB      17													//标号重复定义
#define E_UVAR      18													//变量未定义
#define E_OARR      19													//数组超出维数
#define E_UMEM      20													//成员不存在
#define E_PARA      21													//函数参数错误
#define E_HEAP      22													//堆栈错误
#define E_NBRK      23													//break不在循环体中
#define E_NCON      24													//continue不在循环体中
#define E_NRET      25													//函数必须有返回值
#define E_HRET      26													//函数不能有返回值
#define E_DJMP      27													//跳转错误（还有跳转未写入）
#define E_KVAR      28													//变量空间不足
#define E_LOAD      29													//无法载入内存
#define E_UDEF      30													//宏定义不存在
#define E_ZERO      31													//文件长度为零
#define E_NONE      32													//空字符
#define E_CBIG      33													//长字符
#define E_RDEF      34													//重复定义宏
#define E_LINK      35													//链接库太多
#define E_STR       36													//非法字符串
#define E_INTER     37													//接口错误
#define E_MMAC      38													//宏定义太多
#define E_MVAR      39													//变量太多
#define E_MAIN      40													//缺少main函数
#define E_SYMB      41													//括号无法配对
#define E_JMPE      42													//跳转错误
#define E_FORMAT    43													//接口格式错误
#define E_UTYPE     44													//未定义的类型
#define E_SIGN      45													//错误的符号
#define E_SENTE     46													//错误的语句
#define E_CMD       47													//未定义的内码
#define E_CHANGE    48													//类型转换错误
#define E_ANALY     49													//文本解析错误
#define E_NOPARA    50													//缺少参数
#define E_GRAMMAR   51													//语法错误
#define E_CONST     52													//错误的常数
#define E_JKDIFF    53													//接口个数不符
#define E_NOQMRK	54													//字符串缺少"号
#define E_HEADFILE	55													//包含文件类型错误
#define E_PRETCMD	56													//不支持该命令
#define E_NOTE		57													//注释符不完整
#define E_PRE_IF	58													//预处理命令不完整
#define E_CONSTS	59													//错误的常量式
#define E_UNCODE	60													//未知的定义码
#define E_DEFOVER	61													//宏展开太长
//*******************************************************错误结构*******************************************************//
#define ERROR_LOAD  0x2000												//错误信息地址
//-----------------------------------------------------------------------
#define ERR_MSG     20													//错误信息长度
#define ERR_STR     30													//说明信息长度
#define ERR_ADV     24													//建议信息长度
//======================================================================================================================//
struct ERR_UNIT
{
	char m[ERR_MSG];													//错误信息
	char s[ERR_STR];													//说明信息
	char a[ERR_ADV];													//建议信息
};
//*******************************************************文件列表*******************************************************//
#define LIST_TABLE  0x2000                                               //列表地址
//-----------------------------------------------------------------------
#define LU_SIZE     15                                                   //文件名长度
#define LIST_SIZE   PUBLIC/15                                            //列表大小
#define DIR_LEN     20                                                   //目录长度
//======================================================================================================================//
struct LIST_UNIT
{
	char name[LU_SIZE];
};
struct ULIST
{
	char dirname[DIR_LEN];                                                  //目录
	char start[4];                                                          //起始地址
	char size[2];                                                           //列表大小
	struct LIST_UNIT dat[LIST_SIZE];                                        //列表信息
};
//*******************************************************后缀列表*******************************************************//
#define EU_SIZE     4                                                    //后缀名长度
#define EXT_SIZE    5                                                    //列表大小
//======================================================================================================================//
struct EXT_UNIT
{
	char name[EU_SIZE];
};
struct UEXT
{
	char size;
	struct EXT_UNIT dat[EXT_SIZE];
};//*******************************************************设置表格*******************************************************//
#define CONFG_TABLE 0x2000                                               //设置表地址
//-----------------------------------------------------------------------
#define CON_N_LEN   20                                                   //项目名称长度<=20
#define CON_T_SIZE  4                                                    //目录个数
#define CON_N_SIZE  4                                                    //项目个数
//-----------------------------------------------------------------------
#define CON_READ    1                                                    //读取
#define CON_SETE    2                                                    //设置
//======================================================================================================================//
//---------------------------------------------------------存储---------------------------------------------------------//
struct CONUNIT0                                                          //基本结构0
{
	char value;                                                             //值0
};
struct CONSYS0                                                           //系统结构0
{
	struct CONUNIT0 tem[CON_N_SIZE];                                        //项目数0
};
struct CONTABLE0                                                         //设置表结构0
{
	struct CONSYS0 dat[CON_T_SIZE];                                         //数据域0
	char fun[16];                                                           //函数文件
	char lav[16];                                                           //程序目录
};
//---------------------------------------------------------说明---------------------------------------------------------//
struct CONUNIT1                                                          //基本结构1
{
	char name[CON_N_LEN];                                                   //名称1
};
struct CONSYS1                                                           //系统结构1
{
	struct CONUNIT1 tem[CON_N_SIZE];                                        //项目1
	char size;                                                              //大小1
};
struct CONTABLE1                                                         //设置表结构1
{
	struct CONSYS1 dat[CON_T_SIZE];                                         //数据域1
};
//*******************************************************帮助文本*******************************************************//
#define HELP_TXT    0x2000                                               //帮助地址
//-----------------------------------------------------------------------
#ifndef HLP_L_SIZE
#define HLP_L_SIZE  4200                                                 //行数[变]
#endif
#define HLP_S_LEN   25                                                   //每行长度
//======================================================================================================================//
struct HLPTABLE                                                          //帮助结构
{
	char f;                                                                 //是否已经读取完文本
	char size[HLP_L_SIZE];                                                  //行长度
};
//*******************************************************函数表格*******************************************************//
//-----------------------------------------------------------------------
#define HPFUN_N_LEN 12                                                   //名称长度
#ifndef HPFUN_L_LEN
#define HPFUN_L_LEN 90                                                   //行数[变]
#endif
//======================================================================================================================//
struct HPFUNUNIT                                                         //基本结构
{
	char name[HPFUN_N_LEN];                                                 //名称
	char laddr;                                                             //地址低字节
	char haddr;                                                             //地址中字节
};

struct HPFUNTABLE                                                        //帮助函数结构
{
	char size;                                                              //大小
	struct HPFUNUNIT tem[HPFUN_L_LEN][2];                                   //数据域
};
#ifndef TIME_DELAY
#define TIME_DELAY  64													//输入时间延迟[变]
#endif
struct TIME
{
	int year;
	char month;
	char day;
	char hour;
	char minute;
	char second;
	char week;
};
//*******************************************************文件夹表*******************************************************//
#define DOCUM_TABLE 0x2000												//文件夹表地址
//-----------------------------------------------------------------------
#ifndef DOC_N_LEN
#define DOC_N_LEN   5													//名称长度[变]<=5
#endif
#ifndef DOC_D_SIZE
#define DOC_D_SIZE  230													//文件表长度[变]<=256
#endif
#define DOC_MOVE    2													//文件夹移动
//======================================================================================================================//
struct DOCUNIT															//基本结构
{
	char id;															//所属文件夹id号
	char name[DOC_N_LEN];												//名称
};
struct DOCTABLE															//文件夹表结构
{
	char size;															//文件夹表长度[与数据域顺序不可改变]
	struct DOCUNIT dat[DOC_D_SIZE];										//数据域[与文件夹表长度顺序不可改变]
};
//*******************************************************宏定义表*******************************************************//
//-----------------------------------------------------------------------
#ifndef MAC_N_LEN
#define MAC_N_LEN   19													//名称长度[变]<=19
#endif
#ifndef MAC_V_LEN
#define MAC_V_LEN   19													//值长度[变]<=19
#endif
#ifndef MAC_M_SIZE
#define MAC_M_SIZE  134													//宏表长度[变]<=256
#endif
#define MAC_MOVE    1													//宏移动
//======================================================================================================================//
struct MACUNIT															//基本结构
{
	char id;															//所属文件夹id号
	char name[MAC_N_LEN];												//名称
	char value[MAC_V_LEN];												//值
};
struct MACTABLE															//宏表结构
{
	char size;															//宏表长度[与数据域顺序不可改变]
	struct MACUNIT dat[MAC_M_SIZE];										//数据域[与宏表长度顺序不可改变]
};
//*******************************************************映射宏表*******************************************************//
//======================================================================================================================//
struct MACSHI															//映射宏表结构
{
	char sqr[MAC_M_SIZE];												//映射地址
	char size;															//映射宏表长度
};
//********************************************************缓冲区********************************************************//
#define TXT_CUSH    0x2000                                               //缓冲区地址
//-----------------------------------------------------------------------
#ifndef TXT_SIZE
#define TXT_SIZE    4000                                                 //缓冲区长度[变]
#endif
//======================================================================================================================//
struct TEXT                                                              //行信息
{
	int head;                                                               //行地址
	int size;                                                               //行大小
};
//*******************************************************文本链表*******************************************************//
//-----------------------------------------------------------------------
#ifndef TXT_T_SIZE
#define TXT_T_SIZE  100                                                  //表大小[变]
#endif
#define TXT_B_SIZE  TXT_SIZE/2                                           //块大小
#ifndef TXT_C_SIZE
#define TXT_C_SIZE  256                                                  //临时缓冲区大小[变]
#endif
//-----------------------------------------------------------------------[以下定义值不能变]
#define TXT_SAV_H   0                                                    //保存上一块
#define TXT_SAV_N   1                                                    //保存下一块
#define TXT_LOD_N   2                                                    //载入下一块
#define TXT_LOD_H   3                                                    //载入上一块
//======================================================================================================================//
struct BLOCK_UNIT
{
	char head;                                                              //上一块指针 无:254
	char next;                                                              //下一块指针 无:255
	char start[3];                                                          //文件中的数据起始地址
	char size[2];                                                           //块大小
	char fp;                                                                //块文件句柄
};
struct TXT_BLOCK                                                         //文本链表
{
	char head;                                                              //表头
	char h,n;                                                               //缓冲区头尾指针
	char size;                                                              //当前表大小
	char fp;                                                                //临时文件句柄
	char chg;                                                               //修改标志
	struct BLOCK_UNIT p[TXT_T_SIZE];                                        //表
};
//********************************************************剪贴板********************************************************//
//-----------------------------------------------------------------------
#ifndef CLI_SIZE
#define CLI_SIZE    255                                                  //剪切板长度[变]
#endif
//*******************************************************函数检索*******************************************************//
//-----------------------------------------------------------------------
#define SKFUN_N_LEN 12                                                   //名称长度
#ifndef SKFUN_L_LEN
#define SKFUN_L_LEN 130                                                  //个数[变]
#endif
//-----------------------------------------------------------------------[检索类型定义]
#define SK_NULL     0                                                    //无
#define SK_FUN      1                                                    //函数(不能变)
#define SK_BLANK    2                                                    //空格
#define SK_SEMI     3                                                    //分号(不能变)
#define SK_POINT    4                                                    //点号(不能变)
#define SK_CR       5                                                    //换行
#define SK_SYMBO    6                                                    //语句(不能变)
#define SK_BAO      7                                                    //包含号(<>,"")
//======================================================================================================================//
struct SKFUNUNIT                                                         //基本结构
{
	char n;                                                                 //前4 bit:参数个数.后4 bit:检索类型
	char name[SKFUN_N_LEN];                                                 //名称
};
struct SKFUNTABLE                                                        //帮助函数结构
{
	char size;                                                              //大小
	struct SKFUNUNIT dat[SKFUN_L_LEN];                                      //数据域
};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************中文输入*******************************************************//
#define PY_MAX      416                                                  //拼音个数
#define PY_ADD      80206                                                //拼音起始地址[资源重新编译则需要修改该值]
//======================================================================================================================//
struct PY_UNIT
{
	char str[7];                                                            //拼音
	int size;                                                               //同音字个数
	int add;                                                                //gb码地址
};
//******************************************************资源索引表******************************************************//
#define SRC_TABLE   0x2000                                               //资源索引表地址
//-----------------------------------------------------------------------
#define SRC_D_LEN   47                                                   //描述长度
#define SRC_M_SIZE  PUBLIC/8                                             //资源索引表长度
//======================================================================================================================//
struct _SRCUNIT                                                          //基本结构
{
	long id;                                                                //id号
	long add;                                                               //索引地址
};
struct SRCUNIT                                                           //基本结构
{
	char id[4];                                                             //id号
	char add[4];                                                            //索引地址
};
struct SRCTABLE                                                          //资源索引表结构
{
	char size[2];                                                           //资源索引表长度[与数据域顺序不可改变]
	struct SRCUNIT dat[SRC_M_SIZE];                                         //数据域[与资源索引表长度顺序不可改变]
};
//********************************************************缓冲区********************************************************//
#define FY_CUSH     0x2000												//缓冲区地址
#define DOCUM_LOAD  0x2000												//文件夹表地址
//-----------------------------------------------------------------------
#ifndef FY_C_SIZE
#define FY_C_SIZE   1500												//缓冲区长度[变]
#endif

#ifndef FY_C_REL
#define FY_C_REL    500													//缓冲偏移量[变]
#endif

//*******************************************************宏定义表*******************************************************//
//******************************************************子程序表格******************************************************//
#define LIB_LOAD    0x2000                                               //表格地址
//-----------------------------------------------------------------------
#ifndef LIB_N_LEN
#define LIB_N_LEN   200                                                  //子程序个数[变]
#endif
//======================================================================================================================//
struct LIB_UNIT
{
	char n[16];                                                             //子程序名
	char b;                                                                 //是否有返回值|是否作为接口
};
struct LIB
{
	char size;                                                              //大小
	struct LIB_UNIT f[LIB_N_LEN];                                           //子程序信息
};
//********************************************************缓冲区********************************************************//
//-----------------------------------------------------------------------
#ifndef LIB_C_LEN
#define LIB_C_LEN   3300                                                 //缓冲区大小[变]
#endif
//======================================================================================================================//
//********************************************************缓冲区********************************************************//
#define FB_CUSH		0x2000													//缓冲区地址
//-----------------------------------------------------------------------
#ifndef FB_C_SIZE
#define FB_C_SIZE	1500													//总缓冲区长度[变]
#endif

#define FB_C_REL	256														//代码缓冲长度
//*******************************************************变量空间*******************************************************//
#ifndef DIM_MAX
#define DIM_MAX		5														//数组最大维数+1[变]
#endif
//-----------------------------------------------------------------------
#define VGLOBOLE	0														//全局
#define VPART		1														//局部
#define VTEMP		2														//临时
#define VBACKUP		3														//备份

#define UNIT_COM	0														//基本
#define UNIT_STU	6														//结构体
#define UNIT_UNI	8														//共用体
#define V_POINT		18														//指针

#define UNIT_VAR	0														//变量
#define UNIT_ARR	4														//数组
#define UNIT_QFM	8														//结构引用


//#define G_STU_Q		(VGLOBOLE	+UNIT_STU+UNIT_QFM)							//外结构体引用14
//#define P_STU_Q		(VPART		+UNIT_STU+UNIT_QFM)							//内结构体引用15
//#define G_UNI_Q		(VGLOBOLE	+UNIT_UNI+UNIT_QFM)							//外共用体引用16
//#define P_UNI_Q									//内共用体引用17

																			//指针18~31

#define LVM_LABEL	98														//标号
#define LVM_FUN		99														//函数(要改的话,需重新生成函数文件)
#define LVM_SUB		100														//子程序
//-----------------------------------------------------------------------[以上需要存储]
#define NUMBER		138														//数字
#define LVM_SIZE	139														//sizeof
#define LVM_SIGN	140														//运算符
#define _LVM_T		115														//_TEXT等的偏移量
#define POINT		182														//.
#define STRING		183														//字符串
#define L_M_BRAC	184														//[
#define L_S_BRAC	185														//(
#define R_M_BRAC	186														//]
#define R_S_BRAC	187														//)
#define STIR_NUM	188														//,
#define LVM_SEMI	189														//;
//-----------------------------------------------------------------------[以下是语句]
#define R_B_BRAC	190														//}[与上面要连着]
#define L_B_BRAC	191														//{
#define LVM_BRK		192														//break
#define LVM_CONT	193														//continue
#define LVM_RET		194														//return
#define LVM_GOTO	195														//goto
#define LVM_IF		196														//if
#define LVM_ELSE	197														//else
#define LVM_FOR		198														//for
#define LVM_WHILE	199														//while
#define LVM_DO		200														//do

#define LVM_NULL	255														//空(不产生操作)
/*
-------------------------------------------------------------------------
struct结构:                           |union结构:
 byte=总字节长度                      | byte=最大字节长度
 value=与union结构的value一样         | value=地址(16[低]),标志[第几个结构],位置[STU_NUM,16-STU_NUM]
--------------------------------------|----------------------------------
成员结构:                             |成员结构:
 name=名称[第一个字节为标志]          | name=名称[第一个字节为标志]
 value=相对地址                       |
-------------------------------------------------------------------------
子程序结构:                           |struct或union引用结构:
 byte=类型                            | byte=总字节长度或最大字节长度
 value=地址                           | value=标志[第几个结构],位置[STU_NUM,16-STU_NUM(高2B)]
 dim[0]=标志[第几个子程序]            |
 dim[1]=参数个数                      |
--------------------------------------|----------------------------------
struct _VAR//变量                                                       映射到通用接口
{
	char t;                                                                 //类型->cv.t
	char b;                                                                 //字节->cv.b
	int v;                                                                  //地址->cv.v
};
struct _ARR//数组
{
	char t;                                                                 //类型->cv.t
	char b;                                                                 //字节->cv.b
	int v;                                                                  //地址->cv.v(2B)
	int d[DIM_MAX];                                                         //下标->cv.d(其中d[0]为维数)
};
struct _LAB//标号
{
	char t;                                                                 //类型->cv.t
	long v;                                                                 //地址->cv.v
	int f;                                                                  //标志->cv.d[0](第几个)
};
struct _FUN//函数
{
	char t;                                                                 //类型->cv.t
	char b;                                                                 //字节->cv.b
	char v;                                                                 //伪代码->cv.v
	char n;                                                                 //参数个数->cv.d[1]
};
struct _SUB//子程序
{
	char t;                                                                 //类型->cv.t
	int b;                                                                  //字节->cv.b
	long v;                                                                 //地址->cv.v
	int f;                                                                  //标志->cv.d[0](第几个)
	int n;                                                                  //参数个数->cv.d[1]
};
struct _STU//结构
{
	char t;                                                                 //类型->cv.t
	int b;                                                                  //字节->cv.b
	int f;                                                                  //标志->cv.v(高2B 第几个)
	int v;                                                                  //地址->cv.v(低2B)
	int d[DIM_MAX];                                                         //下标->cv.d(其中d[0]为维数)[可缺省]
};
struct _REF//引用
{
	char t;                                                                 //类型->cv.t
	int b;                                                                  //字节->cv.b
	int v;                                                                  //标志->cv.v(第几个)
};
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************变量链表*******************************************************//
#ifndef VAR_SIZE
#define VAR_SIZE	270														//变量链表大小[变]
#endif
//======================================================================================================================//
struct VAR_LINK
{
	int i;																	//当前指针
	int bh, ph;																//(空间bufhead,链表ptrhead)分界处
	int bt, pt;																//(空间buftail,链表ptrtail)结尾处
	int ptr[VAR_SIZE];														//链表
};
//-----------------------------------------------------------------------
struct COM_VAR//成员之间的相对位置不能改变
{
	char t;																	//type:类型
	int b;																	//byte:字节
	long v;																	//value:值
	int d[DIM_MAX];															//下标
	char n[MAC_N_LEN];														//名称[在查看/定义中]
};
struct TMP_VAR//临时接口(与COM_VAR保持一致)
{
	char t;																	//type:类型
	int b;																	//byte:字节
	long v;																	//value:值
	int d[DIM_MAX];															//下标
};
//*******************************************************跳转模块*******************************************************//
#ifndef N_A_MAX
#define N_A_MAX		8														//嵌套首地址栈大小[变]
#endif

#ifndef N_F_MAX
#define N_F_MAX		80														//嵌套标志栈大小[变]
#endif

#ifndef JP_SIZE
#define JP_SIZE		80														//跳转表大小[变]
#endif
//-----------------------------------------------------------------------
#define JP_TYP		3														//特征(共16B,其中高JMP_TYP位表示特征[下面])
//-----------------------------------------------------------------------
#define JP_CONT		0														//continue
#define JP_BRK		1														//break
#define JP_LABEL	2														//标号
#define JP_SUB		3														//子程序
#define JP_IF		4														//if
#define JP_DO		5														//do
#define JP_WHILE	6														//while
#define JP_FOR		7														//for
//======================================================================================================================//
struct UNIT_JUMP
{
	int t;																	//类型
	long a;																	//地址
};
struct JUMP_LINK
{
	char i;																	//嵌套首地址栈指针
	long t[N_A_MAX];														//嵌套首地址栈
	int j;																	//嵌套标志栈指针
	char f[N_F_MAX];														//嵌套标志栈
//----------------------------
	int size;																//跳转表大小
	struct UNIT_JUMP d[JP_SIZE];											//待值地址
};
//*******************************************************链接系统*******************************************************//
#ifndef LIB_SIZE
#define LIB_SIZE	6														//链接个数
#endif
//======================================================================================================================//
/*
 lib.name[0].t1 lib.name[0].t2:在Fun_deal()中使用
*/
struct TMPLIB																//16B[同时在编译系统中作为临时变量]
{
	long t1;
	long t2;
	char a[8];
};
struct LIBFILE
{
	char size;
	struct TMPLIB name[LIB_SIZE];
};
//*******************************************************记录变量*******************************************************//
struct OPERATOR                                                          //运算符
{
	char g;                                                                 //等级
	char c;                                                                 //伪代码
};
struct COMPILE
{
	char fp;                                                                //临时文件句柄
//----------------------------
	long offset;                                                            //偏移量
	long ary;                                                               //数组初始化所用空间
//----------------------------
	int add[4];                                                             //外,内,临时,备份变量地址起始
	char i;                                                                 //外,内,临时切换
//----------------------------
	char hp;                                                                //变量栈指针
	struct OPERATOR o;                                                      //运算符
	int fn;                                                                 //子程序个数
	int ln;                                                                 //标号个数
	char sn,ts;                                                             //结构体,共用体个数 备份结构体,共用体个数
//----------------------------
	char sf;                                                                //当前变量是否是静态变量 0:不是,1:是
	char la;                                                                //代码是否有#loadall 0:无,1:有
	char mai;                                                               //代码是否有main 0:没有,1:有
	char ma;                                                                //当前函数是否是main 0:不是,1:是
	char sub;                                                               //当前函数是否有返回值 0:无,1:有
};
//********************************************************存储区********************************************************//
char PubBuf[PUBLIC];													//公共缓冲区
//=======================================================编译系统=======================================================//
struct COM_VAR cv;														//通用接口（位置不能变）
struct VAR_LINK var;													//变量链表
//-----------------------------------------------------------------------
struct LIBFILE lib;														//链接文件存储[临时变量区，供编译系统使用]
//-----------------------------------------------------------------------
struct JUMP_LINK jp;													//跳转表
long jp_var;															//总空间地址
long jp_sub;															//子程序总变量地址
//-----------------------------------------------------------------------
char sign1[4];															//优化字符串1
char sign2[5];															//优化字符串2（与sign3对应）
char sign3[4];															//优化字符串3
char sign4[6];															//优化字符串4(顺序不能改变)
char sign5[5];															//优化字符串5
char sign6[3];															//优化字符串6
char sign7[5];															//优化字符串7
char sign8[6];															//优化字符串8
char sign9[4];															//优化字符串9
char sign10[7];															//优化字符串10
char sign11[3];															//优化字符串11
char sign12[6];															//优化字符串12
char sign13[9];															//优化字符串13
char sign14[5];															//优化字符串14
char sign15[4];															//优化字符串15
char sign16[3];															//优化字符串16
char sign17[3];															//优化字符串17
char sign18[3];															//优化字符串18
char sign19[3];															//优化字符串19
char sign20[3];															//优化字符串20
char sign21[5];															//优化字符串21
char sign22[4];															//优化字符串22
char sign23[5];															//优化字符串23
char sign24[5];															//优化字符串24
char sign25[7];															//优化字符串25
char sign26[3];															//优化字符串26
char sig[11];															//符号表(顺序不能改变)
char bol[69];															//运算符表
char code[23];															//符号表对应的伪代码表
char grad[23];															//符号等级表
struct COMPILE cp;														//记录
//////////////////////////////////////////////////////////私有区//////////////////////////////////////////////////////////
struct OUTFILE															//输出结构
{
	char fp;															//句柄
	char name[16];														//名称
	char path[60];														//路径
	int p;																//指针
};

struct INFILE															//输入结构
{
	char fp;															//句柄
	long size;															//大小
	int p;																//指针
};
struct OUTFILE out;														//文件输出
struct INFILE in;														//文件输入
int funjmp;																//函数跳转值
char cpldata[] = "/CplData";											//资源目录
char fundata[] = "/FunData";											//头文件目录
char libdata[] = "/LibData";											//链接库目录
char txtdata[] = "/文本文件";											//文本目录
//=======================================================设置系统=======================================================//
char datfp;																//数据文件句柄[帮助,设置,编辑,查看]
struct CONTABLE0 cfset;													//数据结构
//********************************************************程序区********************************************************//
long DataRead(long addrs, long size, long rel);							/* 数据读取 [通用] */
void UnInstall(struct ULIST &ul);										/* 卸载 */
long Input(char x, char y, int skey, int con);							/* 输入中文 */
int Var_Init();															/* 初始化内存 */
//*******************************************************按键定义*******************************************************//
#define F1_KEY		0x1c
#define F2_KEY		0x1d
#define F3_KEY		0x1e
#define F4_KEY		0x1f
#define CR_KEY		0x0d
#define ESC_KEY		0x1b
#define HELP_KEY	0x19
#define SHIFT_KEY	0x1a
#define CAPS_KEY	0x12
#define UP_KEY		0x14
#define	DOWN_KEY	0x15
#define LEFT_KEY	0x17
#define RIGHT_KEY	0x16
#define UU_KEY		0x13
#define DD_KEY		0x0e
#define A_KEY		'a'
#define D_KEY		'd'
#define M_KEY		'm'
#define S_KEY		's'
#define Y_KEY		'y'
#define N_KEY		'n'
//*******************************************************通用定义*******************************************************//
#define SWIN_COM	0														//普通
#define SWIN_ONE	1														//确定按钮
#define SWIN_TWO	2														//选择按钮
#define SWIN_STW	3														//选择按钮[不停止]
//----------------------------------------------------------------------------------------
#define BUTTON_UP	0														//按键突出
#define BUTTON_DOWN	1														//按键按下
//----------------------------------------------------------------------------------------
#define PIC_QUEN	0														//问号图片
#define PIC_WARN	1														//警告图片
#define PIC_BUSY	2														//忙忙图片
#define PIC_DOCU	3														//文件夹图片
//*******************************************************界面函数*******************************************************//
#if WQX == 0

char pic[][512]=//问号
{0x33,0x33,0x33,0x33,0x33,0x38,0x88,0x88,0x88,0x83,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x88,0x84,0x00,0x00,
 0x00,0x48,0x88,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x88,0x40,0x00,0x00,0x00,0x00,0x00,0x04,0x88,0x33,0x33,0x33,0x33,
 0x33,0x33,0x38,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x83,0x33,0x33,0x33,0x33,0x33,0x80,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x0F,0x33,0x33,0x33,0x33,0x38,0x00,0x00,0x00,0x04,0xBB,0xBB,0xBB,0x40,0x00,0x00,0x00,0xF3,0x33,0x33,
 0x33,0x80,0x00,0x00,0x00,0x4B,0x40,0x0B,0xBB,0xB4,0x00,0x00,0x00,0x0F,0x33,0x33,0x38,0x40,0x00,0x00,0x00,0xBB,0x00,0x00,
 0xBB,0xBB,0x00,0x00,0x00,0x04,0xF3,0x33,0x38,0x00,0x00,0x00,0x00,0xBB,0xBB,0x00,0xBB,0xBB,0x00,0x00,0x00,0x00,0xF8,0x33,
 0x84,0x00,0x00,0x00,0x00,0xBB,0xBB,0x04,0xBB,0xBB,0x00,0x00,0x00,0x00,0x4F,0x83,0x80,0x00,0x00,0x00,0x00,0x4B,0xB4,0x0B,
 0xBB,0xB0,0x00,0x00,0x00,0x00,0x0F,0x83,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x4B,0xBB,0x00,0x00,0x00,0x00,0x00,0x0F,0x88,
 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xBB,0xB0,0x00,0x00,0x00,0x00,0x00,0x0F,0x88,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xBB,
 0x40,0x00,0x00,0x00,0x00,0x00,0x0F,0x88,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xBB,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x88,
 0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4F,0x88,0x38,0x00,0x00,0x00,0x00,0x00,0x04,0xBB,
 0x40,0x00,0x00,0x00,0x00,0x00,0xF8,0x88,0x38,0x40,0x00,0x00,0x00,0x00,0x0B,0xBB,0xB0,0x00,0x00,0x00,0x00,0x04,0xF8,0x88,
 0x33,0x80,0x00,0x00,0x00,0x00,0x0B,0xBB,0xB0,0x00,0x00,0x00,0x00,0x0F,0x88,0x83,0x33,0x3F,0x00,0x00,0x00,0x00,0x04,0xBB,
 0x40,0x00,0x00,0x00,0x00,0xF8,0x88,0x83,0x33,0x33,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x88,0x88,0x33,
 0x33,0x33,0x3F,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xF8,0x88,0x83,0x33,0x33,0x33,0x33,0xFF,0x40,0x00,0x00,0x00,
 0x00,0x00,0x04,0xFF,0x88,0x88,0x33,0x33,0x33,0x33,0x33,0x38,0xFF,0xF4,0x00,0x00,0x00,0x4F,0xFF,0x88,0x88,0x83,0x33,0x33,
 0x33,0x33,0x33,0x33,0x88,0x8F,0xFF,0x40,0x00,0xF8,0x88,0x88,0x88,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x88,0x88,0xF0,
 0x00,0xF8,0x88,0x88,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x38,0xF0,0x00,0xF8,0x83,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0x00,0xF8,0x83,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0xF0,0xF8,0x83,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0xF8,0x83,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x88,0x83,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x38,0x83,0x33,0x33,0x33,0x33,0x33,//警告
 0x33,0x33,0x33,0x33,0x33,0x3F,0xFF,0xFF,0xFF,0xF3,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0xFF,0xFE,0xEE,0xEE,
 0xEE,0xEF,0xFF,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xF3,0x33,0x33,0x33,0x33,
 0x33,0x33,0x3F,0xFE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEF,0xF3,0x33,0x33,0x33,0x33,0x33,0xFE,0xEE,0xEE,0xEE,0xEE,0xEE,
 0xEE,0xEE,0xEE,0xEE,0xEF,0x33,0x33,0x33,0x33,0x3F,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xF3,0x33,0x33,
 0x33,0x3F,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xF8,0x33,0x33,0x33,0xFE,0xEE,0xEE,0xE0,0xEE,0xEE,0xEE,
 0xEE,0xEE,0x0E,0xEE,0xEE,0xEF,0x83,0x33,0x3F,0xEE,0xEE,0xEE,0x00,0x0E,0xEE,0xEE,0xEE,0xE0,0x00,0xEE,0xEE,0xEE,0xF3,0x33,
 0x3F,0xEE,0xEE,0xE0,0x00,0x00,0xEE,0xEE,0xEE,0x00,0x00,0x0E,0xEE,0xEE,0xF8,0x33,0x3F,0xEE,0xEE,0xEE,0x00,0x00,0x0E,0xEE,
 0xE0,0x00,0x00,0xEE,0xEE,0xEE,0xF8,0x83,0xFE,0xEE,0xEE,0xEE,0xE0,0x00,0x00,0xEE,0x00,0x00,0x0E,0xEE,0xEE,0xEE,0xEF,0x83,
 0xFE,0xEE,0xEE,0xEE,0xEE,0x00,0x00,0x00,0x00,0x00,0xEE,0xEE,0xEE,0xEE,0xEF,0x83,0xFE,0xEE,0xEE,0xEE,0xEE,0xE0,0x00,0x00,
 0x00,0x0E,0xEE,0xEE,0xEE,0xEE,0xEF,0x88,0xFE,0xEE,0xEE,0xEE,0xEE,0xEE,0x00,0x00,0x00,0xEE,0xEE,0xEE,0xEE,0xEE,0xEF,0x88,
 0xFE,0xEE,0xEE,0xEE,0xEE,0xEE,0x00,0x00,0x00,0xEE,0xEE,0xEE,0xEE,0xEE,0xEF,0x88,0xFE,0xEE,0xEE,0xEE,0xEE,0xE0,0x00,0x00,
 0x00,0x0E,0xEE,0xEE,0xEE,0xEE,0xEF,0x88,0xFE,0xEE,0xEE,0xEE,0xEE,0x00,0x00,0x00,0x00,0x00,0xEE,0xEE,0xEE,0xEE,0xEF,0x88,
 0xFE,0xEE,0xEE,0xEE,0xE0,0x00,0x00,0xEE,0x00,0x00,0x0E,0xEE,0xEE,0xEE,0xEF,0x88,0x3F,0xEE,0xEE,0xEE,0x00,0x00,0x0E,0xEE,
 0xE0,0x00,0x00,0xEE,0xEE,0xEE,0xF8,0x88,0x3F,0xEE,0xEE,0xE0,0x00,0x00,0xEE,0xEE,0xEE,0x00,0x00,0x0E,0xEE,0xEE,0xF8,0x88,
 0x3F,0xEE,0xEE,0xEE,0x00,0x0E,0xEE,0xEE,0xEE,0xE0,0x00,0xEE,0xEE,0xEE,0xF8,0x83,0x33,0xFE,0xEE,0xEE,0xE0,0xEE,0xEE,0xEE,
 0xEE,0xEE,0x0E,0xEE,0xEE,0xEF,0x88,0x83,0x33,0x3F,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xF8,0x88,0x83,
 0x33,0x3F,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xF8,0x88,0x33,0x33,0x33,0xFE,0xEE,0xEE,0xEE,0xEE,0xEE,
 0xEE,0xEE,0xEE,0xEE,0xEF,0x88,0x83,0x33,0x33,0x33,0x3F,0xFE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEF,0xF8,0x88,0x83,0x33,
 0x33,0x33,0x33,0x8F,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xF8,0x88,0x88,0x33,0x33,0x33,0x33,0x33,0x38,0xFF,0xFE,0xEE,0xEE,
 0xEE,0xEF,0xFF,0x88,0x88,0x83,0x33,0x33,0x33,0x33,0x33,0x33,0x38,0x8F,0xFF,0xFF,0xFF,0xF8,0x88,0x88,0x83,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x38,0x88,
 0x88,0x88,0x83,0x33,0x33,0x33,0x33,0x33,//忙忙
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x3a,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x3d,0xfc,0xcd,0xcd,0xcd,
 0xcd,0xcc,0xdc,0xef,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x38,0xd6,0x66,0x66,0x66,0x66,0x66,0x66,0xca,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0xe6,0x66,0x66,0x66,0x66,0x67,0x66,0xc2,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0xd3,0x33,0x33,0x33,
 0x33,0x33,0x33,0xa3,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0xd1,0x32,0x12,0x23,0x31,0x12,0x31,0xa3,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0xbc,0x28,0x68,0x86,0x97,0x88,0x1a,0xc2,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x1a,0xc1,0x78,0x87,
 0x87,0x71,0xbc,0x23,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x31,0xbd,0x37,0x6b,0x49,0x1a,0xd2,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x3a,0xd1,0x85,0xa1,0xad,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0xbc,0x27,
 0x1a,0xc1,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x3f,0x63,0x3f,0x63,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x3f,0x6a,0x3f,0x63,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x5f,0x53,
 0x2e,0x83,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x35,0xe5,0x35,0x33,0xd8,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x6e,0x53,0x35,0x83,0x4e,0x73,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x35,0xe5,0x33,0x33,
 0x23,0x32,0xf7,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x6e,0x53,0x37,0x6b,0x49,0x13,0x2e,0x73,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0xe5,0x33,0x78,0x86,0x97,0x81,0x34,0xd3,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0xc3,0x37,0x78,0x87,
 0x87,0x79,0x33,0x93,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0xd3,0x75,0xa7,0x7a,0x49,0x85,0x93,0x93,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x32,0xfc,0xdc,0xcc,0xcc,0xdc,0xcc,0xdc,0xe5,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x3d,0xd6,0x66,0x76,0x67,
 0x66,0x76,0x67,0xcf,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x3d,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,//文件夹
 0x33,0x33,0x33,0x31,0x11,0x11,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x31,0x45,0x45,0x55,0x67,0x53,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x37,0x32,0x22,0x11,0x31,0x84,0x33,0x33,0x33,0x32,0x24,0x56,0x51,0x33,0x33,
 0x33,0x36,0x32,0x12,0x21,0x23,0x38,0x31,0x45,0x78,0x65,0x44,0x11,0x66,0x33,0x33,0x33,0x61,0x12,0x22,0x12,0x22,0x33,0x65,
 0x32,0x33,0x31,0x12,0x34,0x79,0x75,0x13,0x33,0x53,0x22,0x12,0x22,0x22,0x11,0x32,0x23,0x46,0x56,0x66,0x65,0x42,0x28,0x53,
 0x34,0x41,0x22,0x22,0x22,0x12,0x22,0x67,0x56,0x54,0x33,0x11,0x33,0x23,0x19,0x71,0x34,0x41,0x22,0x22,0x12,0x22,0x18,0x51,
 0x33,0x33,0x33,0x33,0x13,0x41,0x3A,0x63,0x33,0x41,0x22,0x22,0x33,0x34,0x75,0x31,0x11,0x11,0x31,0x11,0x13,0x43,0x3a,0x53,
 0x33,0x42,0x25,0x56,0x66,0x66,0x33,0x11,0x11,0x11,0x11,0x11,0x13,0x41,0x4a,0x43,0x33,0x52,0x86,0x43,0x22,0x13,0x11,0x11,
 0x11,0x11,0x11,0x11,0x21,0x43,0x59,0x43,0x32,0x53,0x83,0x11,0x11,0x11,0x21,0x11,0x12,0x12,0x12,0x11,0x11,0x41,0x79,0x33,
 0x32,0x43,0x63,0x21,0x21,0x12,0x12,0x12,0x11,0x21,0x11,0x21,0x21,0x43,0x88,0x23,0x32,0x54,0x61,0x21,0x22,0x21,0x22,0x12,
 0x22,0x12,0x22,0x21,0x21,0x41,0x97,0x23,0x32,0x56,0x61,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x41,0xa7,0x33,
 0x31,0x55,0x41,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x42,0xa6,0x33,0x31,0x56,0x42,0x22,0x22,0x23,0x22,0x22,
 0x22,0x22,0x22,0x22,0x22,0x34,0xa5,0x33,0x31,0x58,0x41,0x32,0x23,0x22,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x45,0xa4,0x33,
 0x33,0x68,0x32,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x22,0x32,0x32,0x46,0xa3,0x33,0x33,0x48,0x23,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x32,0x48,0x92,0x33,0x33,0x59,0x23,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x48,0x81,0x33,
 0x33,0x59,0x13,0x33,0x43,0x33,0x33,0x33,0x33,0x33,0x43,0x33,0x33,0x49,0x83,0x33,0x33,0x59,0x14,0x33,0x33,0x34,0x33,0x43,
 0x43,0x43,0x33,0x32,0x44,0x6a,0x61,0x33,0x33,0x49,0x14,0x34,0x43,0x43,0x34,0x34,0x33,0x33,0x35,0x68,0x99,0xaa,0x53,0x33,
 0x33,0x49,0x14,0x44,0x34,0x44,0x44,0x34,0x45,0x78,0x9a,0xa9,0x87,0x53,0x33,0x33,0x33,0x48,0x14,0x44,0x44,0x34,0x55,0x79,
 0x9a,0xa9,0x86,0x53,0x11,0x33,0x33,0x33,0x33,0x47,0x24,0x35,0x56,0x88,0xaa,0x99,0x76,0x43,0x13,0x33,0x33,0x33,0x33,0x33,
 0x33,0x37,0x47,0x88,0xaa,0xa9,0x85,0x42,0x13,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x28,0xaa,0x99,0x65,0x21,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x32,0x64,0x31,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,
 0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33};

void textout(int x, int y, char &str[], int type)
{
	TextOut(x, y, str, type|3);
	TextOut(x, y + 1, str, type|3);
	TextOut(x, y + 2, str, type|3);
	TextOut(x + 1, y, str, type|3);
	TextOut(x + 1, y + 1, str, type|3);
	TextOut(x + 1, y + 2, str, type|3);
	TextOut(x + 2, y, str, type|3);
	TextOut(x + 2, y + 1, str, type|3);
	TextOut(x + 2, y + 2, str, type|3);
	SetBgColor(0);
	TextOut(x + 1, y + 1, str, type|5);
	SetBgColor(3);
}

void Boxw(int x, int y, char &tag[])
{
	Rectangle(x, y, x + strlen(tag) * 6 + 3, y + 13, 1);
	TextOut(x + 2, y + 1, tag, 1);
}

void MyLine(int x0, int y0, int x1, int y1, int type)
{
	SetBgColor(9);
	Line(x0, y0, x1, y1, type);
	SetBgColor(0);
	Line(x0 + 1, y0 + 1, x1 + 1, y1 + 1, type);
}

void MyBox(int x0, int y0, int x1, int y1, int type)
{
	char cmd, mode;
	cmd = type&0xf;
	if (type >> 4) mode = 0;
	else mode = 64;
	if (cmd < 2)
	{
		SetBgColor(cmd * 12);
		Line(x0, y0, x0, y1 - 1, mode);
		Line(x0, y0, x1 - 1, y0, mode);
		SetBgColor(12 - cmd * 12);
		Line(x1, y0, x1, y1, mode);
		Line(x0, y1, x1, y1, mode);
		SetBgColor(3);
		return;
	}
	SetBgColor(3);
	Block(x0, y0, x1, y1, 0);
	if (cmd == 2)
	{
		SetBgColor(0);
		Line(x0, y0, x0, y1 - 1, mode);
		Line(x0, y0, x1 - 1, y0, mode);
		SetBgColor(12);
		Line(x0, y1, x1, y1, mode);
		Line(x1, y0, x1, y1, mode);
		SetBgColor(9);
		Line(x0 + 1, y1 - 1, x1 - 1, y1 - 1, mode);
		Line(x1 - 1, y0 + 1, x1 - 1, y1 - 1, mode);
	}
	else if (cmd == 3)
	{
		SetBgColor(12);
		Line(x0, y1, x1, y1, mode);
		Line(x1, y0, x1, y1, mode);
		SetBgColor(0);
		Line(x0 + 1, y0 + 1, x0 + 1, y1 - 2, mode);
		Line(x0 + 1, y0 + 1, x1 - 2, y0 + 1, mode);
		SetBgColor(9);
		Line(x1 - 1, y0 + 1, x1 - 1, y1 - 1, mode);
		Line(x0 + 1, y1 - 1, x1 - 1, y1 - 1, mode);
	}
	else if (cmd == 4)
	{
		MyLine(x0,y0,x0,y1,mode);
		MyLine(x0,y0,x1,y0,mode);
		MyLine(x1,y0,x1,y1,mode);
		MyLine(x0,y1,x1,y1,mode);
	}
	SetBgColor(3);
}

void Tool(int x, int y, int type)
{
	MyBox(x, y, x + 11, y + 10, 2);
	if (type == 3)
	{
		Line(x + 2, y + 2, x + 7, y + 7, 65);
		Line(x + 3, y + 2, x + 8, y + 7, 65);
		Line(x + 2, y + 7, x + 7, y + 2, 65);
		Line(x + 3, y + 7, x + 8, y + 2, 65);
	}
	else if (type == 2)
	{
		Rectangle(x + 2, y + 2, x + 8, y + 7, 1);
		Line(x + 3, y + 3, x + 7, y + 3, 65);
	}
	else if (type == 1)
	{
		Line(x + 3, y + 7, x + 7, y + 7, 65);
		Line(x + 3, y + 6, x + 7, y + 6, 65);
	}
}

void Button(int x, int y, char &tag[], int cmd)/*按钮*/
{
	int len;

	len = x + strlen(tag) * 6 + 2;
	if (cmd == BUTTON_UP)
	{
		MyBox(x, y, len, y + 13, 0);
		TextOut(x + 1, y + 1, tag, 1);
	}
	else if (cmd == BUTTON_DOWN)
	{
		Box(x, y, len, y + 13, 1, 1);
		Delay(cfset.dat[3].tem[0].value * 5);
		Refresh();
	}
}

void Dwin(char &tag[])/* 大框框 */
{
	MyBox(1, 0, 159, 79, 3);
	textout(6, 3, tag, 1);
	Block(4, 3, 156, 16, 2);
	Tool(120, 5, 1);
	Tool(132, 5, 2);
	Tool(144, 5, 3);
}

int Swin(char &tag[], char &msg[], int type)/*小框框|type:0普通, 1确定, 2选择, 3选择, */
{
	char key;
	char str[3][6];

	strcpy(str[0], "是[Y]");
	strcpy(str[1], "否[N]");
	strcpy(str[2], "确 定");
	MyBox(13, 17, 143, 76, 3);
	textout(18, 20, tag, 1);
	Block(16, 20, 140, 33, 2);
	Tool(104, 22, 1);
	Tool(116, 22, 2);
	Tool(128, 22, 3);
	if (type == SWIN_COM) return(0);
	TextOut(92 - strlen(msg) * 3, 38, msg, 1);
	if (type == SWIN_ONE)//单按钮
	{
		WriteBlock(17, 36, 32, 32, 1, pic[PIC_WARN]);
		Button(78, 57, str[2], BUTTON_UP);
		Refresh();
		if (!cfset.dat[0].tem[2].value) Beep();
		while (getchar() != CR_KEY);
		Button(78, 57, str[2], BUTTON_DOWN);//响应
	}
	else
	{
		WriteBlock(17, 36, 32, 32, 1, pic[PIC_QUEN]);
		Button(55, 57, str[0], BUTTON_UP);
		Button(98, 57, str[1], BUTTON_UP);
		if (type == SWIN_STW) return(0);
		Refresh();
		for(;;)
		{
			key = getchar();
			if (key == Y_KEY || key == CR_KEY)
			{
				Button(55, 57, str[0], BUTTON_DOWN);
				return(1);
			}
			else if (key == N_KEY || key == ESC_KEY || key=='q')
			{
				Button(98, 57, str[1], BUTTON_DOWN);
				return(0);
			}
		}
	}
}

#else

char pic[][128]=//问号
{0x00,0x1F,0xE0,0x00,0x00,0xE0,0x1C,0x00,0x03,0x00,0x03,0x00,0x04,0x00,0x00,0x80,0x08,0x00,0x00,0x40,0x10,0x0F,0xC0,0x20,
 0x20,0x11,0xE0,0x10,0x40,0x30,0xF0,0x08,0x40,0x3C,0xF0,0x0C,0x80,0x3C,0xF0,0x06,0x80,0x19,0xE0,0x06,0x80,0x01,0xC0,0x07,
 0x80,0x03,0x80,0x07,0x80,0x03,0x00,0x07,0x80,0x03,0x00,0x07,0x80,0x00,0x00,0x07,0x40,0x03,0x00,0x0F,0x40,0x07,0x80,0x0F,
 0x20,0x07,0x80,0x1E,0x10,0x03,0x00,0x3E,0x08,0x00,0x00,0x7C,0x04,0x00,0x00,0xF8,0x03,0x00,0x03,0xF0,0x01,0xE0,0x1F,0xE0,
 0x00,0xFC,0x3F,0xC0,0x00,0x3E,0x3F,0x00,0x00,0x06,0x38,0x00,0x00,0x01,0x38,0x00,0x00,0x00,0xB8,0x00,0x00,0x00,0x78,0x00,
 0x00,0x00,0x38,0x00,0x00,0x00,0x18,0x00,//警告
 0x00,0x07,0x00,0x00,0x00,0x08,0x80,0x00,0x00,0x10,0x60,0x00,0x00,0x10,0x70,0x00,0x00,0x20,0x38,0x00,0x00,0x20,0x38,0x00,
 0x00,0x40,0x1C,0x00,0x00,0x40,0x1C,0x00,0x00,0x80,0x0E,0x00,0x00,0x87,0x0E,0x00,0x01,0x0F,0x87,0x00,0x01,0x0F,0x87,0x00,
 0x02,0x0F,0x83,0x80,0x02,0x0F,0x83,0x80,0x04,0x0F,0x81,0xC0,0x04,0x07,0x01,0xC0,0x08,0x07,0x00,0xE0,0x08,0x07,0x00,0xE0,
 0x10,0x02,0x00,0x70,0x10,0x02,0x00,0x70,0x20,0x02,0x00,0x38,0x20,0x00,0x00,0x38,0x40,0x03,0x00,0x1C,0x40,0x07,0x80,0x1C,
 0x80,0x07,0x80,0x0E,0x80,0x03,0x00,0x0E,0x80,0x00,0x00,0x0F,0x80,0x00,0x00,0x0F,0x40,0x00,0x00,0x1F,0x3F,0xFF,0xFF,0xFF,
 0x0F,0xFF,0xFF,0xFE,0x07,0xFF,0xFF,0xFC,//忙忙
 0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x00,0x00,0x40,0x01,0x00,0x00,0x40,0x01,0x00,0x00,0x40,0x01,0x00,0x00,0x40,0x01,0x00,
 0x00,0x55,0x55,0x00,0x00,0x6A,0xAB,0x00,0x00,0x55,0x55,0x00,0x00,0x2A,0xAA,0x00,0x00,0x15,0x54,0x00,0x00,0x0A,0xA8,0x00,
 0x00,0x05,0x50,0x00,0x00,0x02,0xA0,0x00,0x00,0x01,0x40,0x00,0x00,0x00,0x80,0x00,0x00,0x01,0x40,0x00,0x00,0x02,0x20,0x00,
 0x00,0x04,0x10,0x00,0x00,0x08,0x08,0x00,0x00,0x10,0x04,0x00,0x00,0x20,0x02,0x00,0x00,0x40,0x01,0x00,0x00,0x41,0x41,0x00,
 0x00,0x42,0xA1,0x00,0x00,0x45,0x51,0x00,0x00,0x4A,0xA9,0x00,0x00,0x55,0x55,0x00,0x00,0x6A,0xAB,0x00,0x00,0x55,0x55,0x00,
 0x00,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,//文件夹
 0x00,0x00,0x00,0x00,0x07,0xe0,0x00,0x00,0x1f,0xf8,0x00,0x00,0x30,0x0e,0x03,0xf0,0x20,0x03,0xfe,0x18,0x60,0x03,0x00,0x1e,
 0x40,0x00,0x07,0xff,0x40,0x00,0x3c,0x07,0x40,0x01,0xe0,0x07,0x40,0x0f,0x00,0x07,0x40,0xf8,0x00,0x07,0x47,0x80,0x00,0x16,
 0x5c,0x00,0x00,0x16,0x50,0x00,0x00,0x16,0x50,0x00,0x00,0x16,0x50,0x00,0x00,0x16,0x50,0x00,0x00,0x16,0x70,0x00,0x00,0x16,
 0x70,0x00,0x00,0x16,0x70,0x00,0x00,0x16,0x30,0x00,0x00,0x1e,0x30,0x00,0x00,0x1e,0x30,0x00,0x00,0x1e,0x30,0x00,0x00,0x1c,
 0x30,0x00,0x00,0x7c,0x30,0x00,0x03,0xfc,0x30,0x00,0x1f,0xfc,0x30,0x01,0xff,0xc0,0x30,0x3f,0xfc,0x00,0x3b,0xff,0x80,0x00,
 0x1f,0xf0,0x00,0x00,0x1f,0x00,0x00,0x00};

void textout(int x, int y, char &str[], int type)
{
	char xlen;
	char ylen;
	char data[200];
	char buf[200];

	if (type&0x80)
	{
		xlen = strlen(str) * 8;
		ylen = 16;
	}
	else
	{
		xlen = strlen(str) * 6;
		ylen = 12;
	}
	if (xlen&7)
	{
		xlen = (xlen&0xf8) + 0x08;
	}
	GetBlock(0, 0, xlen, ylen, 0, buf);
	Block(0, 0, xlen - 1, ylen - 1, 0);
	TextOut(0, 0, str, type&0xbf);
	GetBlock(0, 0, xlen, ylen, 0, data);
	WriteBlock(0, 0, xlen, ylen, 1, buf);
	TextOut(x, y, str, type|3);
	TextOut(x, y + 1, str, type|3);
	TextOut(x, y + 2, str, type|3);
	TextOut(x + 1, y, str, type|3);
	TextOut(x + 1, y + 1, str, type|3);
	TextOut(x + 1, y + 2, str, type|3);
	TextOut(x + 2, y, str, type|3);
	TextOut(x + 2, y + 1, str, type|3);
	TextOut(x + 2, y + 2, str, type|3);
	WriteBlock(x + 1, y + 1, xlen, ylen, type|5, data);
}

void Boxw(int x, int y, char &tag[])
{
	Rectangle(x, y, x + strlen(tag) * 6 + 7, y + 13, 1);
	TextOut(x + 4, y + 1, tag, 1);
}

void Button(int x, int y, char &tag[], int cmd)/*按钮*/
{
	int len;

	len = x + strlen(tag) * 6 + 2;
	if (cmd == BUTTON_UP)
	{
		Block(x + 1, y + 1, len + 1, y + 14, 1);
		Block(x, y, len, y + 13, 0);
		TextOut(x + 1, y + 1, tag, 1);
		Rectangle(x, y, len, y + 13, 1);
	}
	else if (cmd == BUTTON_DOWN)
	{
		Box(x, y, len, y + 13, 1, 1);
		Delay(cfset.dat[3].tem[0].value * 5);
		Refresh();
	}
}

void Sbox(int x1, int y1, int x2, int y2)
{
	Line(x1 + 1, y1, x2 - 1, y1, 65);
	Line(x1 + 1, y2, x2 - 1, y2, 65);
	Line(x1, y1 + 1, x1, y2 - 1, 65);
	Line(x2, y1 + 1, x2, y2 - 1, 65);
}

void Dwin(char &tag[])/*大框框*/
{
	ClearScreen();
	//TextOut(3, 2, tag, 1);
	textout(3, 1, tag, 1);
	Rectangle(1, 0, 159, 79, 1);
	Sbox(120, 2, 131, 13);
	Rectangle(122, 10, 129, 11, 1);
	Sbox(133, 2, 144, 13);
	Rectangle(135, 4, 142, 11, 1);
	Line(135, 5, 142, 5, 65);
	Sbox(146, 2, 157, 13);
	Line(149, 5, 154, 10, 65);
	Line(149, 10, 154, 5, 65);
	Line(1, 15, 159, 15, 65);
	Block(2, 1, 158, 14, 2);
}

int Swin(char &tag[], char &msg[], int type)/*小框框|type:0普通, 1确定, 2选择, 3选择, */
{
	char key;
	char str[3][6];

	strcpy(str[0], "是[Y]");
	strcpy(str[1], "否[N]");
	strcpy(str[2], "确 定");
	Block(15, 18, 141, 73, 0);
	Rectangle(15, 18, 140, 72, 1);
	Line(141, 19, 141, 73, 65);
	Line(16, 73, 141, 73, 65);
	//TextOut(17, 20, tag, 1);
	textout(17, 19, tag, 1);
	Sbox(101, 20, 112, 31);
	Rectangle(103, 28, 110, 29, 1);
	Sbox(114, 20, 125, 31);
	Rectangle(116, 22, 123, 29, 1);
	Line(116, 23, 123, 23, 65);
	Sbox(127, 20, 138, 31);
	Line(130, 23, 135, 28, 65);
	Line(130, 28, 135, 23, 65);
	Line(15, 33, 140, 33, 65);
	if (type == SWIN_COM) return(0);
	TextOut(92 - strlen(msg) * 3, 37, msg, 1);
	if (type == SWIN_ONE)//单按钮
	{
		WriteBlock(17, 35, 32, 32, 1, pic[PIC_WARN]);
		Button(78, 56, str[2], BUTTON_UP);
		Refresh();
		if (!cfset.dat[0].tem[2].value) Beep();
		while (getchar() != CR_KEY);
		Button(78, 56, str[2], BUTTON_DOWN);//响应
	}
	else
	{
		WriteBlock(17, 35, 32, 32, 1, pic[PIC_QUEN]);
		Button(55, 56, str[0], BUTTON_UP);
		Button(98, 56, str[1], BUTTON_UP);
		if (type == SWIN_STW) return(0);
		Refresh();
		for (;;)
		{
			key = getchar();
			if (key == Y_KEY || key == CR_KEY)
			{
				Button(55, 56, str[0], BUTTON_DOWN);
				return(1);
			}
			else if (key==N_KEY || key == ESC_KEY || key == 'q')
			{
				Button(98, 56, str[1], BUTTON_DOWN);
				return(0);
			}
		}
	}
}
#endif

void Progress(long cur, long len, int cmd)/*进度显示*/
{
	if(!cmd)
	{
		Block(47, 47, cur * 101 / len + 47, 53, 1);
	}
	else
	{
		Dwin("进度");
		TextOut(64, 22, cur, 129);
		TextOut(3, 63, "状态:", 1);
		Button(34, 61, len, BUTTON_UP);
		Block(45, 45, 150, 55, 0);
#if WQX==0
		MyBox(45, 45, 150, 55, 1);
#else
		Rectangle(45, 45, 150, 55, 1);
#endif
		WriteBlock(8, 20, 32, 32, 1, pic[PIC_BUSY]);
	}
	Refresh();
}

void Exit()/*退出画面*/
{
	char n;

	Dwin("退出");
	//TextOut(48, 30, "谢谢使用", 129);
	textout(48, 30, "谢谢使用", 0x81);
	//Rectangle(46, 28, 113, 47, 1);
	//Rectangle(44, 26, 115, 49, 1);
	TextOut(4, 53, "yan制作", 1);
	TextOut(4, 65, "Email:yanggynb@163.com", 1);
	Refresh();//刷新
	for (n = 0; n < 100; n++)
	{
		Delay(20);
		if (Inkey()) return;
	}
}

void Success(int cmd)//0:h,1:lav,2:y
{
	char msg[16], i;

	Dwin("成功");
	TextOut(48, 24, "编译完成", 129);
	Rectangle(46, 22, 113, 41, 1);
	Rectangle(44, 20, 115, 43, 1);
	Line(2, 62, 158, 62, 65);
	Line(2, 76, 158, 76, 65);//图形
	TextOut(2, 50, "名称:", 9);
	strcpy(msg, out.name);
	if (strlen(msg) > 8)
	{
		for (i = 0; i < 7; i++)
		{
			if (msg[i] > 128)
			{
				if (i > 5) break;
				i++;
			}
		}
		strcpy(msg + i, "~");
	}
	TextOut(32, 50, msg, 1);//显示名称
	TextOut(80, 50, "认证:", 9);
	if (cmd) sprintf(msg, "%dB", cp.add[VGLOBOLE] - 0x2000);
	else strcpy(msg, "0B");
	TextOut(110, 50, msg, 1);
	TextOut(80, 64, "目录:", 9);//目录
	if (cmd == 2) TextOut(110, 64, "/LibData", 1);
	else if (cmd)
	{
		in.size = cp.offset;
		TextOut(110, 64, cfset.lav, 1);
	}
	else TextOut(110, 64, "/FunData", 1);
	TextOut(2, 64, "大小:", 9);
	sprintf(msg, "%dB", in.size);
	TextOut(32, 64, msg, 1);//显示大小
	Refresh();
	if (!cfset.dat[0].tem[2].value)//刷新，声音
	{
		Beep();
		Delay(100);
		Beep();
	}
	for (i = 0; i < 255 || !cfset.dat[1].tem[3].value; i++)//暂停
	{
		Delay(20);
		if (Inkey()) return;
	}
}

void PrintMsg(char &s[][30], char type)
{
	char i;

	if (type) Dwin("配置");
	else Dwin("帮助");
	for (i = 0; i < 5 && s[i][0]; i++)
	{
		TextOut(4, i * 12 + 17, s[i], 1);
	}
	Refresh();
}
void ShowSet()
{
	char key;
	char s[5][30];

_S1:
	strcpy	(s[0], "帮助系统:");
	sprintf	(s[1], " 最大载入文本:%d字节", HLP_L_SIZE * 25);
	sprintf	(s[2], " 最大索引个数:%d个", HPFUN_L_LEN * 2);
	strcpy	(s[3], "编辑系统:");
	sprintf	(s[4], " 缓冲区大小:%d字节", TXT_SIZE);
	PrintMsg(s, 1);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
	if (key == ESC_KEY || key == 'q') return;
_S2:
	sprintf	(s[0], " 最大可编辑:%d字节", TXT_B_SIZE * TXT_T_SIZE);
	sprintf	(s[1], " 剪切板大小:%d字节", CLI_SIZE);
	sprintf	(s[2], " 最大检索个数:%d个", SKFUN_L_LEN);
	strcpy	(s[3], "编译系统:");
	sprintf	(s[4], " 支持最大变量个数:%d个", VAR_SIZE);
	PrintMsg(s, 1);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
	if (key == ESC_KEY || key == 'q') return;
_S3:
	sprintf	(s[0], " 最大变量名长度:%d字节", MAC_N_LEN - 1);
	sprintf	(s[1], " 数组最大维数:%d维", DIM_MAX - 1);
	sprintf	(s[2], " 支持最大嵌套层:%d层", N_A_MAX);
	sprintf	(s[3], " 跳转表大小:%d个", JP_SIZE);
	sprintf	(s[4], " 最大y库包含个数:%d个", LIB_SIZE);
	PrintMsg(s, 1);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S2;
	if (key == ESC_KEY || key == 'q') return;
_S4:
	strcpy	(s[0], "宏管理系统:");
	sprintf	(s[1], " 最大文件夹个数:%d个", DOC_D_SIZE);
	sprintf	(s[2], " 最大宏定义个数:%d个", MAC_M_SIZE);
	strcpy	(s[3], "链接库系统:");
	sprintf	(s[4], " 支持最大函数个数:%d个", LIB_N_LEN);
	PrintMsg(s, 1);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S3;
	if (key == ESC_KEY || key == 'q') return;
	strcpy	(s[0], "资源管理系统:");
	sprintf	(s[1], " 最大记录个数:%d个", SRC_M_SIZE);
	sprintf	(s[2], " 最大描述长度:%d字节", SRC_D_LEN - 1);
	s[3][0] = s[4][0] = 0;
	PrintMsg(s, 1);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S4;
}

void ShowHelp()
{
	char s[5][30];

	strcpy(s[0], "方向键    :上一行或下一行");
	strcpy(s[1], "ESC键,q键 :返回上一级界面");
	strcpy(s[2], "输入键    :执行菜单项目");
	strcpy(s[3], "求助键    :显示求助信息");
	s[4][0] = 0;
	PrintMsg(s, 0);
	getchar();
}

void ShowMeiri(long rel, int j, int size)
{
	char i,n;
	char s[4][17];

	memset(s, 0, 17 * 4);
	if (size - j > 4) n = 4;
	else n = size - j;
	fseek(datfp, rel + j * 17, 0);
	fread(s, 1, n * 17, datfp);
	for (i = 0; i < n && s[i][0]; i++)
	{
		TextOut(8, i * 14 + 22, s[i], 1);
	}
}

int SubMenu(int s, char num, char x, char y)/*子菜单*/
{
	char value, key;
	char str[16], len, i;

	value = 0;
	len = strlen(s) / num;
	for (;;)
	{
#if WQX == 0
		SetBgColor(0);
		Block(x - 1, y - 1, x + len * 6 + 11, y + num * 14 + 4, 0);
		MyBox(x, y, x + len * 6 + 10, y + num * 14 + 3, 4);
#else
		Block(x - 1, y - 1, x + len * 6 + 11, y + num * 14 + 4, 0);
		Rectangle(x, y, x + len * 6 + 10, y + num * 14 + 3, 1);
#endif
		for (i = 0; i < num; i++)
		{
			memset(str, 0, 16);
			memcpy(str, s + len * i, len);
			TextOut(x + 5, y + i * 14 + 3, str, 1);
		}
		Block(x + 2, y + value * 14 + 2, x + len * 6 + 8, y + value * 14 + 15, 2);
		Refresh();
		key = getchar();//响应
		if (key == UP_KEY)
		{
			if (value)
			{
				value--;
			}
			else
			{
				value = num - 1;
			}
		}
		else if (key == DOWN_KEY)
		{
			if (value + 1 < num)
			{
				value++;
			}
			else
			{
				value = 0;
			}
		}
		else if (key == CR_KEY) return(value + 4);
		else if (key == ESC_KEY || key == 'q') return(0);
	}
}

int Menu(char value)/*主菜单*/
{
	long rel, n;//偏移地址
	int k, size;
	char key, tv;
	char i, j, flag;//动画

	funjmp = &value - 5;
	i = 0;
	j = 40;
	flag = 1;
	if (value >= 9)
	{
		value = 2;
	}
	else if (value >= 6)
	{
		value = 0;
	}
	if (!cfset.dat[3].tem[2].value)
	{
		rel = DataRead(&k, 0, 15);//读取每日提示地址
		if(rel > 0)
		{
			fseek(datfp, rel, 0);
			fread(&size, 1, 2, datfp);
			rel = rel + 2;
			flag = k = n = 0;
		}
		else cfset.dat[3].tem[2].value = 1;
	}
START:
#if WQX == 0
	SetBgColor(3);
#endif
	ClearScreen();
	for(;;)
	{
		Block(1, 0, 160, 17, 1);
#if WQX == 0
		SetBgColor(0);
#endif
		TextOut(i + 4, 3, "LavaX1.0 Compiler", 2);
#if WQX == 0
		SetBgColor(3);
#endif
		Rectangle(2, 1, 158, 16, 0);
		if (!cfset.dat[0].tem[1].value)//移动
		{
			if (i) i--;
			else if (j) j--;
			else
			{
				i = 158;
				j = 40;
			}
		}
		Block(2, 18, 158, 78, 0);
#if WQX == 0
		MyBox(2, 20, 110, 77, 4);
#else
		Rectangle(2, 20, 110, 77, 1);
#endif
		if (flag)
		{
			textout(11, 40, "Y2.21正式版", 0x81);
		}
		else if (!cfset.dat[3].tem[2].value && rel > 0)
		{
			ShowMeiri(rel, k, size);
		}
		n++;
		if (n > 80)
		{
			n = 0;
			k++;
			if (k >= size) flag = 1;
		}
#if WQX == 0
		Boxw(120, 19, "文 件");
		Boxw(120, 34, "工 具");
		Boxw(120, 49, "查 看");
		Boxw(120, 64, "帮 助");
		Block(121, value * 15 + 20, 152, value * 15 + 31, 2);
#else
		Boxw(118, 19, "文 件");
		Boxw(118, 34, "工 具");
		Boxw(118, 49, "查 看");
		Boxw(118, 64, "帮 助");
		Block(119, value * 15 + 20, 154, value * 15 + 31, 2);
#endif
		Refresh();
		key = Inkey();//响应
		if (key == UP_KEY || key == LEFT_KEY) value = (value - 1)&3;
		else if (key == DOWN_KEY || key == RIGHT_KEY) value = (value + 1)&3;
		else if (key == CR_KEY)
		{
			if (!value)
			{
				if (!(tv = SubMenu("编译打开新建", 3, 100, 22))) goto START;
				value = tv + 2;
			}
			else if (value == 1)
			{
				if (!(tv = SubMenu("设置卸载", 2, 100, 30))) goto START;
				if (tv == 5)
				{
					if (!Swin("卸载？", "确定要卸载？", SWIN_TWO)) continue;
					UnInstall(LIST_TABLE);
				}
				value = 1;
			}
			else if (value == 2)
			{
				if (!(tv = SubMenu("宏管理链接库资  源配  置", 4, 88, 18))) goto START;
				if (tv == 7)
				{
					ShowSet();
					goto START;
				}
				value = tv + 5;
			}
			return(value);
		}
		else if (key == ESC_KEY || key == 'q')
		{
			if (cfset.dat[0].tem[0].value)
			{
				if (!Swin("退出？", "  真的要退出？", SWIN_TWO)) continue;
			}
			if (datfp) fclose(datfp);
			Exit();
			exit(0);
		}
		else if (key == HELP_KEY)
		{
			ShowHelp();
			goto START;
		}
	}
}
//*******************************************************目录通用*******************************************************//
/* 改变目录 */
int ChPath(char &path[])
{
	int head, end;

	if (!ChDir(end = path))
	{
		ChDir("/");
		while (end = strchr(head = end + 1, '/'))
		{
			*end = 0;
			if (!ChDir(head))
			{
				MakeDir(head);
				if (!ChDir(head))
				{
					*end = '/';
					return(1);
				}
			}
			*end = '/';
		}
		MakeDir(head);
		if (!ChDir(head)) return(1);
	}
}

/* 改变后缀 */
void ChExt(char &s[], char &e[])
{
	long t, p;

	p = s;
	while (t = strchr(p, '.')) p = t + 1;
	if (p > s)
	{
		strcpy(p, e);
	}
	else
	{
		strcat(p, ".");
		strcat(p, e);
	}
}

/* 判断后缀 */
int ChkExt(char &s[], char &e[])
{
	int t, p;
	char ext[10];

	p = s;
	while (t = strchr(p, '.')) p = t + 1;
	if (p > s)
	{
		t = 0;
		while (*p) ext[t++] = tolower(*p++);
		ext[t] = 0;
		return(!strcmp(ext, e));
	}
}

void PopDir(char &path[])
{
	int i, len;

	if ((len = strlen(path)) == 1) return;
	for (i = len - 1; i > 0; i--)
	{
		if (path[i] == '/')
		{
			path[i] = 0;
			return;
		}
	}
	path[1] = 0;
}

/* 源程序选择 */
int SelectSrc(struct OUTFILE &fn, char &path[], int cmd)
{
	int i;

	if (ChDir(path))
	{
		strcpy(fn.path, path);
		i = 1;
	}
	else
	{
		ChDir("/");
		strcpy(fn.path, "/");
		i = 0;
	}
	for (;;)
	{
		if (!FileList(fn.name) || !strcmp(fn.name, ".."))
		{
			if (i > 0)
			{
				i--;
				ChDir("..");
				PopDir(fn.path);
				continue;
			}
			return(0);
		}
		else if (ChDir(fn.name))
		{
			if (strlen(fn.path) > 1) strcat(fn.path, "/");
			strcat(fn.path, fn.name);
			i++;
			continue;
		}
		if (cmd == 0xfe)
		{
			if (ChkExt(fn.name, "ref"))			return(5);//检索文件
			continue;
		}
		if (cmd == 0xfc)
		{
			if (ChkExt(fn.name, "dat"))			return(5);//dat文件
			continue;
		}
		if (cmd == 0xff)						return(4);//所有文件
		if (ChkExt(fn.name, "txt"))				return(1);//文本文件
		if (ChkExt(fn.name, "h"))				return(2);//头文件
		if (ChkExt(fn.name, "lav") && cmd != 7)	return(3);//链接文件
	}
}

/* 函数, 链接库文件选择 */
int SelectFil(char &name[], char &path[], char &ext[])
{
	char tn[16];

	ChPath(path);
	for (;;)
	{
		if (!FileList(tn)) return(0);
		if (ChkExt(tn, ext))
		{
			strcpy(name, tn);
			return(1);
		}
	}
}

/* 目录选择[只是一级] */
int SelectDir(char &name[], char &path[])
{
	char tn[16];

	ChPath(path);
	for (;;)
	{
		if (!FileList(tn) || !strcmp(tn, "..")) return(1);
		if (ChDir(tn))
		{
			strcpy(name, "/");
			strcat(name, tn);
			return(0);
		}
	}
}
//*******************************************************目录系统*******************************************************//
/* 数据读取 [通用] */
long DataRead(long addrs, long size, long rel)
{
	if (!datfp)
	{
		ChDir(cpldata);
		if (!(datfp = fopen("compile.dat", "r")))
		{
			Swin("错误！", "找不到资源文件", SWIN_ONE);
			return(-1);
		}
	}
	if (rel < JUMP_SIZE)
	{
		fseek(datfp, rel << 2, 0);
		fread(&rel, 1, 4, datfp);
		if (addrs < 150)//Error特殊
		{
			rel = rel + addrs * sizeof(struct ERR_UNIT);
			addrs = ERROR_LOAD;
		}
	}
	fseek(datfp, rel, 0);
	fread(addrs, 1, size, datfp);
	return(rel);
}

#if WQX == 0
void PrintCat(struct CATTABLE &c, int first, int value)/*显示*/
{
	char i;

	MyBox(69, 18, 155, 76, 4);
	MyLine(69, 36, 153, 36, 64);
	SetBgColor(3);
	Block(4, 17, 68, 77, 0);
	for (i = 0; i < 4 && i + first < CAT_C_SIZE; i++)
	{
		Boxw(4, i * 15 + 18, c.dat[i + first].name);//选项
	}
	TextOut(71, 20, c.dat[value + first].name, 128);
	for (i = 0; i < 3; i++)
	{
		TextOut(71, i * 13 + 38, c.dat[first+value].msg[i], 1);//说明
	}
	Block(5, value * 15 + 19, strlen(c.dat[first + value].name) * 6 + 6, value * 15 + 30, 2);
}
#else
void PrintCat(struct CATTABLE &c, int first, int value)/*显示*/
{
	char i;

	Block(2, 16, 158, 78, 0);
	Rectangle(72, 17, 157, 77, 1);
	Line(72, 34, 157, 34, 65);
	for (i = 0; i < 4 && i + first < CAT_C_SIZE; i++)
	{
		Boxw(3, i * 15 + 18, c.dat[i + first].name);//选项
	}
	TextOut(73, 18, c.dat[value + first].name, 128);
	for (i = 0; i < 3; i++)
	{
		TextOut(73, i * 13 + 37, c.dat[first + value].msg[i], 1);//说明
	}
	Block(4, value * 15 + 19, strlen(c.dat[first + value].name) * 6 + 9, value * 15 + 30, 2);
}
#endif

void CataHelp()
{
	char s[5][30];

	strcpy(s[0], "求助键    :显示求助信息");
	strcpy(s[1], "输入键    :选中该选项");
	strcpy(s[2], "ESC键,q键 :返回上一级界面");
	strcpy(s[3], "方向键    :上一行或下一行");
	strcpy(s[4], "翻页键    :上一页或下一页");
	PrintMsg(s, 0);
	getchar();
}

/* 目录 返回按键信息:0~:项, -1:错误 -2:CAT_SET -3:ESC [通用] */
int Cata(struct CATTABLE &c, long rel, int cur, int cmd)
{
	char key;
	int first;

	first = DataRead(c, sizeof(struct CATTABLE), rel);//数据读取
	if (first < 0) return(-1);
	if (cmd == CAT_HELP)
	{
		Dwin("帮助");
	}
	else
	{
		Dwin("设置");
	}
	for (first = 0;;)
	{
		PrintCat(c, first, cur - first);
		Refresh();
		key = getchar();
		if (key == UP_KEY || key == LEFT_KEY)
		{
			if (cur)
			{
				cur--;
				if (cur < first) first = cur;
			}
			else
			{
				cur = CAT_C_SIZE - 1;
				if (cur > first + 3) first = cur - 3;
			}
		}
		else if (key == DOWN_KEY || key == RIGHT_KEY)
		{
			if (cur + 1 < CAT_C_SIZE)
			{
				cur++;
				if (cur > first + 3) first = cur - 3;
			}
			else
			{
				cur = first = 0;
			}
		}
		else if (key == UU_KEY)
		{
			if (first < 4)
			{
				cur = cur - first;
				first = 0;
			}
			else
			{
				first = first - 4;
				cur = cur - 4;
			}
		}
		else if (key == DD_KEY && first + 4 < CAT_C_SIZE)
		{
			first = first + 4;
			cur = cur + 4;
			if (cur >= CAT_C_SIZE) cur = CAT_C_SIZE - 1;
		}
		else if (key == HELP_KEY)				CataHelp();
		else if (key == CR_KEY)					return(cur);
		else if (key == ESC_KEY || key == 'q')	return(-3);
	}
}
//*******************************************************报告系统*******************************************************//
void ChangeFun(int tfunjmp)
{
	memcpy(&tfunjmp - 2, &tfunjmp, 2);
	funjmp = 0;
}

void GotoFun()
{
	ChangeFun(funjmp);
}

void Error(long p, int id)/* 错误系统 */
{
	char msg[30];

	Dwin("错误");
	TextOut(3, 63, "表述:", 1);
	TextOut(37, 35, "在:", 1);
	WriteBlock(3, 17, 32, 32, 1, pic[PIC_WARN]);
#if WQX == 0
	MyBox(34, 61, 155, 76, 1);
#else
	Block(35, 62, 156, 77, 1);//图形界面
	Block(34, 61, 155, 76, 0);
	Rectangle(34, 61, 155, 76, 1);
#endif
	if (in.fp) fclose(in.fp);
	if (out.fp)//关闭句柄,删除错误文件
	{
		fclose(out.fp);
		if (ChkExt(out.name, "lav"))	ChDir(cfset.lav);
		else if (ChkExt(out.name, "h"))	ChDir(fundata);
		else if (ChkExt(out.name, "y"))	ChDir(libdata);
		DeleteFile(out.name);
	}
	if (cp.fp)
	{
		fclose(cp.fp);
		ChDir(cpldata);
		DeleteFile("cpl.tmp");
	}
	in.fp = out.fp = cp.fp = 0;//关闭所有文件
	if (in.p >= FB_CUSH + FB_C_REL)//截取片段
	{
		if (in.p >= FB_CUSH + FB_C_REL + 10)		in.p = in.p - 10;
		else if (in.p >= FB_CUSH + FB_C_REL + 8)	in.p = in.p - 8;
		else if (in.p >= FB_CUSH + FB_C_REL + 6)	in.p=in.p-6;
		else if (in.p >= FB_CUSH + FB_C_REL + 4)	in.p=in.p-4;
		else if (in.p >= FB_CUSH + FB_C_REL + 2)	in.p=in.p-2;
		if (*in.p >= 160) in.p++;
		if (*(in.p + 17) >= 160)
		{
			*(in.p + 16) = 0;
		}
		else
		{
			*(in.p + 17) = 0;
		}
	}
	if (id <= E_CREAT | id == E_OFFSET | id == E_KVAR | id == E_LOAD | id == E_ZERO | id == E_LINK | id == E_INTER | id == E_MAIN | !in.p)
	{
		TextOut(55, 35, "[缺省]", 1);
	}
	else
	{
		TextOut(55, 35, in.p, 1);
	}
	if (DataRead(id, sizeof(struct ERR_UNIT), 19) < 0)//读取信息,返回ERROR_LOAD
	{
		Swin("警告！", "无法显示信息", 1);
		GotoFun();//返回主程序
		return;
	}
	TextOut(100 - (strlen(ERROR_LOAD) << 2), 18, ERROR_LOAD, 129);
	strcpy(msg, ERROR_LOAD + ERR_MSG);
	if (p >= 6000)
	{
		strcat(msg, p);
	}
	else if (id == E_USIGN | id == E_STR | id == E_SIGN)
	{
		sprintf(msg + strlen(msg), "%c", p);
	}
	else if (id == E_DJMP | id == E_KVAR | id == E_CMD | id == E_UNCODE)
	{
		sprintf(msg + strlen(msg),"%d",p);
	}
	TextOut(4, 49, msg, 1);
	TextOut(36, 63, ERROR_LOAD + ERR_MSG + ERR_STR, 1);
	Refresh();
	for(;;)//暂停
	{
		Delay(20);
		if (!cfset.dat[0].tem[2].value) Beep();
		if (Inkey()) break;
	}
	GotoFun();//返回主程序
}
void UnInstallFace(char &s[][30], char &name[], int cur, int num, char cmd)
{
	char i;

	if (!cmd)
	{
		if (s[3][0])
		{
			for (i = 0; i < 3; i++)
			{
				strcpy(s[i], s[i + 1]);
			}
			memset(s[3], 0, 30);
		}
	}
	for (i = 0; i < 4; i++)
	{
		if (!s[i][0]) break;
	}
	if (cmd)
	{
		strcat(s[i - 1], name);
	}
	else
	{
		strcpy(s[i], name);
	}
	Block(2, 16, 158, 78, 0);
	Rectangle(3, 17, 157, 22, 1);
	if (num) Block(5, 19, cur * (in.size) / num + in.p, 20, 1);//进度
	Rectangle(3, 24, 157, 77, 1);
	for (i = 0;i < 4 && s[i][0]; i++)
	{
		TextOut(5, i * 13 + 26, s[i], 1);
	}
	Refresh();
}

int GetFileList(struct ULIST &ul, struct UEXT &ue, char &s[][30])//返回列表大小
{
	char fp, i, flag, tf;
	int size;
	long start;
	char str[30];

	UnInstallFace(s, "正在收集列表信息...", 0, 1, 0);
	if (!ChDir(ul.dirname))
	{
		sprintf(str, "无法进入目录:%s", ul.dirname);
		UnInstallFace(s, str, 0, 1, 0);
		return(-1);
	}
	if (!(fp = fopen("", "r"))) return(-2);
	memcpy(&start, ul.start, 4);
	fseek(fp, start, 0);
	size = flag = 0;
	while (!feof(fp) && size < LIST_SIZE)
	{
		fseek(fp, 2, 1);
		fread(ul.dat[size].name, 1, LU_SIZE - 1, fp);
		if (!ul.dat[size].name[0] || ul.dat[size].name[0] == 255)
		{
			flag = 1;
			break;
		}
		for (i = tf = 0; i < ue.size; i++)
		{
			if (ChkExt(ul.dat[size].name, ue.dat[i].name))
			{
				tf = 1;
				break;
			}
		}
		if (tf || !ue.size) size++;
	}
	start = ftell(fp);
	fclose(fp);
	memcpy(ul.start, &start, 4);
	memcpy(ul.size, &size, 2);
	UnInstallFace(s, " 完成", 0, 1, 1);
	return(flag);
}

int FileDelete(struct ULIST &ul, char &s[][30])//删除文件
{
	int i, size, udsize;
	char str[30];

	memcpy(&size, ul.size, 2);
	udsize = 0;
	for (i = 0; i < size; i++)
	{
		sprintf(str, "删除:%s", ul.dat[i].name);
		UnInstallFace(s, str, i + 1, size, 0);
		if (!DeleteFile(ul.dat[i].name))
		{
			UnInstallFace(s, " 未完成", i + 1, size, 1);
			udsize++;
		}
		else
		{
			UnInstallFace(s, " 完成", i + 1, size, 1);
		}
	}
	return(udsize);
}

int ListDelete(struct ULIST &ul, struct UEXT &ue, char &s[][30])//删除目录
{
	int flag, i;
	long start;
	char str[30];

	for (i = flag = 0; i < 1024 / LIST_SIZE + 1 && !flag; i++)
	{
		start = 16;
		memcpy(ul.start, &start, 4);
		flag = GetFileList(ul, ue, s);
		if (flag >= 0)
		{
			out.p = FileDelete(ul, s) + out.p;
		}
		else if (flag == -2)
		{
			return(1);
		}
	}
}

int ChkProgFile(struct ULIST &ul)//判断是否是主程序
{
	char fp;
	int i, size;

	memcpy(&size, ul.size, 2);
	for (i = 0; i < size; i++)
	{
		if (fp = fopen(ul.dat[i].name, "r"))
		{
			if (fseek(fp, 0, 2) > 78000)
			{
				fseek(fp, -5, 2);
				if (getc(fp) == 0x3b)
				{
					fseek(fp, -2, 2);
					if (getc(fp) == 0x01)
					{
						fclose(fp);
						return(i);
					}
				}
			}
			fclose(fp);
		}
	}
	return(-1);
}

int ProgDelete(struct ULIST &ul, struct UEXT &ue, char &s[][30])//删除主程序
{
	int flag, p;
	long start;
	char str[30];

	start = 16;
	memcpy(ul.start, &start, 4);
	flag = 0;
	while (!flag)
	{
		flag = GetFileList(ul, ue, s);
		if (flag >= 0)
		{
			UnInstallFace(s, "正在校验列表信息...", 1, 4, 0);
			p = ChkProgFile(ul);
			if (p >= 0)
			{
				sprintf(str, "删除:%s", ul.dat[p].name);
				UnInstallFace(s, str, 2, 4, 0);
				if (!DeleteFile(ul.dat[p].name))
				{
					UnInstallFace(s, " 未完成", 2, 4, 1);
					out.p++;
				}
				else
				{
					UnInstallFace(s, " 完成", 2, 4, 1);
				}
				return(0);
			}
		}
		else if (flag == -2)
		{
			return(1);
		}
	}
	UnInstallFace(s, "无法删除主程序！", 2, 4, 0);
	out.p++;
}
void UnInstall(struct ULIST &ul)//借用了out.p, in.p, in.size
{
	struct UEXT ue;
	char str[30];
	char s[4][30];

	memset(s, 0, 120);
	out.p = 0;//计数器初始化
	//if (datfp)fclose(datfp);//关闭资源文件
	fclose(128);
	fclose(129);
	fclose(130);//关闭所有文件
	Dwin("卸载");
	strcpy(ul.dirname, "/CplData");
	strcpy(ue.dat[0].name, "dat");
	strcpy(ue.dat[1].name, "fun");
	strcpy(ue.dat[2].name, "ref");
	strcpy(ue.dat[3].name, "tmp");
	ue.size = 4;//文件类型
	in.p = 5;
	in.size = 40;
	if (ListDelete(ul, ue, s))
	{
		UnInstallFace(s, "无法收集信息", 0, 1, 0);
		UnInstallFace(s, "请手动删除:/CplData文件夹", 0, 1, 0);
	}
	strcpy(ul.dirname, "/LibData");
	strcpy(ue.dat[0].name, "y");
	strcpy(ue.dat[1].name, "dll");
	ue.size = 2;//文件类型
	in.p = in.p + in.size;
	in.size = 40;
	if (ListDelete(ul, ue, s))
	{
		UnInstallFace(s, "无法收集信息", 0, 1, 0);
		UnInstallFace(s, "请手动删除:/LibData文件夹", 0, 1, 0);
	}
	strcpy(ul.dirname, "/FunData");
	strcpy(ue.dat[0].name, "h");
	ue.size = 1;//文件类型
	in.p = in.p + in.size;
	in.size = 40;
	if (ListDelete(ul, ue, s))
	{
		UnInstallFace(s, "无法收集信息", 0, 1, 0);
		UnInstallFace(s, "请手动删除:/FunData文件夹", 0, 1, 0);
	}
	strcpy(ul.dirname, cfset.lav);
	strcpy(ue.dat[0].name, "lav");
	ue.size = 1;//文件类型
	in.p = in.p + in.size;
	in.size = 30;
	if (ProgDelete(ul, ue, s));
	{
		UnInstallFace(s, "无法收集信息", 0, 1, 0);
		UnInstallFace(s, "请手动删除主程序", 0, 1, 0);
	}
	sprintf(str, "卸载完成！%d个文件未删除", out.p);
	UnInstallFace(s, str, 3, 4, 0);
	UnInstallFace(s, "按任意键退出程序...", 4, 4, 0);
	getchar();
	exit(0);
}
//*******************************************************设置系统*******************************************************//
void ConfigRW(int cmd)/*config.dat存取操作[通用]*/
{
	char fp;

	if (ChPath(cpldata))
	{
		Swin("错误！", "无法进入目录", SWIN_ONE);
		return;
	}
	if (!(fp = fopen("config.dat", "r+")))
	{
		if (!(fp = fopen("config.dat", "w+")))
		{
			Swin("错误！", "无法创建config", SWIN_ONE);
			return;
		}
		goto SAVE;
	}
	if (cmd == CON_READ)
	{
		fread(cfset, 1, sizeof(struct CONTABLE0), fp);
	}
	else if (cmd == CON_SETE)
	{
SAVE:
		if (fwrite(cfset, 1, sizeof(struct CONTABLE0), fp) != sizeof(struct CONTABLE0))
		{
			Swin("错误！", "写入config错误", SWIN_ONE);
		}
	}
	fclose(fp);
}

#if WQX == 0
/* 设置显示 */
void PrintTem(struct CONTABLE1 &n, int first, int value, int rel)
{
	int i;
	char msg[4];

	SetBgColor(3);
	Block(4, 18, 156, 77, 0);
	Rectangle(4, 18, 149, 76, 1);
	TextOut(44, 19, "项  目", 1);
	TextOut(131, 19, "值", 1);
	Block(122, 18, 123, 76, 1);
	Block(4, 30, 149, 31, 1);
	Line(4, 46, 149, 46, 65);
	Line(4, 61, 149, 61, 65);
	for(i = 0; i < 3 && i + first < n.dat[rel].size; i++)
	{
		if (!cfset.dat[rel].tem[first + i].value)
		{
			sprintf(msg, "否");
		}
		else if (cfset.dat[rel].tem[first + i].value == 1)
		{
			sprintf(msg, "是");
		}
		else if (cfset.dat[rel].tem[first + i].value == 2)
		{
			sprintf(msg, cfset.fun);
			msg[3] = 0;
		}
		else
		{
			sprintf(msg, "%d", cfset.dat[rel].tem[first + i].value);
		}
		TextOut(5, i * 15 + 33, n.dat[rel].tem[first + i].name, 1);
		TextOut(136 - strlen(msg) * 3, i * 15 + 33, msg, 1);
	}
	MyBox(151, 18, 156, 76, 1);
	Block(153, (first * 54) / n.dat[rel].size + 20, 154, ((first + i) * 54) / n.dat[rel].size + 20, 1);//进度显示
	Block(124, value * 15 + 32, 148, value * 15 + 45, 2);
}
#else
void PrintTem(struct CONTABLE1 &n, int first, int value, int rel)/*设置显示*/
{
	int i;
	char msg[4];

	Block(2, 16, 158, 78, 0);
	Rectangle(3, 17, 150, 77, 1);
	TextOut(44, 19, "项  目", 1);
	TextOut(131, 19, "值", 1);
	Block(123, 18, 124, 76, 1);
	Block(4, 31, 149, 32, 1);
	Line(4, 47, 149, 47, 65);
	Line(4, 62, 149, 62, 65);
	for (i = 0; i < 3 && i + first < n.dat[rel].size; i++)
	{
		if (!cfset.dat[rel].tem[first + i].value)
		{
			sprintf(msg, "否");
		}
		else if (cfset.dat[rel].tem[first + i].value == 1)
		{
			sprintf(msg, "是");
		}
		else if (cfset.dat[rel].tem[first + i].value == 2)
		{
			sprintf(msg, cfset.fun);
			msg[3] = 0;
		}
		else
		{
			sprintf(msg, "%d", cfset.dat[rel].tem[first+i].value);
		}
		TextOut(5, i * 15 + 34, n.dat[rel].tem[first + i].name, 1);
		TextOut(137 - strlen(msg) * 3, i * 15 + 34, msg, 1);
	}
	Block(154, (first * 56) / n.dat[rel].size + 19, 155, ((first + i) * 56) / n.dat[rel].size + 19, 1);//进度显示
	Rectangle(152, 17, 157, 77, 1);
	Block(125, value * 15 + 33, 149, value * 15 + 46, 2);
}
#endif

void SetHelp()
{
	char s[5][30];
 
	strcpy(s[0], "左右键    :改变设置值");
	strcpy(s[1], "上下键,翻页键 :移动选择条");
	strcpy(s[2], "求助键    :显示求助信息");
	strcpy(s[3], "ESC键,q键 :返回上一级界面");
	strcpy(s[4], "CR键      :选择函数文件");
	PrintMsg(s, 0);
	getchar();
}

void CON_Set(struct CONTABLE1 &n)/*设置表操作[通用]*/
{
	int first, cur, value;
	char key;

	value = 0;
START:
	cur = Cata(CATAL_TABLE, 1, value, CAT_SET);
	if (cur == -1) return;
	if (cur == -3)//退出
	{
		ConfigRW(CON_SETE);
		return;
	}
	DataRead(n, sizeof(struct CONTABLE1), 2);//读取说明数据
	value = cur;
	for (first = cur = 0;;)
	{
		PrintTem(n, first, cur - first, value);
		Refresh();

		key = getchar();
		if (key == UP_KEY)
		{
			if (cur > 0)
			{
				cur--;
				if (cur < first) first = cur;
				continue;
			}
		}
		else if (key == DOWN_KEY)
		{
			if (cur + 1 < n.dat[value].size)
			{
				cur++;
				if (cur > first + 2) first = cur - 2;
				continue;
			}
		}
		else if (key == UU_KEY)
		{
			if (first >= 3)
			{
				first = first - 3;
				cur = cur - 3;
				continue;
			}
			if (first > 0)
			{
				cur = cur - first;
				first = 0;
				continue;
			}
		}
		else if (key == DD_KEY)
		{
			if (first + 3 < n.dat[value].size)
			{
				first = first + 3;
				cur = cur + 3;
				if (cur >= n.dat[value].size) cur = n.dat[value].size - 1;
			}
		}
		else if ((key == LEFT_KEY || key == RIGHT_KEY) && cfset.dat[value].tem[cur].value != 2)
		{
			if (cfset.dat[value].tem[cur].value < 2)
			{
				cfset.dat[value].tem[cur].value = cfset.dat[value].tem[cur].value ^ 1;
				continue;
			}
			if (key == LEFT_KEY)
			{
				if (cfset.dat[value].tem[cur].value > 3)
				{
					cfset.dat[value].tem[cur].value--;
				}
				else
				{
					cfset.dat[value].tem[cur].value = 255;
				}
				continue;
			}
			if (key == RIGHT_KEY)
			{
				if (cfset.dat[value].tem[cur].value < 255)
				{
					cfset.dat[value].tem[cur].value++;
				}
				else
				{
					cfset.dat[value].tem[cur].value = 3;
				}
				continue;
			}
		}
		else if (key == CR_KEY && cfset.dat[value].tem[cur].value == 2)
		{
			SelectFil(cfset.fun, cpldata, "fun");
		}
		else if (key == ESC_KEY || key == 'q') goto START;
		else if (key == HELP_KEY) SetHelp();
		if (!cfset.dat[0].tem[2].value) Beep();
	}
}
//*******************************************************帮助系统*******************************************************//
void HelpHelp1()
{
	char s[5][30];

	strcpy(s[0], "F3键      :跳转到文本头部");
	strcpy(s[1], "F4键      :跳转到文本尾部");
	strcpy(s[2], "ESC键,q键 :返回上一级界面");
	strcpy(s[3], "方向键    :上一行或下一行");
	strcpy(s[4], "翻页键    :上一页或下一页");
	PrintMsg(s, 0);
	getchar();
}

int GetText(struct HLPTABLE &h, char &buf[], int sm, int i, long add, char fp)//分析文本, 返回新的指针i(最大行)
{
	char k, l;//当前行长度
	char j, c;//缓冲区

START:
	fseek(fp, add, 0);
	fread(buf, 1, 5 * (HLP_S_LEN - 1) + 1, fp);//读取数据
	for (j = l = 0; i < HLP_L_SIZE && l < 5; l++)//换行
	{
		for (k = 0; k < HLP_S_LEN - 1; k++)
		{
			if ((c = buf[j++]) < 128)
			{
				if (c == 13)
				{
					j++;
					if (!k)
					{
						k = h.size[--i];
						l--;
					}
					k = k + 2;
					break;
				}
				else if (!c)
				{
END:
					if (k) h.size[i++] = k;
					h.f = 1;
					goto RET;
				}
			}
			else if (k < HLP_S_LEN - 2)
			{
				if (!buf[j]) goto END;
				k++;
				j++;
			}
			else
			{
				j--;
				break;
			}
		}
		h.size[i++] = k;
	}
	if (i >= HLP_L_SIZE)
	{
		Swin("警告！", "无法全部载入", 1);
	}
	else if (sm)
	{
		add = add + j;
		goto START;
	}
RET:
 return(i);
}

void PrintHlp(struct HLPTABLE &h, long rel, char fp, int s)/*文本浏览*/
{
	char key;
	int size;//size:文件长度
	long dcur;//当前文件地址
	int i, tlen;//临时变量
	int j, len;//当前行，最大行
	char c, p, str[HLP_S_LEN], buf[5 * (HLP_S_LEN - 1) + 1];//缓冲区

	Swin("信息", NULL, SWIN_COM);
	//TextOut(43, 46, "载入中...", 128);
	textout(43, 46, "载入中...", 128);
	Refresh();
	if (!fp)
	{
		rel = DataRead(h, 0, rel);
		fp = datfp;
	}
	fseek(fp, rel, 0);
	fread(&size, 1, 2, fp);
	dcur = rel = ftell(fp);//确定地址，长度
	memset(h, 0, sizeof(struct HLPTABLE));//初始化
	if (s)
	{
		strcpy(str, "链接库:");
		strcat(str, s);
		Dwin(str);
	}
	else
	{
		Dwin("帮助");
	}
	for (j = len = 0;;)
	{
		if ((tlen = GetText(h, buf, 0, j, dcur, fp)) > len) len = tlen;
START:
#if WQX == 0
		Block(4, 18, 157, 76, 0);
		MyBox(4, 18, 150, 76, 1);
		SetBgColor(8);
		Line(5, 19, 5, 74, 64);
		Line(5, 19, 148, 19, 64);
		MyBox(152, 18, 157, 76, 1);
		for (i = p = 0; i < 4 && i + j < len; i++)
		{
			for (c = h.size[i + j]; *(buf + p + c - 1) == 10; c = c - 2);
			memcpy(str, buf + p, c);
			str[c] = 0;
			TextOut(6, i * 13 + 23, str, 1);
			p = p + h.size[i + j];
		}
		Block(154, ((dcur - rel) * 54) / size + 20, 155, ((dcur + p - rel) * 54) / size + 20, 1);//进度显示
#else
		Block(2, 16, 158, 78, 0);
		Rectangle(3, 17, 150, 77, 1);
		Rectangle(152, 17, 157, 77, 1);
		for (i = p = 0; i < 4 && i + j < len; i++)
		{
			for (c = h.size[i + j]; *(buf + p + c - 1) == 10; c = c - 2);
			memcpy(str, buf + p, c);
			str[c] = 0;
			TextOut(5, i * 13 + 23, str, 1);
			p = p + h.size[i + j];
		}
		Block(154, ((dcur - rel) * 56) / size + 19, 155, ((dcur + p - rel) * 56) / size + 19, 1);//进度显示
#endif
		Refresh();
		key = getchar();
		if ((key == UP_KEY || key == LEFT_KEY) && j)
		{
			dcur = dcur - h.size[--j];
			break;
		}
		else if (key == DOWN_KEY || key == RIGHT_KEY)
		{
			if (j + 4 < len)
			{
				dcur = dcur + h.size[j++];
				break;
			}
			if (!h.f) dcur = dcur + h.size[j++];
		}
		else if (key == UU_KEY)
		{
			for (i = 0; i < 4 && j; i++)
			{
				dcur = dcur - h.size[--j];
			}
			break;
		}
		else if (key == DD_KEY)
		{
			if (j + 7 < len)
			{
				for (i = 0; i < 4; i++)
				{
					dcur = dcur + h.size[j++];
				}
				break;
			}
			if (!h.f)
			{
				for (i = 0; i < 4; i++)
				{
					dcur = dcur + h.size[j++];
				}
			}
		}
		else if (key == F3_KEY)
		{
			j = 0;
			dcur = rel;
			break;
		}
		else if (key == F4_KEY)
		{
			if (!h.f)
			{
				while (j < len - 1)
				{
					dcur = dcur + h.size[j++];
				}
				len = GetText(h, buf, 1, j, dcur, fp);
			}
			while (j + 4 < len)
			{
				dcur = dcur + h.size[j++];
			}
			break;
		}
		else if (key == ESC_KEY || key == 'q') return;
		else if (key == HELP_KEY) HelpHelp1();
	}
	fseek(fp, dcur, 0);
	fread(buf, 1, 4 * (HLP_S_LEN - 1) + 1, fp);
	goto START;
}

#if WQX == 0
void PrintFun(struct HPFUNTABLE &f, int first, int value)/*函数显示*/
{
	int i;

	SetBgColor(3);
	Block(4, 17, 157, 77, 0);
	for (i = 0; i < 8 && i + first < f.size; i++)
	{
		Boxw((i&1) * 83 + 4, (i >> 1) * 15 + 18, f.tem[(first + i) >> 1][(first + i)&1].name);
	}
	Block((value&1) * 83 + 5, (value >> 1) * 15 + 19, (value&1) * 83 + 72, (value >> 1) * 15 + 30, 2);
};
#else
void PrintFun(struct HPFUNTABLE &f, int first, int value)/*函数显示*/
{
	int i;

	Block(2, 16, 158, 78, 0);
	for (i = 0; i < 8 && i + first < f.size; i++)
	{
		Boxw((i&1) * 81 + 3, (i >> 1) * 15 + 19, f.tem[(first + i) >> 1][(first + i)&1].name);
	}
	Block((value&1) * 81 + 4, (value >> 1) * 15 + 20, (value&1) * 81 + 75, (value >> 1) * 15 + 31, 2);
};
#endif

void HelpHelp2()
{
	char key;
	char s[5][30];

_S1:
	strcpy(s[0], "方向键 :上一行或下一行");
	strcpy(s[1], "翻页键 :上一页或下一页");
	strcpy(s[2], "ESC键  :返回上一级界面");
	strcpy(s[3], "输入键 :显示函数详细信息");
	strcpy(s[4], "字母键 :跳转到该字母开头");
	PrintMsg(s, 0);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
	if (key == ESC_KEY || key == 'q') return;
	strcpy(s[0], "的函数，再次按该键可以跳");
	strcpy(s[1], "转到下一个相同字母开头的");
	strcpy(s[2], "函数");
	strcpy(s[3], "求助键 :显示求助信息");
	strcpy(s[4], "F3(F4)键:跳转到首(尾)");
	PrintMsg(s, 0);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
}

long SFunSeekName(struct HPFUNTABLE &f, char c)
{
	long low, mid, high, t;

	low = mid = 0;
	high = f.size - 1;
	while (low <= high)
	{
		mid = (low + high) >> 1;
		t = c - f.tem[mid >> 1][mid&1].name[0];
		if (t > 0)
		{
			low = mid + 1;
		}
		else if (t < 0)
		{
			high = mid - 1;
		}
		else
		{
			while (mid > 0)
			{
				mid--;
				if (c != f.tem[mid >> 1][mid&1].name[0]) return(mid + 1);
			}
			return(0);
		}
	}
	return(-1);
}

void FunHelp(struct HPFUNTABLE &f)/*函数帮助*/
{
	char key, fp;
	char skey;
	char flag;
	long first, cur, t;

	if (!ChDir(cpldata))
	{
		Swin("错误！", "无法进入目录", SWIN_ONE);
		return;
	}
	if (!(fp = fopen(cfset.fun, "r")))
	{
		Swin("错误！", "找不到函数文件", SWIN_ONE);
		return;
	}
	first = key = flag = 0;
	fread(&first, 1, 2, fp);
	fseek(fp, first, 0);
	fread(&f.size, 1, 1, fp);//读取长度
	if (f.size > HPFUN_L_LEN * 2)
	{
		Swin("错误！", "函数个数太多", SWIN_ONE);
		fclose(fp);
		return;
	}
	fread(f.tem, 1, f.size * sizeof(struct HPFUNUNIT), fp);
	for (first = cur = 0;;)
	{
		PrintFun(f, first, cur - first);
		Refresh();
		skey = key;
		key = getchar();
		if (key == UP_KEY && cur > 1)
		{
			cur = cur - 2;
			if (cur < first)
			{
				first = first - 2;
			}
		}
		else if (key == DOWN_KEY && cur + 2 < f.size)
		{
			cur = cur + 2;
			if (cur > first + 7)
			{
				first = first + 2;
			}
		}
		else if (key == LEFT_KEY && cur)
		{
			cur--;
			if(cur < first)
			{
				first = first - 2;
			}
		}
		else if (key == RIGHT_KEY && cur + 1 < f.size)
		{
			cur++;
			if (cur > first + 7)
			{
				first = first + 2;
			}
		}
		else if (key == UU_KEY)
		{
			if (first < 8)
			{
				cur = cur - first;
				first = 0;
			}
			else
			{
				first = first - 8;
				cur = cur - 8;
			}
		}
		else if (key == DD_KEY && first + 8 < f.size)
		{
			first = first + 8;
			if ((cur = cur + 8) >= f.size)
			{
				cur = ((f.size >> 1) << 1) + (cur&1) - 2;
			}
			if (cur < first) cur = first;
		}
		else if (key == CR_KEY)
		{
			PrintHlp(HELP_TXT, f.tem[cur >> 1][cur&1].laddr + (f.tem[cur >> 1][cur&1].haddr << 8), fp, 0);
		}
		else if (key == ESC_KEY)
		{
			fclose(fp);
			return;
		}
		else if (isalpha(key))
		{
			if (skey != key)
			{
				skey = toupper(key);
				flag = 0;
FUN_NAME_SEEK:
				t = SFunSeekName(f, skey);
				if (t >= 0)
				{
					flag = 2;
					cur = t;
					if (cur > first + 7 || cur < first) first = cur&(-2);
				}
				else if (flag < 1)
				{
					flag++;
FUN_NAME_CHG:
					if (skey < 'a') skey = tolower(skey);
					else skey = toupper(skey);
					goto FUN_NAME_SEEK;
				}
			}
			else if (flag == 2)
			{
				if (cur + 1 < f.size)
				{
					skey = f.tem[cur >> 1][cur&1].name[0];
					cur++;
					if (f.tem[cur >> 1][cur&1].name[0] != skey)
					{
						flag = 0;
						goto FUN_NAME_CHG;
					}
					if (cur > first + 7)
					{
						first = first + 2;
					}
				}
				else
				{
					flag = 0;
					goto FUN_NAME_CHG;
				}
			}
		}
		else if (key == F3_KEY)
		{
			first = cur = 0;
		}
		else if (key == F4_KEY)
		{
			cur = f.size - 1;
			first = cur&(-2);
		}
		else if (key == HELP_KEY) HelpHelp2();
		else if (!cfset.dat[0].tem[2].value) Beep();
	}
}

void Help()/* 帮助系统[通用] */
{
	int cur[2];

	for (cur[0] = 0;;)
	{
		cur[0] = Cata(CATAL_TABLE, 3, cur[0], CAT_HELP);
		if (cur[0] < 0) return;//返回按键信息
		if (!cur[0])
		{
			PrintHlp(HELP_TXT, 6, 0, 0);
		}
		else if (cur[0] == 1)
		{
			for (cur[1] = 0;;)
			{
				cur[1] = Cata(CATAL_TABLE, 4, cur[1], CAT_HELP);
				if (cur[1] < 0) break;
				if (!cur[1])
				{
					PrintHlp(HELP_TXT, 7, 0, 0);
				}
				else if (cur[1] == 1)
				{
					PrintHlp(HELP_TXT, 8, 0, 0);
				}
				else if (cur[1] == 2)
				{
					PrintHlp(HELP_TXT, 9, 0, 0);
				}
				else
				{
					PrintHlp(HELP_TXT, 10, 0, 0);
				}
			}
		}
		else if (cur[0] == 2)
		{
			for (cur[1] = 0;;)
			{
				cur[1] = Cata(CATAL_TABLE, 5, cur[1], CAT_HELP);
				if(cur[1] < 0) break;
				if (!cur[1])
				{
					PrintHlp(HELP_TXT, 11, 0, 0);
				}
				else if (cur[1] == 1)
				{
					PrintHlp(HELP_TXT, 12, 0, 0);
				}
				else if (cur[1] == 2)
				{
					PrintHlp(HELP_TXT, 13, 0, 0);
				}
				else
				{
					PrintHlp(HELP_TXT, 14, 0, 0);
				}
			}
		}
		else
		{
			FunHelp((HELP_TXT+HLP_L_SIZE+1));
		}
	}
}
//*****************************************************文字输入系统*****************************************************//
char Getsign()/* 获取符号 */
{
	char key, i, j;
	char numkey[10], mark[4][18];

	TextOut(1, 64, "符", 0xc2);
	strcpy(numkey, "bnmghjtyu");
	strcpy(mark, ". , ; - / ? ! $ % ( ) : ` ' \" < > { } [ ] # ~ @ ^ & * + = _ | '         ");
	mark[3][8] = 92;
	for (i = 0;;)
	{
		TextOut(17, 64, mark[i], 0xc1);
		key = getchar();
		if (key == UP_KEY || key == LEFT_KEY || key == UU_KEY)
		{
			if (i)
			{
				i--;
				continue;
			}
		}
		else if (key == DOWN_KEY || key == RIGHT_KEY || key == '0' || key == DD_KEY)
		{
			if (i < 3)
			{
				i++;
				continue;
			}
		}
		else if (strchr(numkey, key))
		{
			j = strchr(numkey, key) - numkey;
			if (mark[i][j << 1] > ' ') return(mark[i][j << 1]);
		}
		else if (isdigit(key))
		{
			j = key - '0';
			if (mark[i][j << 1] > ' ') return(mark[i][j << 1]);
		}
		else if (key == ESC_KEY)
		{
			return(0);
		}
		if (!cfset.dat[0].tem[2].value) Beep();
	}
}

/* 输入 type:bit0, 1:0=num, 1=eng, 2=han 2:1=han 3:1=min 4:1=!sign */
int Inputw(char &tag[], char &text[], int len, int type)
{
	char key, tkey, skey, con;//按键值 缓冲按键值 锁定键 锁定连续响应键
	char han, min, sign;//是否支持汉字, 是否小写, 是否禁止符号输入
	char i, j, numkey[10];
	char str[20];//临时字符串
	long m, n;//临时变量
 
	han = type&4;
	min = (type&8) >> 3;
	sign = !(type&16);
	type = type&3;
	if (han)//打开字库
	{
		if (!datfp)
		{
			ChDir(cpldata);
			if (!(datfp = fopen("compile.dat", "r"))) han = 0;
		}
	}
	i = j = 0;
	strcpy(numkey, "bnmghjtyu");
	memset(text, 0, len);
	Swin("输入", NULL, SWIN_COM);
	TextOut(18, 36, tag, 1);
#if WQX == 0
	MyBox(18, 52, 137, 66, 1);
#else
	Rectangle(18, 52, 137, 66, 1);
#endif
START:
	skey = CheckKey(128);//终止响应键
START1:
	Block(19, 53, 136, 65, 0);
	if (i < j) j = i;
	else
	{
		while (i > j + 19)
		{
			if (*(text + (j++)) >= 160)j++;
		}
	}
	memcpy(str, text + j, 19);
	n = j;
	while (n < j + 19)
	{
		if (*(text + (n++)) >= 160)
		{
			if (n >= j + 19)
			{
				n--;
				break;
			}
			n++;
		}
	}
	str[n - j] = 0;
	TextOut(19, 54, str, 1);
	if (!type)
	{
		TextOut(120, 40, "num", 1);
	}
	else if (type == 1)
	{
		if (min)
		{
			TextOut(120, 40, "eng", 1);
		}
		else
		{
			TextOut(120, 40, "ENG", 1);
		}
	}
	else
	{
		TextOut(120, 40, "han", 1);
	}
	Refresh();
	for (m = n = 0;;)
	{
		if (type == 2)//中文输入
		{
			n = Input((i - j) * 6 + 19, 4, &skey, &con);
			if (n < 0xff)
			{
				key = n;
				break;
			}
			if (strlen(text) < len - 2)
			{
				memmove(text + i + 2, text + i, strlen(text + i));
				memcpy(text + i, n, 2);//写入汉字
				i = i + 2;
			}
			goto START;
		}
		if (!n) Box((i - j) * 6 + 19, 54, (i - j) * 6 + 20, 65, 1, 2);
		if ((n++) == (cfset.dat[3].tem[1].value << 4)) n = 0;
		tkey = key;
		key = CheckKey(128);
		Inkey();
		if (skey == key || !key)
		{
			skey = key;
			continue;
		}
		if (key == tkey)
		{
			if (++m >= cfset.dat[3].tem[0].value || con)
			{
				con = 1;
				break;
			}
			Delay(20);
			n = 1;
		}
		else
		{
			con = 0;
			break;
		}
	}
	if (key == F2_KEY)
	{
		if (i)
		{
			if (text[i - 1] >= 160)
			{
				n = 2;
			}
			else
			{
				n = 1;
			}
			memmove(text + i - n, text + i, strlen(text + i));
			i = i - n;
			memset(text+strlen(text) - n, 0, n);
			goto START1;
		}
	}
	else if (key == F3_KEY)
	{
		i = j = 0;
		goto START;
	}
	else if (key == F4_KEY)
	{
		i = j = strlen(text);
		while (i < j + 19 && j)
		{
			if (*(text + (--j)) >= 160) j--;
		}
		goto START;
	}
	else if (key == CR_KEY)
	{
		return(text[0]);
	}
	else if (key == ESC_KEY)
	{
		return(text[0] = 0);
	}
	else if (key == SHIFT_KEY)
	{
		if (++type == 3 || (!han && type == 2)) type = 0;
		goto START;
	}
	else if (key == CAPS_KEY)
	{
		min = min ^ 1;
		goto START;
	}
	else if (key == LEFT_KEY || key == UP_KEY)
	{
		if (i)
		{
			if (text[--i] >= 160) i--;
			goto START1;
		}
	}
	else if (key == RIGHT_KEY || key == DOWN_KEY)
	{
		if (i < strlen(text))
		{
			if (text[i++] >= 160) i++;
			goto START1;
		}
	}
	else if (isprint(n = key))
	{
		if (type == 1)//英文
		{
			if (n == '0' && sign)//符号
			{
				n = Getsign();
				if (!n) goto START;
			}
			else if (!min)
			{
				n = toupper(n);//大字母
			}
		}
		else if (strchr(numkey, n))
		{
			n = strchr(numkey, n) - numkey + '1';//数字
		}
		if (strlen(text) < len - 1)
		{
			memmove(text + i + 1, text + i, strlen(text + i));
			text[i++] = n;
			if (key == '0' && type == 1) goto START;
			goto START1;
		}
		if (key == '0' && type == 1)
		{
			if (!cfset.dat[0].tem[2].value) Beep();
			goto START;
		}
	}
	if (!cfset.dat[0].tem[2].value) Beep();
	goto START1;
}
//********************************************************宏系统********************************************************//
/* 宏表操作 -1:错误 -2:溢出*/
int MAC_Op(struct MACTABLE &mac, struct MACUNIT &e, int cmd)
{
	int low, mid, high;
	int value;

	if (cmd == TABLE_INS | cmd == TABLE_SEK)
	{
		low = 0;
		high = mac.size - 1;
		while (low <= high)
		{
			mid=(low+high) >> 1;
			value = strcmp(mac.dat[mid].name, e.name);
			if (!value)
			{
				if (cmd == TABLE_SEK)
				{
					strcpy(e.value, mac.dat[mid].value);
					return(mid);
				}
				return(-1);
			}
			else if (value>0)
			{
				high = mid - 1;
			}
			else
			{
				low = mid + 1;
			}
		}
		if (cmd == TABLE_SEK) return(-1);
		if (mac.size >= MAC_M_SIZE) return(-2);//溢出判断
		memmove(mac.dat[low + 1], mac.dat[low], (mac.size - low) * sizeof(struct MACUNIT));//插入
		memcpy(mac.dat[low], e, sizeof(struct MACUNIT));
		mac.size++;
	}
	else if (cmd == TABLE_DEL)
	{
		mac.size--;
		memmove(mac.dat[e.id], mac.dat[e.id+1], (mac.size - e.id) * sizeof(struct MACUNIT));
		memset(mac.dat[mac.size], 0, sizeof(struct MACUNIT));
	}
	else if (cmd == 0)
	{
		memset(mac, 0, sizeof(struct MACTABLE));
	}
}

/* 文件夹表操作 查找 成功返回指针, 否则返回-1.插入 成功返回id号, 否则返回id号|0x8000 */
int DOC_Op(struct MACTABLE &mac, struct DOCTABLE &doc, struct DOCUNIT &e, int cmd)
{
	int i, value, cur;

	if (cmd == TABLE_SEK)
	{
		for (i = 0; i < doc.size; i++)
		{
			if (!strcmp(doc.dat[i].name, e.name)) return(i);
		}
		return(-1);
	}
	else if (cmd == TABLE_INS)
	{
		i = DOC_Op(mac, doc, e, TABLE_SEK);
		if (i < 0)
		{
			for (value = 1; value <= DOC_D_SIZE; value++)//分配id
			{
				for (i = 0; i < doc.size; i++)
				{
					if (doc.dat[i].id == value) goto END;
				}
				e.id = value;
				break;
END:
			}
			memcpy(doc.dat[doc.size++], e, sizeof(struct DOCUNIT));return(e.id);
		}
		return(doc.dat[i].id|0x8000);
	}
	else if (cmd == TABLE_DEL)
	{
		value = doc.dat[cur = e.id].id;
		for (i = 0 ; i < mac.size; i++)//宏删除
		{
			while (mac.dat[i].id == value)
			{
				e.id = i;
				MAC_Op(mac, e, TABLE_DEL);
			}
		}
		doc.size--;
		memmove(doc.dat[cur], doc.dat[cur+1], (doc.size - cur) * sizeof(struct DOCUNIT));//文件夹删除
		memset(doc.dat[doc.size], 0, sizeof(struct DOCUNIT));
	}
	else if (cmd == 0)
	{
		memset(doc, 0, sizeof(struct DOCTABLE));
	}
}

/* macro.dat操作:0保存, 1读取 返回:0:正常 1:文件打开错误 2:文件读写错误*/
int DiskMacro(struct MACTABLE &mac, struct DOCTABLE &doc, int cmd)
{
	char fp;
	int offset;
 
	ChPath(cpldata);
	if (cmd == TABLE_RED)
	{
		MAC_Op(mac, NULL, 0);
		DOC_Op(mac, doc, NULL, 0);//初始化
		if (!(fp = fopen("macro.dat", "r")))
		{
			if (DataRead(mac, 1, 0) < 0) return(0);
			DataRead(mac, mac.size * sizeof(struct MACUNIT) + 1, 0);//读取初始化数据
			strcpy(doc.dat[0].name, "内置");
			doc.dat[0].id = doc.size = 1;//文件夹初始化
		}
		else
		{
			if (fread(&offset, 1, 2, fp) == 2)
			{
				fread(mac, 1, sizeof(struct MACTABLE), fp);//宏表
				if (mac.size <= MAC_M_SIZE)
				{
					fseek(fp, offset, 0);
					fread(doc, 1, sizeof(struct DOCTABLE), fp);//文件夹表
					if (doc.size <= DOC_D_SIZE)
					{
						fclose(fp);
						return(0);
					}
				}
			}
			MAC_Op(mac, NULL, 0);
			DOC_Op(mac, doc, NULL, 0);
			fclose(fp);
			return(0);
		}
	}
	if (!(fp = fopen("macro.dat", "w"))) return(1);
	fwrite(&offset, 1, 2, fp);
	if (fwrite(mac, 1, sizeof(struct MACTABLE), fp) != sizeof(struct MACTABLE))
	{
		fclose(fp);
		return(2);
	}
	offset = ftell(fp);
	fwrite(doc, 1, sizeof(struct DOCTABLE), fp);
	rewind(fp);
	fwrite(&offset, 1, 2, fp);
	fclose(fp);
}
//******************************************************宏查看系统******************************************************//
void MacroHelp_()
{
	char key;
	char s[5][30];

_S1:
	strcpy(s[0], "A、F1:添加一个宏定义");
	strcpy(s[1], "D、F2:删除一个宏定义");
	strcpy(s[2], "F3键 :查找宏定义");
	strcpy(s[3], "F4键 :修改宏定义的值");
	strcpy(s[4], "M键  :移动宏定义的位置");
	PrintMsg(s, 0);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
	if (key == ESC_KEY || key == 'q') return;
	strcpy(s[0], "S键  :保存当前宏定义");
	strcpy(s[1], "CR键 :查看当前宏定义");
	strcpy(s[2], "ESC键:返回上一级界面");
	s[3][0] = 0;
	PrintMsg(s, 0);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
}

int MoveDM(struct DOCTABLE &doc, int cmd)/*移动宏, 文件夹*/
{
	char key;
	int i;

	Swin("移动", "移动到       ", SWIN_STW);
	if (cmd == DOC_MOVE)
	{
		TextOut(115, 37, "之后", 1);
	}
	else if (cmd == MAC_MOVE)
	{
		TextOut(115, 37, "之中", 1);
	}
	for (i = 0;;)
	{
		Block(90, 37, 113, 49, 0);
		TextOut(90, 37, doc.dat[i].name, 1);
		Rectangle(90, 36, 115, 49, 1);
		Refresh();
		key = getchar();
		if ((key == RIGHT_KEY || key == DOWN_KEY) && i + 1 < doc.size)
		{
			i++;
		}
		else if ((key == LEFT_KEY || key == UP_KEY) && i)
		{
			i--;
		}
		else if (key == Y_KEY || key == CR_KEY)
		{
			Button(55, 56, "是[Y]", BUTTON_DOWN);
			return(i);
		}
		else if (key == N_KEY || key == ESC_KEY || key == 'q')
		{
			Button(98, 56, "否[N]", BUTTON_DOWN);
			return(-1);
		}
		else if (!cfset.dat[0].tem[2].value) Beep();
	}
}

#if WQX == 0
void LookFace(char &str[])/*皮肤*/
{
	Dwin(str);
	MyBox(4, 22, 109, 76, 4);
	TextOut(10, 17, "浏览", 1);
	Button(112, 18, "添加[A]", BUTTON_UP);
	Button(112, 33, "删除[D]", BUTTON_UP);
	Button(112, 48, "载入[L]", BUTTON_UP);
	Button(112, 63, "保存[S]", BUTTON_UP);
}

void PrintMac(int first, int value, struct MACSHI &shi, struct MACTABLE &mac)/*宏显示*/
{
	struct MACUNIT e;
	char i;

	Block(6, 28, 108, 75, 0);
	for (i = 0; i < 4 && i + first < shi.size; i++)
	{
		memcpy(e, mac.dat[shi.sqr[first + i]], sizeof(struct MACUNIT));
		if (strlen(e.name) > 7) strcpy(e.name + 7, "~");
		if (strlen(e.value) > 7) strcpy(e.value + 7, "~");
		TextOut(6, i * 12 + 28, e.name, 1);
		TextOut(58, i * 12 + 28, e.value, 1);
	}
	Block(6, value * 12 + 28, 108, value * 12 + 39, 2);
}
#else
void LookFace(char &str[])/*皮肤*/
{
	Dwin(str);
	Rectangle(3, 21, 110, 77, 1);
	TextOut(10, 16, "浏览", 1);
	Button(112, 16, "添加[A]", BUTTON_UP);
	Button(112, 32, "删除[D]", BUTTON_UP);
	Button(112, 48, "载入[L]", BUTTON_UP);
	Button(112, 64, "保存[S]", BUTTON_UP);
}

void PrintMac(int first, int value, struct MACSHI &shi, struct MACTABLE &mac)/*宏显示*/
{
	struct MACUNIT e;
	char i;
 
	Block(4, 28, 109, 76, 0);
	for (i = 0; i < 4 && i + first < shi.size; i++)
	{
		memcpy(e, mac.dat[shi.sqr[first + i]], sizeof(struct MACUNIT));
		if (strlen(e.name) > 7) strcpy(e.name + 7, "~");
		if (strlen(e.value) > 7) strcpy(e.value + 7, "~");
		TextOut(4, i * 12 + 28, e.name, 1);
		TextOut(56, i * 12 + 28, e.value, 1);
	}
	Block(4, value * 12 + 28, 109, value * 12 + 39, 2);
}
#endif

void Resqr(struct MACSHI &shi, struct MACTABLE &mac, int id)/*映射表操作*/
{
	int i, j;

	for (i = j = 0; i < mac.size; i++)
	{
		if (mac.dat[i].id == id) shi.sqr[j++] = i;
	}
	shi.size = j;
}

int LookMacro(struct MACSHI &shi, struct MACTABLE &mac, struct DOCTABLE &doc, int id)/*宏查看*/
{
	struct MACUNIT e;
	char msg[20];
	char key, change;
	int first, cur, value, t;

	Resqr(shi, mac, id);
	for (first = cur = change = 0;;)
	{
		LookFace("系统宏");
		PrintMac(first, cur - first, shi, mac);
		Refresh();//界面
		key = getchar();
		if ((key == UP_KEY || key == LEFT_KEY) && cur)
		{
			cur--;
			if (cur < first) first = cur;
		}
		else if ((key == DOWN_KEY || key == RIGHT_KEY) && cur + 1 < shi.size)
		{
			cur++;
			if (cur > first + 3) first = cur - 3;
		}
		else if (key == UU_KEY)
		{
			if (first < 4)
			{
				cur = cur - first;
				first = 0;
			}
			else
			{
				first = first - 4;
				cur = cur - 4;
			}
		}
		else if (key == DD_KEY && first + 4 < shi.size)
		{
			first = first + 4;
			cur = cur + 4;
			if (cur >= shi.size) cur = shi.size - 1;
		}
		else if (key == A_KEY || key == F1_KEY)//插入
		{
			Button(112, 16, "添加[A]", BUTTON_DOWN);
			if (mac.size >= MAC_M_SIZE)
			{
				sprintf(msg, "宏个数已达%d个", MAC_M_SIZE);
				Swin("提醒！", msg, SWIN_ONE);
			}
			else if (Inputw("请输入宏名:", e.name, MAC_N_LEN, 1))
			{
				if (Inputw("请输入宏值:", e.value, MAC_V_LEN, 0))
				{
					e.id = id;
					t = MAC_Op(mac, e, TABLE_INS);
					if (t == -2)
					{
						Swin("警告！", "宏定义太多", SWIN_ONE);
					}
					if (t == -1)
					{
						Swin("警告！", "存在同名的宏", SWIN_ONE);
					}
					else
					{
						Resqr(shi, mac, id);
						change = 1;
					}
				}
			}
		}
		else if (key == D_KEY || key == F2_KEY)//删除
		{
			Button(112, 32, "删除[D]", BUTTON_DOWN);
			if (!shi.size)
			{
				Swin("警告！", "没有宏可删除", SWIN_ONE);
			}
			else
			{
				if (cfset.dat[2].tem[1].value)
				{
					if (!Swin("删除？", "真的要删除么", SWIN_TWO)) continue;
				}
				e.id = shi.sqr[cur];
				MAC_Op(mac, e, TABLE_DEL);
				Resqr(shi, mac, id);
				if (shi.size && cur >= shi.size)
				{
					cur = shi.size - 1;
					if (cur < first) first = cur;
				}
				change = 1;
			}
		}
		else if (key == F3_KEY)//查找
		{
			if (!shi.size)
			{
				Swin("警告！", "没有宏可查找", SWIN_ONE);
			}
			else if (Inputw("请输入宏名:", e.name, MAC_N_LEN, 1))
			{
				value = MAC_Op(mac, e, TABLE_SEK);
				if (value < 0)
				{
					Swin("信息", "没有找到", SWIN_ONE);
					continue;
				}
				Resqr(shi, mac, mac.dat[value].id);
				for (cur = 0; cur < shi.size; cur++)
				{
					if (!strcmp(e.name, mac.dat[shi.sqr[cur]].name)) break;
				}
				first = cur;
			}
		}
		else if (key == F4_KEY)//修改
		{
			if (!shi.size)
			{
				Swin("警告！", "没有宏可修改", SWIN_ONE);
			}
			else if (Inputw("当前宏值替换为:", e.value, MAC_V_LEN, 0))
			{
				strcpy(mac.dat[shi.sqr[cur]].value, e.value);
				change = 1;
			}
		}
		else if (key == CR_KEY)//查看
		{
			if (!shi.size)
			{
				Swin("警告！", "没有宏可查看", SWIN_ONE);
			}
			else
			{
				Swin("查看", NULL, SWIN_COM);
				TextOut(16, 38, "M:", 1);
				TextOut(28, 38, mac.dat[shi.sqr[cur]].name, 1);
				Line(28, 49, 136, 49, 65);
				TextOut(16, 55, "Z:", 1);
				TextOut(28, 55, mac.dat[shi.sqr[cur]].value, 1);
				Line(28, 66, 136, 66, 65);
				Refresh();
				while (getchar() != ESC_KEY);
			}
		}
		else if (key == S_KEY)//保存
		{
			Button(112, 64, "保存[S]", BUTTON_DOWN);
			if (cfset.dat[2].tem[2].value)
			{
				if (!Swin("保存？", "真的要保存么", SWIN_TWO)) continue;
			}
			LookFace("系统宏");
			//TextOut(30, 45, "保存中...", 1);
			textout(30, 45, "保存中...", 1);
			Refresh();
			t = DiskMacro(mac, doc, 10);
			if (t == 1)
			{
				Swin("错误！", "无法创建宏文件", SWIN_ONE);
			}
			else if (t == 2)
			{
				Swin("错误！", "文件读写出错", SWIN_ONE);
			}
			else
			{
				change = 2;
			}
		}
		else if (key == M_KEY)//移动
		{
			if (doc.size < 2 || !shi.size)
			{
				Swin("警告！", "无法移动宏", SWIN_ONE);
			}
			else if ((value=MoveDM(doc, MAC_MOVE)) != -1)
			{
				mac.dat[shi.sqr[cur]].id = doc.dat[value].id;
				Resqr(shi, mac, id);
				if (shi.size&cur >= shi.size)
				{
					cur = shi.size - 1;
					if (cur < first) first = cur;
				}
				change = 1;
			}
		}
		else if (key == ESC_KEY || key == 'q')
		{
			return(change);
		}
		else if (key == HELP_KEY)
		{
			MacroHelp_();
		}
		else if (!cfset.dat[0].tem[2].value) Beep();
	}
}
//******************************************************文件夹系统******************************************************//
void MacroHelp()
{
	char key;
	char s[5][30];

_S1:
	strcpy(s[0], "A、F1:添加一个文件夹");
	strcpy(s[1], "D、F2:删除一个文件夹");
	strcpy(s[2], "F3键 :查找文件夹");
	strcpy(s[3], "F4键 :修改文件夹的名称");
	strcpy(s[4], "L键  :从文件添加宏定义");
	PrintMsg(s, 0);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
	if (key == ESC_KEY || key == 'q') return;
	strcpy(s[0], "M键  :移动文件夹的位置");
	strcpy(s[1], "S键  :保存当前宏定义");
	strcpy(s[2], "CR键 :进入文件夹浏览");
	strcpy(s[3], "ESC键:退出宏管理系统");
	strcpy(s[4], ".键  :导出当前宏定义");
	PrintMsg(s, 0);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
}

void SaveMacroTxt(struct MACUNIT &e, char fp)
{
	fseek(fp, 0, 2);
	putc(13, fp);
	putc(10, fp);
	fwrite("#define ", 1, 8, fp);
	fwrite(e.name, 1, strlen(e.name), fp);
	putc(' ', fp);
	fwrite(e.value, 1, strlen(e.value), fp);
}

void SaveHead(char &name[], char fp, char cmd)
{
	struct TIME time;
	char str[50];

	fseek(fp, 0, 2);
	putc(13, fp);
	putc(10, fp);
	GetTime(time);
	sprintf(str, "%s:%d/%d/%d %d:%d:%d", name, time.year, time.month, time.day, time.hour, time.minute, time.second);
	if (cmd)
	{
		strcat(str, " [output]");
	}
	else
	{
		strcat(str, " [error]");
	}
	fwrite(str, 1, strlen(str), out.fp);
}

void SavetoTxt(struct MACTABLE &mac)
{
	char i;

	if (ChPath(txtdata))
	{
		Swin("错误！", "无法进入目录", SWIN_ONE);
		return;
	}
	if (!(out.fp = fopen("Macro.txt", "r+")))
	{
		if (!(out.fp = fopen("Macro.txt", "w")))
		{
			Swin("错误！", "无法创建文件", SWIN_ONE);
			return;
		}
	}
	LookFace("系统宏");
	//TextOut(30, 45, "另存中...", 1);
	textout(30, 45, "另存中...", 1);
	Refresh();
	SaveHead("Macro.txt", out.fp, 1);
	for (i = 0; i < mac.size; i++)
	{
		SaveMacroTxt(mac.dat[i], out.fp);
	}
	putc(13, out.fp);
	putc(10, out.fp);
	fclose(out.fp);
	out.fp = 0;
}

int AddMacro(struct MACTABLE &mac, struct DOCTABLE &doc)//加载文件
{
	struct MACUNIT m;
	struct DOCUNIT d;
	int md, dd, t;
	char ms, ds, i, j, rt, k, str[16], v[19];

	if (!ChDir(out.path))
	{
		Swin("错误！", "无法进入目录", SWIN_ONE);
		return(0);
	}
	if (!(in.fp = fopen(out.name, "r")))
	{
		Swin("错误！", "无法打开文件", SWIN_ONE);
		return(0);
	}
	if (!(out.fp = fopen("NotLoad.txt", "r+")))
	{
		if (!(out.fp = fopen("NotLoad.txt", "w")))
		{
			Swin("错误！", "无法创建文件", SWIN_ONE);
			return(0);
		}
	}
	fread(&dd, 1, 2, in.fp);
	ms = getc(in.fp);
	if (ms + mac.size <= MAC_M_SIZE)
	{
		fseek(in.fp, dd, 0);
		ds = getc(in.fp);
		if (ds + doc.size <= DOC_D_SIZE) goto START;
	}
	Swin("警告！", "无法全部载入", SWIN_ONE);
	rt = 0;
	goto END;
START:
	LookFace("系统宏");
	//TextOut(30, 45, "载入中...", 1);
	textout(30, 45, "载入中...", 1);
	Refresh();
	SaveHead(out.name, out.fp, 0);
	md = 3;
	dd++;
	for (k = i = 0; i < ms; i++)
	{
		fseek(in.fp, md, 0);
		fread(m, 1, sizeof(struct MACUNIT), in.fp);
		md=ftell(in.fp);
		strcpy(v, m.value);
		t = MAC_Op(mac, m, TABLE_SEK);
		if (t < 0)
		{
			fseek(in.fp, dd, 0);
			k++;
			for (j = 0; j < ds; j++)
			{
				fread(d, 1, sizeof(struct DOCUNIT), in.fp);
				if (d.id == m.id)//插入
				{
					t = DOC_Op(NULL, doc, d, TABLE_INS);
					m.id = t&0x7fff;
					MAC_Op(mac, m, TABLE_INS);
					break;
				}
			}
		}
		else if (strcmp(mac.dat[t].value, v))
		{
			strcpy(m.value, v);
			SaveMacroTxt(m, out.fp);
		}
	}
	putc(13, out.fp);
	putc(10, out.fp);
	rt = 1;
END:
	fclose(in.fp);
	fclose(out.fp);
	out.fp = in.fp = 0;
	sprintf(str, "%d个宏被加载", k);
	Swin("信息", str, SWIN_ONE);
	return(rt);
}

#if WQX == 0
void PrintDoc(int first, int value, struct DOCTABLE &doc)/*文件夹显示*/
{
	int i;

	Block(6, 28, 108, 75, 0);
	for (i = 0; i < 3 && i + first < doc.size; i++)
	{
		WriteBlock(i * 35 + 6, 28, 32, 32, 1, pic[PIC_DOCU]);
		TextOut(i * 35 - strlen(doc.dat[i + first].name) * 3 + 22, 63, doc.dat[i + first].name, 1);
	}
	if (doc.size) Block(value * 35 + 6, 28, value * 35 + 38, 60, 2);
}
#else
void PrintDoc(int first, int value, struct DOCTABLE &doc)/*文件夹显示*/
{
	int i;
 
	Block(4, 28, 109, 76, 0);
	for (i = 0; i < 3 && i + first < doc.size; i++)
	{
		WriteBlock(i * 35 + 5, 28, 32, 32, 1, pic[PIC_DOCU]);
		TextOut(i * 35 - strlen(doc.dat[i + first].name) * 3 + 21, 63, doc.dat[i + first].name, 1);
	}
	if (doc.size) Block(value * 35 + 5, 28, value * 35 + 37, 60, 2);
}
#endif

void LookDoc(struct MACTABLE &mac, struct DOCTABLE &doc)/*文件夹查看*/
{
	struct DOCUNIT e;
	char msg[20];
	char key, change;
	int first, cur, value, dire, t;//方向
 
	LookFace("系统宏");
	//TextOut(30, 45, "载入中...", 1);
	textout(30, 45, "载入中...", 1);
	Refresh();//界面
	t = DiskMacro(mac, doc, TABLE_RED);
	if (t == 1)
	{
		Swin("错误！", "无法创建宏文件", SWIN_ONE);
	}
	else if (t == 2)
	{
		Swin("错误！", "文件读写出错", SWIN_ONE);
	}
	for (first = cur = change = 0;;)
	{
		LookFace("系统宏");
		PrintDoc(first, cur - first, doc);
		Refresh();//界面
		key = getchar();
		if (key == LEFT_KEY&cur)
		{
			cur--;
			if (cur < first) first = cur;
		}
		else if (key == RIGHT_KEY && cur + 1 < doc.size)
		{
			cur++;
			if (cur > first + 2) first = cur - 2;
		}
		else if (key == UP_KEY || key == UU_KEY)
		{
			if (first < 3)
			{
				cur = cur - first;
				first = 0;
			}
			else
			{
				first = first - 3;
				cur = cur - 3;
			}
		}
		else if ((key == DOWN_KEY || key == DD_KEY) && first + 3 < doc.size)
		{
			first = first + 3;
			cur = cur + 3;
			if (cur >= doc.size) cur = doc.size - 1;
		}
		else if (key == A_KEY || key == F1_KEY)//插入
		{
			Button(112, 16, "添加[A]", BUTTON_DOWN);
			if (doc.size >= DOC_D_SIZE)
			{
				sprintf(msg, "文件夹已达%d个", DOC_D_SIZE);
				Swin("提醒！", msg, SWIN_ONE);
			}
			else if (Inputw("请输入文件夹名:", e.name, DOC_N_LEN, 6))
			{
				t = DOC_Op(NULL, doc, e, TABLE_INS);
				if (t < 0)
				{
					Swin("警告！", "存在同名文件夹", SWIN_ONE);
				}
				else
				{
					change = 1;
				}
			}
		}
		else if (key == D_KEY || key == F2_KEY)//删除
		{
			Button(112, 32, "删除[D]", BUTTON_DOWN);
			if (!doc.size)
			{
				Swin("警告！", "无文件夹可删除", SWIN_ONE);
			}
			else
			{
				if (cfset.dat[2].tem[0].value)
				{
					if (!Swin("删除？", "真的要删除么", SWIN_TWO))continue;
				}
				e.id = cur;
				DOC_Op(mac, doc, e, TABLE_DEL);
				if (doc.size&cur >= doc.size)
				{
					cur = doc.size - 1;
					if (cur < first) first = cur;
				}
				change = 1;
			}
		}
		else if (key == F3_KEY)//查找
		{
			if (!doc.size)
			{
				Swin("警告！", "无文件夹可查找", SWIN_ONE);
			}
			else if (Inputw("请输入文件夹名:", e.name, DOC_N_LEN, 6))
			{
				value = DOC_Op(NULL, doc, e, TABLE_SEK);
				if (value < 0)
				{
					Swin("信息", "没有找到", SWIN_ONE);
				}
				else
				{
					first = cur = value;
				}
			}
		}
		else if (key == F4_KEY)//修改
		{
			if (!doc.size)
			{
				Swin("警告！", "无文件夹可修改", SWIN_ONE);
			}
			else if (Inputw("当前名称替换为:", e.name, DOC_N_LEN, 6))
			{
				t = DOC_Op(NULL, doc, e, TABLE_SEK);
				if (t < 0)
				{
					Swin("警告！", "存在同名文件夹", SWIN_ONE);
				}
				else
				{
					strcpy(doc.dat[cur].name, e.name);
					change = 1;
				}
			}
		}
		else if (key == CR_KEY && doc.size)
		{
			t = LookMacro(((DOCUM_TABLE+(DOC_N_LEN+1)*DOC_D_SIZE+1)+(MAC_N_LEN+MAC_V_LEN+1)*MAC_M_SIZE+1), mac, doc, doc.dat[cur].id);//查看
			if (t == 2)
			{
				change = 0;
			}
			else
			{
				change = change|t;
			}
		}
		else if (key == ESC_KEY || key == 'q')//返回
		{
			if (change && !cfset.dat[2].tem[3].value)
			{
				if (!Swin("退出？", "警告:数据已更改", SWIN_TWO)) continue;
			}
			return;
		}
		else if (key == S_KEY)//保存
		{
			Button(112, 64, "保存[S]", BUTTON_DOWN);
			if (cfset.dat[2].tem[2].value)
			{
				if (!Swin("保存？", "真的要保存么", SWIN_TWO)) continue;
			}
			LookFace("系统宏");
			//TextOut(30, 45, "保存中...", 1);
			textout(30, 45, "保存中...", 1);
			Refresh();
			t = DiskMacro(mac, doc, 10);
			if (t == 1)
			{
				Swin("错误！", "无法创建宏文件", SWIN_ONE);
			}
			else if (t == 2)
			{
				Swin("错误！", "文件读写出错", SWIN_ONE);
			}
			else
			{
				change = 0;
			}
		}
		else if (key == M_KEY)//移动
		{
			if (doc.size<2)
			{
				Swin("警告！", "无法移动文件夹", SWIN_ONE);
			}
			else if ((value = MoveDM(doc, DOC_MOVE)) != -1)
			{
				if (value > cur)
				{
					dire=1;
				}
				else if (value + 1 < cur)
				{
					dire=2;
				}
				else
				{
					dire=0;
				}
				if (dire)
				{
					memcpy(e, doc.dat[cur], sizeof(struct DOCUNIT));
					if (dire == 1)
					{
						memmove(doc.dat[cur], doc.dat[cur + 1], (value - cur) * sizeof(struct DOCUNIT));
					}
					else
					{
						memmove(doc.dat[value + 1], doc.dat[value], (cur - value) * sizeof(struct DOCUNIT));
						value++;
					}
					memcpy(doc.dat[value], e, sizeof(struct DOCUNIT));
					change = 1;
				}
			}
		}
		else if (key == 'l')
		{
			Button(112, 48, "载入[L]", BUTTON_DOWN);
			Swin("信息", "请选择加载文件", SWIN_ONE);
			if (SelectSrc(out, "/", 0xff))
			{
				if (AddMacro(mac, doc)) change = 1;
			}
		}
		else if (key == '.')
		{
			SavetoTxt(mac);
		}
		else if (key == HELP_KEY)
		{
			MacroHelp();
		}
		else if (!cfset.dat[0].tem[2].value) Beep();
	}
}
//******************************************************链接库系统******************************************************//
void LookLib()/*链接库浏览*/
{
	char fp, name[16];

	for (;;)
	{
		if (!SelectFil(name, libdata, "y")) return;
		if (!(fp = fopen(name, "r")))//打开
		{
			Swin("错误！", "无法打开文件", SWIN_ONE);
			return;
		}
		PrintHlp(HELP_TXT, 4, fp, name);//浏览
		fclose(fp);
	}
}
//*******************************************************链表操作*******************************************************//
int BlkCmp(int p, struct TXT_BLOCK &tb, char cmd)//块比较 不同返回非0,相同返回0
{
	char s[TXT_C_SIZE], ch;//临时缓冲区
	int len;//临时缓冲区实际大小
	long start;//块的文件起始地址
	int size;//块大小
	char fp;//块的文件句柄

	start = 0;
	if (cmd == TXT_SAV_H)
	{
		memcpy(&start, tb.p[tb.h].start, 3);
		memcpy(&size, tb.p[tb.h].size, 2);
		fp = tb.p[tb.h].fp;
	}
	else
	{
		memcpy(&start, tb.p[tb.n].start, 3);
		memcpy(&size, tb.p[tb.n].size, 2);
		fp = tb.p[tb.n].fp;
		p = p + strlen(p) - size;
	}
	if (!fp) return(1);
	fseek(fp, start, 0);
	while (size)//比较
	{
		if (size < TXT_C_SIZE - 1)
		{
			len = size;
		}
		else
		{
			len = TXT_C_SIZE - 1;
		}
		fread(s, 1, len, fp);
		s[len] = 0;
		ch = *(p + len);
		*(p + len) = 0;
		if (strcmp(s, p))
		{
			*(p + len) = ch;
			break;
		}
		*(p = p + len) = ch;
		size = size - len;
	}
	return(size);
}

/* 链表操作 返回保存,载入长度 -1:文件错误,-2:表溢出,-3:行太长,-4:读写错误 */
int TextLink(char &buf[], struct TXT_BLOCK &tb, char cmd)
{
	long start;//块的文件起始地址
	int size, rt, len;//块大小,返回值,缓冲区实际大小
	char i;//临时变量

	memset(&start, 0, &i - &start);
	len = strlen(buf);
	if (cmd >= TXT_LOD_N)//载入
	{
		while (len > TXT_B_SIZE)//缓冲区太小,先保存数据
		{
			rt = TextLink(buf, tb, cmd - TXT_LOD_N);
			if (rt < 0) return(rt);
			len = len - rt;
		}
		if (cmd == TXT_LOD_H)//链表定位
		{
			i = tb.h = tb.p[tb.h].head;
		}
		else
		{
			i = tb.n = tb.p[tb.n].next;
		}
		memcpy(&start, tb.p[i].start, 3);//读取块信息
		memcpy(&size, tb.p[i].size, 2);
		fseek(tb.p[i].fp, start, 0);
		if (cmd == TXT_LOD_H)//读取上一块
		{
			memmove(buf + size, buf, len);
			fread(buf, 1, size, tb.p[i].fp);
		}
		else//读取下一块
		{
			fread(buf + len, 1, size, tb.p[i].fp);
			size = rt;
		}
		return(size);
	}
	if (BlkCmp(buf, tb, cmd))
	{
		if (tb.size >= TXT_T_SIZE) return(-2);//溢出判断
		if (!tb.fp)//创建临时文件
		{
			if (ChPath(cpldata)) return(-1);
			if (!(tb.fp = fopen("mem.tmp", "w+"))) return(-1);
		}
		fseek(tb.fp, 0, 2);
		start = ftell(tb.fp);
		for (size = buf; rt = strchr(size, 13);)//分割,中点为size
		{
			if (cmd == TXT_SAV_H)
			{
				if (rt + 2 > buf + TXT_B_SIZE) break;
			}
			else if (buf + len - size < TXT_B_SIZE)
			{
				break;
			}
			size = rt + 2;
		}
		if (cmd == TXT_SAV_H)
		{
			if (fwrite(buf, 1, size = size - buf, tb.fp) != size) return(-4);
			if (!size) return(-3);//写入文件
			memcpy(tb.p[tb.h].start, &start, 3);
			memcpy(tb.p[tb.h].size, &size, 2);
			tb.p[tb.h].fp = tb.fp;//写入信息
			if (tb.n == tb.h)
			{
				if ((rt = tb.p[tb.h].next) != 255) tb.p[rt].head = tb.size;//链接
				tb.p[tb.h].next = tb.size;
				tb.p[tb.size].head = tb.h;
				tb.p[tb.size].next = rt;
				tb.n=tb.size++;
			}
			memmove(buf, buf+size, len = len - size);//擦除
			memset(buf + len, 0, TXT_SIZE - len);
			tb.h = tb.p[tb.h].next;
		}
		else
		{
			if (fwrite(size, 1, size = len + buf - size, tb.fp) != size) return(-4);
			if (!size) return(-3);//写入文件
			memcpy(tb.p[tb.n].start, &start, 3);
			memcpy(tb.p[tb.n].size, &size, 2);
			tb.p[tb.n].fp = tb.fp;//写入信息
			if (tb.h == tb.n)
			{
				if ((rt = tb.p[tb.n].head) != 254)//链接
				{
					tb.p[rt].next = tb.size;
				}
				else
				{
					tb.head = tb.size;
				}
				tb.p[tb.n].head = tb.size;
				tb.p[tb.size].next = tb.n;
				tb.p[tb.size].head = rt;
				tb.h=tb.size++;
			}
			memset(buf + len - size, 0, TXT_SIZE - len + size);
			tb.n = tb.p[tb.n].head;
		}
		return(size);
	}
	if (cmd == TXT_SAV_H)/* 擦除 */
	{
		memcpy(&size, tb.p[tb.h].size, 2);
		memmove(buf, buf+size, len = len - size);
		memset(buf + len, 0, TXT_SIZE - len);
		tb.h = tb.p[tb.h].next;
	}
	else
	{
		memcpy(&size, tb.p[tb.n].size, 2);
		memset(buf + len - size, 0, TXT_SIZE - len + size);
		tb.n = tb.p[tb.n].head;
	}
	return(size);
}

long TextLoad(char &buf[], struct TXT_BLOCK &tb)//载入文本,初始化链表 返回文件长度
{
	long start, size, len;
	int a, b;

	memset(tb, 0, sizeof(struct TXT_BLOCK));
	tb.p[0].head = 254;
	tb.p[0].next = 255;
	tb.size = 1;//初始化
	if (out.name[0])
	{
		if (!ChDir(out.path))
		{
			Swin("错误！", "无法进入目录", SWIN_ONE);
			return(-1);
		}
		if (!(in.fp = fopen(out.name, "r")))
		{
			Swin("错误！", "无法打开文件", SWIN_ONE);
			return(-1);
		}
		if (!getc(in.fp))//头定位
		{
			fseek(in.fp, 24, 0);
		}
		else
		{
			rewind(in.fp);
		}
		start = ftell(in.fp);
		fseek(in.fp, 0, 2);
		len = size = ftell(in.fp) - start;//起始地址,获取长度
		for (tb.size = 0; size; tb.size++)//文件分割
		{
			fseek(in.fp, start, 0);
			a = fread(buf, 1, TXT_B_SIZE, in.fp);
			buf[a] = 0;//读取数据到缓冲区
			if (size < TXT_B_SIZE)
			{
				b = size;//确定块大小
			}
			else
			{
				for (a = buf;;)
				{
					if (b = strchr(a, 13))
						a = b + 2;
					else
						break;
				}
				if (!(b = a - buf))
				{
					fclose(in.fp);
					in.fp = 0;
					Swin("警告！", "行字数太多", SWIN_ONE);
					return(-1);
				}
			}
			if (tb.size >= TXT_T_SIZE)//是否溢出
			{
				fclose(in.fp);
				in.fp = 0;
				Swin("警告！", "文本已到上限", SWIN_ONE);
				return(-1);
			}
			if (tb.size)//链接
			{
				tb.p[tb.size - 1].next = tb.size;
				tb.p[tb.size].head = tb.size - 1;
				tb.p[tb.size].next = 255;
			}
			memcpy(tb.p[tb.size].start, &start, 3);
			memcpy(tb.p[tb.size].size, &b, 2);
			tb.p[tb.size].fp = in.fp;//写入链表
			size = size - b;
			start = start + b;
		}
		memcpy(&start, tb.p[0].start, 3);
		memcpy(&size, tb.p[0].size, 2);
		fseek(in.fp, start, 0);//读取表头
		memset(buf, 0, TXT_B_SIZE);
		fread(buf, 1, size, in.fp);
		if (ChkExt(out.name, "h"))//载入
		{
			ChExt(out.name, "txt");
			strcpy(out.path, txtdata);
		}
		return(len);
	}
}

int BlkSave(char tp, char fp, int size)//保存块
{
	char s[TXT_C_SIZE];//临时缓冲区
	int len;//临时缓冲区实际大小

	while(size)
	{
		if (size < TXT_C_SIZE)
		{
			len = size;
		}
		else
		{
			len = TXT_C_SIZE;
		}
		fread(s, 1, len, fp);
		if (fwrite(s, 1, len, tp) != len) return(1);
		size = size - len;
	}
}

int TextSave(char &buf[], struct TXT_BLOCK &tb, long filelen)//保存文件
{
	long start;//块的文件起始地址
	int size;//块大小
	char i;//临时变量

	start = 0;
	if (in.fp)
	{
		if (!tb.fp)//创建临时文件
		{
			if (ChPath(cpldata))
			{
				Swin("错误！", "无法进入目录", SWIN_ONE);
				return(1);
			}
			if (!(tb.fp = fopen("mem.tmp", "w+")))
			{
				Swin("错误！", "无法创建文件", SWIN_ONE);
				return(1);
			}
		}
		for (i = tb.head; i != 255; i = tb.p[i].next)//整理链表
		{
			if (tb.p[i].fp != tb.fp)
			{
				memcpy(&start, tb.p[i].start, 3);
				fseek(in.fp, start, 0);
				fseek(tb.fp, 0, 2);
				start = ftell(tb.fp);
				memcpy(&size, tb.p[i].size, 2);
				if (BlkSave(tb.fp, in.fp, size))
				{
					Swin("错误！", "文件读写出错", SWIN_ONE);
					return(1);
				}
				memcpy(tb.p[i].start, &start, 3);
				tb.p[i].fp = tb.fp;
			}
		}
		fclose(in.fp);
		in.fp = 0;
	}
	if (ChPath(out.path))
	{
		Swin("错误！", "无法进入目录", SWIN_ONE);
		return(1);
	}
	if (out.fp = fopen(out.name, "r"))
	{
		fclose(out.fp);
		out.fp = 0;
		if (!Swin("存在同名文件", "是否覆盖？", SWIN_TWO)) return(1);
	}
	if (!(out.fp = fopen(out.name, "w"))) return(1);//创建保存文件
#if WQX != 0
	memset(&start, 0, 5);
	fwrite(&start, 1, 5, out.fp);
	putc(1, out.fp);
	putc(0, out.fp);
	putc(24, out.fp);
	fwrite(&start, 1, 2, out.fp);
	fwrite(&filelen, 1, 4, out.fp);
	fwrite(&start, 1, 2, out.fp);
	putc(24, out.fp);
	putc(0, out.fp);
	putc(0, out.fp);
	fwrite(&filelen, 1, 4, out.fp);
	putc(0, out.fp);
#endif
	for (i = tb.head; i != 255; i = tb.p[i].next)
	{
		if (i == tb.h)
		{
			if (fwrite(buf, 1, size = strlen(buf), out.fp) != size)
			{
				fclose(out.fp);
				out.fp = 0;
				Swin("错误！", "文件读写出错", SWIN_ONE);
				return(1);
			}
			i = tb.n;
		}
		else
		{
			memcpy(&start, tb.p[i].start, 3);
			fseek(tb.p[i].fp, start, 0);
			memcpy(&size, tb.p[i].size, 2);
			if (BlkSave(out.fp, tb.p[i].fp, size))
			{
				fclose(out.fp);
				out.fp = 0;
				Swin("错误！", "文件读写出错", SWIN_ONE);
				return(1);
			}
		}
	}
	fclose(out.fp);
	out.fp = tb.chg = 0;//清除修改标志
}

void Deltmp(struct TXT_BLOCK &tb)
{
	if (tb.fp)
	{
		fclose(tb.fp);
		tb.fp = 0;
		if (cfset.dat[0].tem[3].value)
		{
			if (!ChDir(cpldata))
			{
				Swin("错误！", "无法进入目录", SWIN_ONE);
				return;
			}
			if (!DeleteFile("mem.tmp")) Swin("错误！", "无法删除*.tmp", SWIN_ONE);
		}
	}
}
//*******************************************************函数检索*******************************************************//
int LoadFun(struct SKFUNTABLE &f)//函数载入
{
	char fp;
	long addrs;

	if (!ChDir(cpldata))
	{
		Swin("错误！", "无法进入目录", SWIN_ONE);
		return(1);
	}
	if (!(fp = fopen(cfset.fun, "r")))
	{
		Swin("错误！", "找不到函数文件", SWIN_ONE);
		return(1);
	}
	fseek(fp, 2, addrs = 0);
	fread(&addrs, 1, 2, fp);
	fseek(fp, addrs, 0);
	fread(&f.size, 1, 1, fp);//读取长度
	if (f.size > SKFUN_L_LEN)
	{
		Swin("错误！", "函数个数太多", SWIN_ONE);
		fclose(fp);
		return(1);
	}
	fread(f.dat, 1, f.size * sizeof(struct SKFUNUNIT), fp);
	fclose(fp);
}

int SeekFun(struct SKFUNTABLE &f, char &name[])//函数检索
{
	char str[SKFUN_N_LEN];
	int low, mid, high, value;

	low = 0;
	high = f.size - 1;
	while (low <= high)
	{
		mid = (low + high) >> 1;
		value = strcmp(f.dat[mid].name, name);
		if (!value)
		{
			return(-1);
		}
		else if (value > 0)
		{
			high = mid - 1;
		}
		else
		{
			low = mid + 1;
		}
	}
	strcpy(str, f.dat[low].name);
	str[strlen(name)] = 0;
	if (!strcmp(str, name)) return(low);
	return(-1);
}

void ShowFun(struct SKFUNTABLE &f, int first, int value, int x, int y)
{
	char i;

	if ((x = x - 37) > 82)
	{
		x = 82;
	}
	else if (x < 9)
	{
		x = 9;
	}
	if (y < 3)
	{
		y = y * 13 + 15;
	}
	else
	{
		y = y * 13 - 31;
	}
	Box(x - 1, y - 1, x + 77, y + 32, 1, 0);
#if WQX == 0
	MyBox(x, y, x + 76, y + 31, 0x14);
#else
	Box(x, y, x + 76, y + 31, 0, 1);
#endif
	for (i = 0; i + first < f.size && i < 2; i++)
	{
		TextOut(x + 5, y + i * 14 + 3, f.dat[i + first].name, 65);
	}
	if (value >= 0) Box(x + 2, y + value * 14 + 2, x + 74, y + value * 14 + 15, 1, 2);
}
//*******************************************************检索编辑*******************************************************//
void ChkReFunType(char n, char &s[])
{
	if ((n = n >> 4) == SK_FUN)
	{
		strcpy(s, " 函数 ");
	}
	else if (n == SK_BLANK || n == SK_SYMBO)
	{
		strcpy(s, "关键字");
	}
	else if (n == SK_CR || n == SK_BAO)
	{
		strcpy(s, " 命令 ");
	}
	else if (n == SK_SEMI)
	{
		strcpy(s, " 语句 ");
	}
	else if (n == SK_POINT)
	{
		strcpy(s, "构造体");
	}
	else
	{
		strcpy(s, "无类型");
	}
}

#if WQX == 0
void _PrintFun(struct SKFUNTABLE &f, int first, int value)/*检索显示*/
{
	struct SKFUNUNIT e;
	char i;
	char s[7];

	Block(6, 28, 108, 75, 0);
	for (i = 0; i < 4 && i + first < f.size; i++)
	{
		memcpy(e, f.dat[first + i], sizeof(struct SKFUNUNIT));
		TextOut(6, i * 12 + 28, e.name, 1);
		ChkReFunType(e.n, s);
		TextOut(73, i * 12 + 28, s, 1);
	}
	Block(6, value * 12 + 28, 108, value * 12 + 39, 2);
}
#else
void _PrintFun(struct SKFUNTABLE &f, int first, int value)/*检索显示*/
{
	struct SKFUNUNIT e;
	char i;
	char s[7];
 
	Block(4, 28, 109, 76, 0);
	for (i = 0; i < 4 && i + first < f.size; i++)
	{
		memcpy(e, f.dat[first + i], sizeof(struct SKFUNUNIT));
		TextOut(4, i * 12 + 28, e.name, 1);
		ChkReFunType(e.n, s);
		TextOut(73, i * 12 + 28, s, 1);
	}
	Block(4, value * 12 + 28, 109, value * 12 + 39, 2);
}
#endif

int seekfun(struct SKFUNTABLE &f, char &name[])//查找检索
{
	char str[SKFUN_N_LEN];
	int low, mid, high, value;

	low = 0;
	high = f.size - 1;

	while(low <= high)
	{
		mid = (low + high) >> 1;
		value = strcmp(f.dat[mid].name, name);
		if (!value)
		{
			return(mid);
		}
		else if (value > 0)
		{
			high = mid - 1;
		}
		else
		{
			low = mid + 1;
		}
	}
	return(low|0x8000);
}

int GetType(char &type)//类型输入
{
	char key, value;
	char s[2];

	for (value = 0;;)
	{
		Swin("输入", NULL, SWIN_COM);
		TextOut(17, 35, "请选择类型：", 1);
#if WQX == 0
		Boxw(39, 52, "函 数");
		Boxw(87, 52, "其 他");
		Block(value * 48 + 40, 53, value * 48 + 71, 64, 2);
#else
		Boxw(36, 52, "函 数");
		Boxw(84, 52, "其 他");
		Block(value * 48 + 37, 53, value * 48 + 72, 64, 2);
#endif
		Refresh();
		key = getchar();
		if (key == DOWN_KEY || key == RIGHT_KEY || key == UP_KEY || key == LEFT_KEY) value = value ^ 1;
		else if (key == CR_KEY)
		{
			if (!value)//函数
			{
LOOP:
				if (!Inputw("请输入参数个数:", s, 2, 24)) continue;
				if (!isdigit(s[0])) goto LOOP;
				type = (s[0] - '0')|(SK_FUN << 4);
			}
			else type = SK_NULL << 4;//其他
			return(1);
		}
		else if (key == ESC_KEY || key == 'q') return(0);
	}
}

int ChkReFunName(int s)//检查名称是否合法
{
	while(isalnum(*s)) s++;
	if (*s) return(1);
}

void LoadReFun(struct SKFUNTABLE &f)//加载检索数据
{
	struct OUTFILE file;

	if (!SelectSrc(file, cpldata, 0xfe)) return;//ref文件
	if (!(file.fp = fopen(file.name, "r")))
	{
		if (datfp)
		{
			fclose(datfp);
			datfp = 0;
		}
		if (!(file.fp = fopen(file.name, "r")))
		{
			Swin("错误！", "无法打开文件", SWIN_ONE);
			goto END;
		}
	}
	fread(f, 1, sizeof(struct SKFUNTABLE), file.fp);
	fclose(file.fp);
END:
	if (!datfp)
	{
		ChDir(cpldata);
		datfp = fopen("compile.dat", "r");
	}
}

void SaveReFun(struct SKFUNTABLE &f)//保存检索数据
{
	char fp;
	char name[20];

START:
 
	if (!Inputw("请输入文件名:", name, 15, 6)) return;
	ChExt(name, "ref");
	if (strlen(name) > 14)
	{
		Swin("警告！", "文件名太长", SWIN_ONE);
		goto START;
	}
	if (ChPath(cpldata))
	{
		Swin("错误！", "无法进入目录", SWIN_ONE);
		goto END;
	}
	if (!(fp = fopen(name, "w")))
	{
		if (datfp)
		{
			fclose(datfp);
			datfp = 0;
		}
		if (!(fp = fopen(name, "w")))
		{
			Swin("错误！", "无法创建文件", SWIN_ONE);
			goto END;
		}
	}
	fwrite(f, 1, sizeof(struct SKFUNTABLE), fp);
	fclose(fp);
END:
	if (!datfp)
	{
		ChDir(cpldata);
		datfp = fopen("compile.dat", "r");
	}
}

int AddSeekFun(struct SKFUNTABLE &f, int sfun, struct SKFUNUNIT &a)
{
	struct SKFUNUNIT e;
	char msg[20];
	int t;

	if (f.size >= SKFUN_L_LEN)
	{
		sprintf(msg, "检索个数已达%d个", SKFUN_L_LEN);
		Swin("提醒！", msg, SWIN_ONE);
	}
	else
	{
		if (sfun)
		{
			e.n = SK_NULL << 4;
			strcpy(e.name, sfun);
		}
		else
		{
			memcpy(e, a, sizeof(struct SKFUNUNIT));
		}
		t = seekfun(f, e.name);
		if (t >= 0)
		{
			Swin("警告！", "存在同名的检索", SWIN_ONE);
		}
		else
		{
			memmove(f.dat[(t = t&0x7fff) + 1], f.dat[t], (f.size - t) * sizeof(struct SKFUNUNIT));
			memcpy(f.dat[t], e, sizeof(struct SKFUNUNIT));
			f.size++;
			return(1);
		}
	}
}

void LookReFun(struct SKFUNTABLE &f)/*检索查看*/
{
	struct SKFUNUNIT e;
	char msg[20];
	char key;
	int first, cur, t;

	for (first = cur = 0;;)
	{
		LookFace("检索");
		_PrintFun(f, first, cur - first);
		Refresh();//界面
		key = getchar();
		if ((key == UP_KEY || key == LEFT_KEY) && cur)
		{
			cur--;
			if (cur < first) first = cur;
		}
		else if ((key == DOWN_KEY || key == RIGHT_KEY) && cur + 1 < f.size)
		{
			cur++;
			if (cur > first + 3) first = cur - 3;
		}
		else if (key == UU_KEY)
		{
			if (first < 4)
			{
				cur = cur - first;
				first = 0;
			}
			else
			{
				first = first - 4;
				cur = cur - 4;
			}
		}
		else if (key == DD_KEY && first + 4 < f.size)
		{
			first = first + 4;
			cur = cur + 4;
			if (cur >= f.size) cur = f.size - 1;
		}
		else if (key == A_KEY || key == F1_KEY)//插入
		{
			Button(112, 16, "添加[A]", BUTTON_DOWN);
PUT_NAME1:
			if (Inputw("请输入检索名:", e.name, SKFUN_N_LEN, 25))
			{
				if (ChkReFunName(e.name)) goto PUT_NAME1;
				if (GetType(&e.n)) AddSeekFun(f, 0, e);
			}
		}
		else if (key == D_KEY || key == F2_KEY)//删除
		{
			Button(112, 32, "删除[D]", BUTTON_DOWN);
			if (!f.size) Swin("警告！", "没有检索可删除", SWIN_ONE);
			else
			{
				if (cfset.dat[2].tem[1].value)
				{
					if (!Swin("删除？", "真的要删除么", SWIN_TWO)) continue;
				}
				f.size--;
				memmove(f.dat[cur], f.dat[cur + 1], (f.size - cur) * sizeof(struct SKFUNUNIT));
				memset(f.dat[f.size], 0, sizeof(struct SKFUNUNIT));
				if (f.size && cur >= f.size)
				{
					cur = f.size - 1;
					if (cur < first) first = cur;
				}
			}
		}
		else if (key == F3_KEY)//查找
		{
			if (!f.size)
			{
				Swin("警告！", "没有检索可查找", SWIN_ONE);
			}
			else
			{
PUT_NAME2:
				if (Inputw("请输入检索名:", e.name, SKFUN_N_LEN, 25))
				{
					if (ChkReFunName(e.name)) goto PUT_NAME2;
					t = seekfun(f, e.name);
					if (t < 0)
					{
						Swin("信息！", "没有找到", SWIN_ONE);
						continue;
					}
					first = cur = t;
				}
			}
		}
		else if (key == 'l')//载入
		{
			Button(112, 48, "载入[L]", BUTTON_DOWN);
			Swin("信息", "请选择加载文件", SWIN_ONE);
			LoadReFun(f);
		}
		else if (key == S_KEY)//保存
		{
			Button(112, 64, "保存[S]", BUTTON_DOWN);
			if (cfset.dat[2].tem[2].value)
			{
				if (!Swin("保存？", "真的要保存么", SWIN_TWO)) continue;
			}
			LookFace("检索");
			TextOut(30, 45, "保存中...", 1);
			Refresh();
			SaveReFun(f);
		}
		else if (key == ESC_KEY || key == 'q') return;
	}
}
//*******************************************************中文输入*******************************************************//
long Getmark()/*获取全角符号*/
{
	char key, j;
	int i;
	char numkey[10], mk[16][18];

	TextOut(1, 64, "符", 0xc2);
	strcpy(numkey, "bnmghjtyu");
	strcpy(mk, "§№☆★○●◎◇◆□■△▲※→←↑↓〓〔〕〈〉《》「」『』．〖〗【】（）［］｛｝＃＆＠＼＾");
	strcpy(mk + 90, "＿￣。，、；：？！…―・ˉˇ¨‘’“”々～‖∶＂＇｀｜〃°′″＄￡￥‰％℃¤￠≈≡≠＝≤≥");
	strcpy(mk + 180, "＜＞≮≯∷±＋－×÷／∫∮∝∞∧∨∑∏∪∩∈∵∴⊥∥∠⌒⊙≌∽√㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩①②③");
	strcpy(mk + 270, "④⑤⑥⑦⑧⑨⑩    ");
	for (i = 0;;)
	{
		TextOut(17, 64, mk[i], 0xc1);
		key = getchar();
		if (key == UP_KEY || key == LEFT_KEY || key == UU_KEY)
		{
			if (i) i--;
		}
		else if (key == DOWN_KEY || key == RIGHT_KEY || key == '0' || key == DD_KEY)
		{
			if (i < 15) i++;
		}
		else if (isalnum(key))
		{
			if (strchr(numkey, key))
				j = strchr(numkey, key) - numkey;
			else
				j = key - '1';
			if (mk[i][j << 1] > ' ') return(&mk[i][j << 1]);
		}
		else if (key == ESC_KEY) return(0);
	}
}

long PY2GB(char &str[])/*查找字库*/
{
	struct PY_UNIT dat;
	int low, mid, high, value;

	if (!str[0]) return(0);
	low = 0;
	high = PY_MAX - 1;
	while(low <= high)
	{
		mid = (low + high) >> 1;
		fseek(datfp, mid * sizeof(struct PY_UNIT) + PY_ADD, 0);
		fread(dat, 1, sizeof(struct PY_UNIT), datfp);
		if (!(value = strcmp(dat.str, str)))
			return(dat.size|(dat.add << 16));
		else if (value > 0)
			high = mid - 1;
		else
			low = mid + 1;
	}
}

long Input(char x, char y, int skey, int con)/*输入中文*/
{
	char str[7], i, buf[19], key, tkey;
	int size, f, c, t;
	long n, a, b;

START:
	TextOut(2, 67, "拼", 65);
	Box(2, 66, 14, 79, 1, 2);
	for (i = size = 0;;)
	{
		for (a = b = 0;;)//光标闪动
		{
			if (!(a  |  (i  &&  y == 5))) Box(x, y * 13 + 2, x + 1, y * 13 + 13, 1, 2);
			if ((a++) == (cfset.dat[3].tem[1].value << 5)) a = 0;
			tkey = key;
			key = CheckKey(128);
			Inkey();
			if (*skey == key  |  !key)
			{
				*skey = key;
				continue;
			}
			if (key == tkey)
			{
				if (++b  >=  cfset.dat[3].tem[0].value | *con)
				{
					*con=1;
					break;
				}
				Delay(14);
				a = 1;
			}
			else
			{
				*con = 0;
				break;
			}
		}
		if (key == '0')//全角符号
		{
			Box(x, y * 13 + 2, x + 1, y * 13 + 13, 1, 1);
			if (a = Getmark()) return(a);
			*skey = CheckKey(128);
		}
		else if (!(i | islower(key))) return(key);//命令
		else if (key == F2_KEY | key == UP_KEY)
		{
			if (i) i--;
			size = 0;
		}
		else if (key == LEFT_KEY)
		{
			if (c)
			{
				if ((--c) < f) f = c;
			}
			else
			{
				if (i) i--;
				size = 0;
			}
		}
		else if (key == DOWN_KEY | key == RIGHT_KEY)
		{
			if (c + 1 < size)
			{
				if ((++c) > f + 8) f = c - 8;
			}
		}
		else if (key == UU_KEY)
		{
			if (f < 9)
			{
				c = c - f;
				f = 0;
			}
			else
			{
				f = f - 9;
				c = c - 9;
			}
		}
		else if (key == DD_KEY)
		{
			if (f + 9 < size)
			{
				f = f + 9;
				c = c + 9;
				if (c >= size) c = size - 1;
			}
		}
		else if (key == F3_KEY) f = c = 0;
		else if (key == F4_KEY) f = c = size - 1;
		else if (key == CR_KEY)
		{
			if (size) return(buf + ((c - f) << 1));
		}
		else if (key == SHIFT_KEY)	return(SHIFT_KEY);
		else if (key == ESC_KEY)	return(ESC_KEY);
		else if (islower(key))
		{
			if (i < 6)
			{
				str[i++] = key;
				size = 0;
			}
		}
		Box(15, 66, 159, 79, 1, 0);
		str[i] = 0;
		TextOut(15, 67, str, 65);
		if (!size)
		{
			if ((n = PY2GB(str)) == -1) n = 0;
			size = n;
			t = n >> 16;
			f = c = 0;
		}
		if (n)
		{
			if (size >= f + 9) tkey = 18;
			else tkey = (size - f)<<1;
			fseek(datfp, t + (f << 1) + PY_ADD - 14740, 0);
			fread(buf, 1, tkey, datfp);
			buf[tkey] = 0;
			TextOut(52, 67, buf, 65);
			Box((c - f) * 12 + 52, 66, (c - f) * 12 + 64, 79, 1, 2);
		}
		if (!i)
		{
			Refresh();
			goto START;
		}
	}
}
//*******************************************************文本编辑*******************************************************//
void EMsg()
{
	Refresh();
#if WQX == 0
	MyBox(44, 26, 115, 49, 0x12);
#else
	Box(43, 25, 116, 50, 1, 0);
	Box(46, 28, 113, 47, 0, 1);
	Box(44, 26, 115, 49, 0, 1);
#endif
	TextOut(48, 30, "操作完成", 193);
	Delay(500);
	Refresh();
}

long atoi(char &str[])
{
	long num;
	char i;

	for (i = num = 0;; i++)
	{
		if (isdigit(str[i]))
		{
			num = num * 10 + str[i] - '0';
		}
		else
		{
			break;
		}
	}
	return(num);
}

int Ismid(int cursor, int end)/*判断字节是否是右半字节*/
{
	int i;

	for (i = cursor; *i >= 160 && i >= end; i--);
	return(!((cursor - i)&1));
}

int BakSch(int b, char &buf[])
{
	int i, tmp;

	if ((tmp = strchr(buf, 13)) > b | !tmp) return(buf);
	for (i = b; *i != 13; i--);
	return(i + 2);
}

int StrSeek(char &buf[], int cursor, char &str[])/*从cursor开始搜索str,找不到就从全文本头部buf开始搜,再搜不到返回0*/
{
	int tmp, a;

SEARCH1:
	if (tmp = strstr(cursor, str))
	{
		if (*tmp >= 160)
		{
			if (Ismid(tmp, buf))
			{
				cursor = tmp + 1;
				goto SEARCH1;
			}
		}
		return(tmp);
	}
	else
	{
		cursor = buf;
SEARCH2:
		if (a = strstr(cursor, str))
		{
			if (*a >= 160)
			{
				if (Ismid(a, buf))
				{
					cursor = tmp + 1;
					goto SEARCH2;
				}
			}
			return(a);
		}
		else
		{
			return(0);
		}
	}
}

int GetSeekFunName(int cursor, int buf, int end, int a, int b, char &sfun[])
{
	int c, d;

	if (isalpha(*(cursor - 1)))
	{
		for (d = cursor - 1; d >= buf && d + 16 > cursor; d--)
		{
			if (!isalpha(*d))
			{
				d++;
				break;
			}
		}
		if (d < buf)//定位函数或关键字的头
		{
			c = buf;
		}
		else
		{
			c = d;
		}
		for (d = cursor; d < end && d < cursor + 16; d++)//定位函数或关键字的尾
		{
			if (!isalpha(*d)) break;
		}
		if (d <= c + 11 && d != c)//查询
		{
			memcpy(sfun, c, d - c);
			sfun[d - c] = 0;
			memcpy(a, &c, 2);
			memcpy(b, &d, 2);
			return(1);
		}
	}
}

int Edit(char &buf[], struct TXT_BLOCK &tb, char &cl[], struct SKFUNTABLE &f)
{
	long filelen, filestart;//总长度 当前起始点
//---------------------------------------------------------
	char show[26], str[MAC_N_LEN], s[24];//显示缓冲 查找字符串缓冲 临时字符串缓冲
	char sfun[SKFUN_N_LEN];//检索缓冲
	int j, k, c, d;//检索指针 临时检索指针 函数起始 函数结尾
	struct TEXT t[7];//行信息(head指针，指向屏幕上每行的行首地址;size:每行长度)
	int start, cursor, end, size;//分别指向复制起点(值-1时为无设定)，光标处，文本尾和剪贴板大小
	int sx;//屏幕右滚偏移量
	char new;//屏幕指针移动标记(0:不移动,1:令屏幕指针t[0].head指向光标所在行的行首,2:t[0].head下移一行)
	char move;//屏幕是否有滚动(0:无,1:有)
	int x, y;//光标
	char key, tkey, skey, con;//按键值 缓冲按键值 锁定键 锁定连续响应键
	char min, eng, suc;//是否小写 是否输入英文 是否成功载入检索
	char numkey[11], signkey[18], letkey[18], symkey[15], chakey[15];//按键对应表
	char cur, i;
	long a, b;//临时变量
//--------------------------------------------------------初始化--------------------------------------------------------//

	memset(&filelen, 0, &b - &filelen);
	strcpy(numkey, "0bnmghjtyu");
	strcpy(signkey, "+-*/;'\"=()[],<>{}");
	strcpy(letkey, "qwerasdfzxcviopkl");
	strcpy(symkey, "\\%:|~?!&#_`^$@");
	strcpy(chakey, "bnmghjtyu.    ");
	chakey[11] = F1_KEY;
	chakey[12] = F2_KEY;
	chakey[13] = F3_KEY;
	min = eng = 1;
	start = j = -1;
//---------------------------------------------------------选择---------------------------------------------------------//
	if (!out.name[0])
	{
		if (!(i = SubMenu("空的程序简单程序经典程序演示程序", 4, 50, 16))) return(1);
	}
	Swin("信息", NULL, SWIN_COM);//信息
	//TextOut(43, 46, "载入中...", 128);
	textout(43, 46, "载入中...", 128);
	Refresh();
//---------------------------------------------------------载入---------------------------------------------------------//
	filelen = TextLoad(buf, tb);//载入文本
	if (filelen < 0) return(1);
	t[0].head = cursor = buf;
	end = buf + strlen(buf);
	if (!cfset.dat[3].tem[3].value) suc = LoadFun(f) ^ 1;//载入检索
	if (!datfp)//打开字库
	{
		ChDir(cpldata);
		if (!(datfp = fopen("compile.dat", "r"))) Swin("错误！", "无法打开字库", SWIN_ONE);
	}
	if (i > 4 && datfp)//载入事例程序
	{
		DataRead(&filelen, 2, i + 16 - 5);
		fread(buf, 1, filelen, datfp);
		end = buf + filelen;
	}
//--------------------------------------------------------主程序--------------------------------------------------------//
START:
	skey = CheckKey(128);//终止响应键
START1:
	if (cursor < t[0].head | new == 1)
	{
		t[0].head = BakSch(cursor - 1, buf);
	}
	else if (new == 2)
	{
		t[0].head = t[1].head;//确定首行地址
	}
	for (cur = 0; cur < 6; cur++)//确定行地址
	{
		if (cursor >= t[cur].head) y = cur;//确定光标所在行数
		if (a = strchr(t[cur].head, 13))
		{
			t[cur + 1].head = a + 2;
			t[cur].size = t[cur + 1].head - t[cur].head - 2;
		}
		else
		{
			t[cur].size = strlen(t[cur].head);
			t[++cur].head = end;
			break;
		}
	}
	if (cursor - t[y].head > sx + 24)
	{
		sx = cursor - t[y].head - 24;
	}
	else if (cursor - t[y].head < sx)//滚动调整
	{
		sx = cursor - t[y].head;
	}
//---------------------------------------------------------显示---------------------------------------------------------//
	if (move)
	{
		i = y;
	}
	else
	{
		i = 0;
#if WQX == 0
		Block(1, 0, 159, 79, 0);
#else
		ClearScreen();
#endif
	}
	while (i < cur)
	{
		if (sx > t[i].size)
		{
			show[0] = 0;
		}
		else
		{
			memcpy(show, t[i].head + sx, 25);
			if (a = strchr(show, 13))
			{
				*a = 31;
				*(a + 1) = 0;
			}
		}
		if (show[0] >= 160)//汉语调整(头)
		{
			if (Ismid(t[i].head + sx, buf)) show[0] = '_';
		}
		if (strlen(show) == 25 && show[24] >= 160)//汉语调整(尾)
		{
			if (!Ismid(show + 24, show)) show[24] = '_';
		}
		TextOut(8, (i++) * 13 + 2, show, 1);
		if (move) break;
	}
	if (eng&2)
	{
		TextOut(1, 1, "z", 2);
	}
	else if (eng)
	{
		TextOut(1, 1, "E", 2);
	}
	else
	{
		TextOut(1, 1, "n", 2);
	}
	if (min)
	{
		TextOut(1, 14, "a", 2);
	}
	else
	{
		TextOut(1, 14, "A", 2);
	}
	Block(1, 27, 6, 52, 0);
	if (size) TextOut(1, 27, "c", 2);
	if (start >= 0) TextOut(1, 40, ".", 2);
	if (sx) TextOut(1, 68, "<", 2);
	Line(7, 1, 7, 79, 65);
	if (filelen)//进度
	{
		Line(7, a = (filestart + cursor - buf) * 79 / filelen, 7, a + 3, 64);
	}
	Refresh();
	x = (cursor - t[y].head - sx) * 6 + 8;
	if ((k = j) >= 0) ShowFun(f, j, j = -1, x, y);//函数检索
	a = b = new = move = 0;
//-------------------------------------------------------按键响应-------------------------------------------------------//
	for (;;)
	{
		if (eng&2)//中文输入
		{
			a = Input(x, y, &skey, &con);
			if (a < 0xff)
			{
				key = a;
				break;
			}
			if (buf + TXT_SIZE < end + 2)//////////////////////////////////////////////////////error
			{
				Swin("警告！", "文本已到上限", SWIN_ONE);
				goto START;
			}
			memmove(cursor + 2, cursor, end - cursor);
			memcpy(cursor, a, 2);//写入汉字
			cursor = cursor + 2;
			end = end + 2;
			filelen = filelen + 2;//增加
			tb.chg = 1;//内容已改变
			goto START;
		}
		if (!a) Box(x, y * 13 + 2, x + 1, y * 13 + 13, 1, 2);
		if ((a++) == cfset.dat[3].tem[1].value << 4) a = 0;
		tkey = key;
		key = CheckKey(128);
		Inkey();
		if (skey == key | !key)
		{
			skey=key;
			continue;
		}
		if (key == tkey)
		{
			if (++b >= cfset.dat[3].tem[0].value | con)
			{
				con = 1;
				break;
			}
			Delay(14);
			a = 1;
		}
		else
		{
			con = 0;
			break;
		}
	}
#if DEBUG == 1
 //if (con<10)key=CR_KEY;else if (con<100)key=rand()%26+'A';else key=rand()%26+'a';con=con+rand()%10;tkey=0;
 //key=DOWN_KEY;if (s[0])key=UP_KEY;
	if (s[0] == 255)
	{
		s[0] = 0;
		Box(x, y * 13 + 2, x + 1, y * 13 + 13, 1, 2);
		Delay(1000);
	}
	if (key == '0')
	{
		fclose(tb.fp);
		fclose(in.fp);
		i = fopen("/tb.bin", "w");
		fwrite(tb, 1, sizeof(struct TXT_BLOCK), i);
		fclose(i);
		exit(0);
	}
	if (key == ' ')
	{
		ShowTxtLink(tb);
		goto START;
	}
#endif
	if (key == UP_KEY)
	{
		if (t[0].head == buf && !y)
		{
			if (tb.p[tb.h].head == 254) goto START;
			a = TextLink(buf, tb, TXT_LOD_H);
			if (a < 0) goto ERRTXT;//载入文本(上)
			cursor = cursor + a;
			end = buf + strlen(buf);
			filestart = filestart - a;
			for (cur = 0; cur < 7; cur++)//调整
			{
				t[cur].head = t[cur].head + a;
			}
#if DEBUG == 1
			Delay(1000);
			s[0] = 255;
#endif
		}
		if ((a = cursor - t[y].head) > t[y].head - (b = BakSch(t[y].head - 3, buf)) - 2)
		{
			cursor = t[y].head - 2;
		}
		else
		{
			cursor = a + b;
		}
		goto HAN_TZ;
	}
	if (key == DOWN_KEY)
	{
		if (t[++y].head >= end)
		{
			if (tb.p[tb.n].next == 255) goto START;
			a = TextLink(buf, tb, TXT_LOD_N);
			if (a < 0) goto ERRTXT;//载入文本(下)
			cursor = cursor - a;
			end = buf + strlen(buf);
			filestart = filestart + a;
			for (cur = 0; cur < 7; cur++)
			{
				t[cur].head = t[cur].head - a;//调整
			}
			if (t[0].head < buf)//溢出调整
			{
				t[0].head = buf;
				if (t[1].head < buf) t[1].head = buf;
			}
#if DEBUG == 1
			Delay(1000);
			s[0] = 255;
#endif
		}
		if (y > 5) new = 2;
		if (a = strchr(t[y].head, 13))
		{
			b = a - t[y].head;
		}
		else
		{
			b = strlen(t[y].head);
		}
		if (cursor - t[y - 1].head > b)
		{
			cursor = t[y].head + b;
		}
		else
		{
			cursor = t[y].head + cursor - t[y - 1].head;
		}
HAN_TZ:
		if (*cursor >= 160)
		{
			if (Ismid(cursor, buf)) cursor--;//防止中文错位
		}
		goto START1;
	}
	if (key == LEFT_KEY)
	{
		if (cursor <= buf)
		{
			if (tb.p[tb.h].head == 254) goto START;
			a = TextLink(buf, tb, TXT_LOD_H);
			if (a < 0) goto ERRTXT;//载入文本(上)
			cursor = cursor + a;
			end = buf + strlen(buf);
			filestart = filestart - a;
			t[0].head = t[0].head + a;//调整
#if DEBUG == 1
			Delay(1000);
			s[0] = 255;
#endif
		}
		if (*--cursor >= 160 | *cursor == 10) cursor--;
		goto START1;
	}
	if (key == RIGHT_KEY)
	{
		if (cursor + 1 >= end)
		{
			if (tb.p[tb.n].next == 255)
			{
				cursor = end;
				goto START;
			}
			a = TextLink(buf, tb, TXT_LOD_N);//载入文本(下)
			if (a < 0) goto ERRTXT;
			cursor = cursor - a;
			end = buf + strlen(buf);
			filestart = filestart + a;
			for (cur = 0; cur < 7; cur++)
			{
				t[cur].head = t[cur].head - a;//调整
			}
			if (t[0].head < buf)//溢出调整
			{
				t[0].head = buf;
				if (t[1].head < buf) t[1].head = buf;
			}
#if DEBUG == 1
			Delay(1000);
			s[0] = 255;
#endif
		}
		if (*cursor < 160)
		{
			if (*++cursor == 10)
			{
				cursor++;
				if (y == 5) new = 2;
			}
		}
		else
		{
			cursor = cursor + 2;
		}
		goto START1;
	}
	if (key == CR_KEY)
	{
		a = cursor;
		b = t[y].head;
		while (--a >= b)
		{
			if (!isspace(*a))//当该行不空
			{
				for (b = t[y].head; isspace(*b) && b < cursor; b++);//计算该行起始有几个空白符
				for (j = cursor; j < end; j++)//计算光标起始有几个空白符
				{
					if (!isspace(*j) | *j == 13)
					{
						if (*j == '}')
						{
							memmove(cursor, j, end - j);
							memset(end = end - (j = j - cursor), 0, j);
							filelen = filelen - j;//减少
							goto SUB_END;
						}
						break;
					}
				}
				if (*a == '{') b++;
SUB_END:
				j = -1;
				goto CR_START;
			}
		}
		b = cursor;//空格行
CR_START:
		if ((b = b - t[y].head + 2) + end > buf + TXT_SIZE)//溢出
		{
			if (cursor > buf + TXT_B_SIZE)
			{
				a = TextLink(buf, tb, TXT_SAV_H);
				if (a < 0)//保存文本(上)
				{
ERRTXT://错误分析
					if (a == -1)
					{
						Swin("错误！", "无法保存数据", SWIN_ONE);
					}
					else if (a == -2)
					{
						Swin("警告！", "文本已到上限", SWIN_ONE);
					}
					else if (a == -3)
					{
						Swin("错误！", "其中一行太长", SWIN_ONE);
					}
					else
					{
						Swin("错误！", "文件读写出错", SWIN_ONE);
					}
					goto START;
				}
				filestart = filestart + a;
				cursor = cursor - a;
				for (cur = 0; cur < 7; cur++)//调整
				{
					t[cur].head = t[cur].head - a;
				}
				if (t[0].head < buf)//溢出调整
				{
					t[0].head = buf;
					if (t[1].head < buf) t[1].head = buf;
				}
			}
			else//保存文本(下)
			{
				a = TextLink(buf, tb, TXT_SAV_N);
				if (a < 0) goto ERRTXT;
			}
			end = buf + strlen(buf);
#if DEBUG == 1
			Delay(1000);
			s[0] = 255;
#endif
		}
		memmove(cursor + b, cursor, end - cursor);
		memset(cursor, ' ', b);
		*cursor = 13;
		*(cursor + 1) = 10;//填充空格符(自动缩进)
		cursor = cursor + b;
		end = end + b;
		filelen = filelen + b;
		if (y == 5) new = 2;//光标在屏幕底时下移一行
		tb.chg = 1;//内容已改变
		goto START1;
	}
	if (key == F2_KEY)//退格
	{
		if (cursor <= buf)
		{
			if (tb.p[tb.h].head == 254) goto START;
			a = TextLink(buf, tb, TXT_LOD_H);//载入文本(上)
			if (a < 0) goto ERRTXT;
			cursor = cursor + a;
			end = buf + strlen(buf);
			filestart = filestart - a;
			t[0].head = t[0].head + a;//调整
#if DEBUG == 1
			Delay(1000);
			s[0] = 255;
#endif
		}
		if (*(cursor - 1) == 10 | *(cursor - 1) >= 160)
		{
			b = 2;
		}
		else
		{
			b = 1;
		}
		memmove(cursor - b, cursor, end - cursor);//遇中文或换行符时退两格
		cursor = cursor - b;
		memset(end = end - b, 0, b);
		filelen = filelen - b;//减少
		tb.chg = 1;//内容已改变
		goto SEEKFUN;
	}
	if (isprint(i = key))//插入字符
	{
		if (buf + TXT_SIZE < end + 60)//当前有保存操作(溢出)
		{
			if (cursor > buf + TXT_B_SIZE)
			{
				a = TextLink(buf, tb, TXT_SAV_H);
				if (a < 0) goto ERRTXT;//保存文本(上)
				filestart = filestart + a;
				cursor = cursor - a;
				for (cur = 0; cur < 7; cur++)//调整
				{
					t[cur].head = t[cur].head - a;
				}
				if (t[0].head < buf) t[0].head = buf;
			}
			else//保存文本(下)
			{
				a = TextLink(buf, tb, TXT_SAV_N);
				if (a < 0) goto ERRTXT;
			}
			end = buf + strlen(buf);
#if DEBUG == 1
			Delay(1000);
			s[0] = 255;
#endif
		}
		else
		{
			a=0;//当前没有保存操作
		}
		if (!eng)//数字状态
		{
			if (b = strchr(numkey, i))//数字
			{
				i = b - numkey + '0';
			}
			else if (b = strchr(letkey, i))//符号
			{
				goto SIGN_INSERT;
			}
		}
		else//英文状态
		{
#if WQX != 0
			if (i == '0')//符号表
#else
			0;if (i == '0' || i == '-')
#endif
			{
				Box(5, 13, 155, 79, 1, 0);
				Box(6, 14, 154, 78, 0, 1);
				TextOut(7, 16, "请选择符号: F1-F3: ^ $ @", 65);
				TextOut(7, 28, "字母键:↓空格:` 小数点:_", 65);
				TextOut(7, 40, " + - * / !   & # , < >", 65);
				TextOut(7, 54, " ; ' \" = |   ~ ? { }", 65);
				TextOut(7, 66, " ( ) [ ] \\   % :", 65);
				i = getchar();
				if (b = strchr(letkey, i))
				{
SIGN_INSERT:
					i = signkey[b - letkey];
					if (i == '}')//遇到}自动缩进
					{
						j = 1;
						b = cursor;
						while(--b >= buf)//寻找配对的大括号
						{
							if (*b == '}') j++;
							else if (*b == '{')
							{
								if (!--j)
								{
									for (j = b; b > buf;)
									{
										if (*(--b) == 10)
										{
											b++;
											break;
										}
										if (!isspace(*b)) j = b;
									}
									j = j - b;//计算有几列(j)
									if (cursor - t[y].head > j)//减少空格
									{
										j = t[y].head + j;
										for (b = cursor; isspace(*--cursor);)
										{
											if (cursor <= j)
											{
												cursor--;
												break;
											}
										}
										cursor++;//有几个空白符
										memmove(cursor, b, end - b);
										memset(end = end - b + cursor, 0, b - cursor);
										filelen = filelen - b + cursor;//减少
										Block(8, y * 13 + 2, 159, y * 13 + 13, 0);//清除该行屏幕
									}
									else if (cursor - t[y].head < j)//补充空格
									{
										memmove(cursor + j, cursor, end - cursor);
										memset(cursor, ' ', j);//填充空格符(自动缩进)
										cursor = cursor + j;
										end = end + j;
										filelen = filelen + j;//增加
									}
									break;
								}
							}
						}
						j = -1;//因为前面借用了j, 所以要初始化
					}
				}
				else if (b = strchr(chakey, i))
				{
					i = symkey[b - chakey];
				}
				else if (!isprint(i))
				{
					goto START;
				}
			}
			else if (!min)
			{
				i = toupper(i);
			}
		}
		memmove(cursor + 1, cursor, end - cursor);
		*cursor++ = i;
		end++;
		filelen++;//写入
		tb.chg = 1;//内容已改变
		if (!a)//光标在屏幕最右端时屏幕右滚
		{
			if (cursor - t[y].head - sx == 25)
			{
				sx = cursor - t[y].head - 17;
			}
			else
			{
				move = 1;
			}
		}
SEEKFUN:
		if (suc && cursor > buf)//函数或关键字检索
		{
			if (GetSeekFunName(cursor, buf, end, &c, &d, sfun)) j = SeekFun(f, sfun);
		}
#if WQX != 0
		if (key == '0' && eng) goto START;
#else
		0;if ((key == '0' || key == '-') && eng) goto START;
#endif
		goto START1;
	}
	if (key == UU_KEY)
	{
		if (sx) sx--;
		goto START1;
	}
	if (key == DD_KEY)
	{
		sx++;
		goto START1;
	}
	if (i == HELP_KEY)
	{
		if (k >= 0)//检索
		{
			for (a = k;;)
			{
				ShowFun(f, k, a - k, x, y);
				i = getchar();
				if (i == UP_KEY || i == LEFT_KEY)
				{
					if (a)
					{
						a--;
						if (a < k) k = a;
					}
				}
				else if (i == DOWN_KEY || i == RIGHT_KEY)
				{
					if (a + 1 < f.size)
					{
						a++;
						if (a > k + 1) k = a - 1;
					}
				}
				else if (i == UU_KEY)
				{
					if (k < 2)
					{
						a = a - k;
						k = 0;
					}
					else
					{
						k = k - 2;
						a = a - 2;
					}
				}
				else if (i == DD_KEY)
				{
					if (k + 2 < f.size)
					{
						k = k + 2;
						a = a + 2;
						if (a >= f.size) a = f.size - 1;
					}
				}
				else if (i == CR_KEY || i == HELP_KEY)
				{
					k = f.dat[a].n&0xf;
					b = f.dat[a].n >> 4;
					s[0] = i = 0;//参数个数 类型
					if (b == SK_FUN | b == SK_SYMBO)//函数 语句
					{
						for (j = cursor; j < end; j++)
						{
							if (!isspace(*j) | *j == 13)
							{
								if (*j != '(') break;
								goto ADD_SKFUN;
							}
						}
						b = b * 3 + 41;
						for (s[i = 0] = '('; ++i < k; s[i] = b);//添加参数表
						s[i] = 0;
						strcat(s, ")");
						if (b == ',')
						{
							if (*j != ')' && *j != ']' && *j != ';') strcat(s, ";");
						}
						i = 0;
						if (k | b == ';') i = strlen(s) - 1;//移动光标
					}
					else if (b == SK_BLANK)//空格
					{
						if (*cursor != ' ' && *cursor != 9) strcpy(s, " ");
					}
					else if (b == SK_SEMI || b == SK_POINT)//分号 点号
					{
						for (j = cursor; j < end; j++)
						{
							if (!isspace(*j) | *j == 13)
							{
								if (*j != 98 - b * 13) break;
								goto ADD_SKFUN;
							}
						}
						s[0] = 98 - b * 13;
						s[1] = 0;
					}
					else if (b == SK_CR)
					{
						s[0] = 13;
						s[1] = 10;
						s[2] = 0;
					}
					else if (b == SK_BAO)
					{
						for (j = cursor; j < end; j++)
						{
							if (!isspace(*j) | *j == 13)
							{
								if (*j != '<' && *j != '"') break;
								goto ADD_SKFUN;
							}
						}
						strcpy(s, "<>");
						s[2] = 0;//插入
						i = 1;//移动光标
					}
ADD_SKFUN:
					memmove(c + (b = strlen(f.dat[a].name) + c - d + strlen(s)), c, end - c);//移动
					memcpy(c, f.dat[a].name, strlen(f.dat[a].name));
					memcpy(c + strlen(f.dat[a].name), s, strlen(s));//插入
					cursor = d + b - i;
					end = end + b;
					filelen = filelen + b;//增加
					j = -1;
					tb.chg = 1;//内容已改变
					break;
				}
				else if (i == ESC_KEY || i == 'q')break;
			}
			goto START;
		}
#if WQX == 0
		Box(10, 5, 152, 76, 1, 0);
		MyBox(10, 5, 152, 76, 0x12);
		MyLine(12, 21, 149, 21, 0);
		SetBgColor(3);
#else
		Box(10, 5, 151, 75, 1, 0);Box(10, 5, 151, 75, 0, 1);
		Line(152, 6, 152, 76, 1);
		Line(11, 76, 152, 76, 1);
		Line(12, 21, 149, 21, 1);
#endif
		//TextOut(56, 7, "功能选择", 65);
		textout(54, 7, "功能选择", 65);
		TextOut(12, 23, "F3:字串续查 F4:编辑检索", 65);
		TextOut(18, 36, ".:设置起点 Z:清空缓存", 65);
		TextOut(21, 49, "C:复制 X:剪切 V:粘贴", 65);
		TextOut(26, 62, "D:删除 F1:插入变量", 65);
		i = getchar();
		if (i == F3_KEY)
		{
			if (str[0]) goto SEARCH1;
			goto SEARCH2;
		}
		else if (i == 'c' | i == 'x')
		{
			if (start < 0) goto NOSTART;
			if ((size = abs(cursor - start)) > CLI_SIZE)
			{
				size = 0;
				Swin("警告！", "复制内容太多", SWIN_ONE);
				goto START;
			}
			if (cursor < start)
				memcpy(cl, cursor, size);
			else
				memcpy(cl, start, size);
			if (i == 'x') goto DELTXT;
			EMsg();
		}
		else if (i == 'v')
		{
			if (!size) goto START;
			if (size + end > buf + TXT_SIZE)
			{
				Swin("警告！", "文本已到上限", SWIN_ONE);
				goto START;
			}
			memmove(cursor + size, cursor, end - cursor);
			memcpy(cursor, cl, size);
			cursor = cursor + size;
			end = end + size;
			filelen = filelen + size;//光标移动
		}
		else if (i == 'd')
		{
			if (start < 0)
			{
NOSTART:
				Swin("警告！", "没有设置起点", SWIN_ONE);
			}
			else
			{
DELTXT:
				if (cursor > start)
				{
					a = start;
					start = cursor;
					cursor = a;
				}
				memmove(cursor, start, end - start);
				memset(end = end - (a = start - cursor), 0, a);
				filelen = filelen - a;
				start = -1;
			}
		}
		else if (i == F1_KEY)
		{
			if (suc && cursor > buf)//函数或关键字检索
			{
				if (GetSeekFunName(cursor, buf, end, &c, &d, sfun))
				{
					if (AddSeekFun(f, sfun, 0)) EMsg();
				}
			}
		}
		else if (i == 'z')
		{
			size = 0;
			EMsg();
		}
		else if (i == '.')
		{
			start = cursor;
			EMsg();
		}
		else if (i == F4_KEY) LookReFun(f);
		goto START;
	}
	if (key == SHIFT_KEY)
	{
		if (eng&2)
		{
			eng = eng&1;
		}
		else
		{
			eng = eng ^ 1;
		}
		goto START;
	}
	if (key == CAPS_KEY)
	{
		j = k;
		min = min ^ 1;
		goto START;
	}
	if (key == F1_KEY)
	{
		j = k;
		if (datfp) eng = eng ^ 2;
		goto START;
	}
	if (key == F3_KEY)
	{
SEARCH2:
		if (!Inputw("请输入字符串:", str, MAC_N_LEN, 5)) goto START;
SEARCH1:
		if (a = StrSeek(buf, cursor + 1, str))
		{
			cursor = a;
			new = 1;
		}
		else
		{
			Swin("信息", "没有找到", SWIN_ONE);
		}
		goto START;
	}
	if (key == F4_KEY)
	{
		sprintf(s, "大小:%d 当前:%d", end - buf, cursor - buf);

#if WQX == 0
		Block(14, 0, 142, 16, 0);
		MyBox((i = 77 - strlen(s) * 3) - 2, 0, strlen(s) * 3 + 80, 15, 0);
		TextOut(i, 2, s, 1);
#else
		Block(14, 0, 142, 16, 0);
		Rectangle((i = 77 - strlen(s) * 3) - 2, 1, strlen(s) * 3 + 80, 16, 1);
		TextOut(i, 3, s, 1);
#endif

GETNUM:
		if (!Inputw("跳转到(Dec):", s, 5, 0)) goto START;
		a = atoi(s) + buf;
		if (a > end) goto GETNUM;
		if (*a == 10) a--;
		if (*a >= 160)
		{
			if (Ismid(a, buf)) a--;
		}
		cursor = a;
		new = 1;
		goto START;
	}
	if (key == ESC_KEY)
	{
		if (!(cur = SubMenu("编译代码保存文件另存为..结束编辑", 4, 50, 12))) goto START;
		if (cur == 7)//结束编辑
		{
			if (tb.chg)
			{
				if (Swin("文字已改变", "是否保存？", SWIN_TWO)) goto SAVETXT;
			}
			if (in.fp)
			{
				fclose(in.fp);
				in.fp = 0;
			}
			Deltmp(tb);
			return(1);
SAVETXT:
		}
		if (!out.name[0] | cur == 6)
		{
			if (!Inputw("请输入文件名:", s, 11, 14)) goto START;
			ChExt(s, "txt");
			strcpy(out.name, s);//添加后缀名
			if (!out.path[0]) strcpy(out.path, txtdata);
		}
		Swin("信息", NULL, SWIN_COM);
		//TextOut(43, 46, "保存中...", 128);
		textout(43, 46, "保存中...", 128);
		Refresh();
		if (TextSave(buf, tb, filelen + 24)) goto START;//保存数据
		if (cur == 4 || cur == 7)//退出,编译代码
		{
			Deltmp(tb);
			return(cur - 4);
		}
	}
	goto START;
}
//*****************************************************资源管理系统*****************************************************//
int SRC_Op(struct SRCTABLE &src, struct SRCUNIT &e, long id, int cmd)/*资源索引表操作*/
{
	int size, low, mid, high;
	long value;

	memcpy(&size, src.size, 2);
	if (cmd == TABLE_INS || cmd == TABLE_SEK)
	{
		low = 0;
		high = size - 1;
		memcpy(&id, e.id, 4);
		while (low <= high)
		{
			mid = (low + high) >> 1;
			memcpy(&value, src.dat[mid].id, 4);
			if (value == id)
			{
				if (cmd == TABLE_SEK)
				{
					memcpy(e.add, src.dat[mid].add, 4);
					return(mid);
				}
				return(-1);
			}
			else if (value > id)
			{
				high = mid - 1;
			}
			else
			{
				low = mid + 1;
			}
		}   
		if (cmd == TABLE_SEK) return(-1);
		memmove(src.dat[low + 1], src.dat[low], (size - low) * sizeof(struct SRCUNIT));//插入
		memcpy(src.dat[low], e, sizeof(struct SRCUNIT));
		size++;
	}
	else if (cmd == TABLE_DEL)
	{
		size--;
		memmove(src.dat[id], src.dat[id + 1], (size - id) * sizeof(struct SRCUNIT));
		memset(src.dat[size], 0, sizeof(struct SRCUNIT));
	}
	else if (cmd == 0)
	{
		memset(src, size = 0, sizeof(struct SRCTABLE));
	}
	memcpy(src.size, &size, 2);
}

int LoadSrcFile(struct SRCTABLE &src)//载入资源文件
{
	char fp;
	int size;
	char buf[256];

	if (!(fp = fopen(out.name, "r")))
	{
		Swin("错误！", "无法打开文件", SWIN_ONE);
		return(1);
	}
	fread(buf, 1, 3, fp);
	buf[3] = 0;
	if (strcmp(buf, "yan"))
	{
		fclose(fp);
		memset(out.name, 0, 16);
		Swin("错误！", "文件类型错误", SWIN_ONE);
		return(1);
	}
	if (!out.fp)
	{
		if (ChPath(cpldata))
		{
			Swin("错误！", "无法进入目录", SWIN_ONE);
			return(1);
		}
		if (!(out.fp = fopen("mem.tmp", "w+")))
		{
			Swin("错误！", "无法创建文件", SWIN_ONE);
			return(1);
		}
	}
	Swin("信息", NULL, SWIN_COM);
	//TextOut(43, 46, "载入中...", 128);
	textout(43, 46, "载入中...", 128);
	Refresh();
	fread(&size, 1, 2, fp);
	fseek(fp, 3, 0);
	SRC_Op(src, 0, 0, 0);
	fread(src, 1, size * sizeof(struct SRCUNIT) + 2, fp);
	rewind(out.fp);
	while (!feof(fp))
	{
		size = fread(buf, 1, 256, fp);
		fwrite(buf, 1, size, out.fp);
	}
	fclose(fp);
}

int SaveSrcFile(struct SRCTABLE &src)//保存资源文件
{
	char fp;
	int size, i, len, tsize;
	long add;
	char buf[256];

	ChDir(out.path);
	if (fp = fopen(out.name, "r"))
	{
		fclose(fp);
		if (!Swin("存在同名文件", "是否覆盖？", SWIN_TWO)) return(1);
	}
	if (!(fp = fopen(out.name, "w")))//创建保存文件
	{
		Swin("错误！", "无法创建文件", SWIN_ONE);
		return(1);
	}
 
	Swin("信息", NULL, SWIN_COM);
	//TextOut(43, 46, "保存中...", 128);
	textout(43, 46, "保存中...", 128);
	Refresh();
	fwrite("yan", 1, 3, fp);//文件头
	memcpy(&size, src.size, 2);
	len = size * sizeof(struct SRCUNIT) + 2;
	fwrite(src, 1, len, fp);
	for (i = 0; i < size; i++)
	{
		add = ftell(fp) - len - 3;
		fseek(fp, i * sizeof(struct SRCUNIT) + 9, 0);
		fwrite(&add, 1, 4, fp);
		fseek(fp, 0, 2);
		memcpy(&add, src.dat[i].add, 4);
		fseek(out.fp, add, 0);
		buf[0] = getc(out.fp);
		fread(buf + 1, 1, buf[0], out.fp);
		fwrite(buf, 1, buf[0]+1, fp);
		fread(&add, 1, 4, out.fp);
		fwrite(&add, 1, 4, fp);
		while (add)
		{
			if (add > 256)
			{
				tsize = 256;
			}
			else
			{
				tsize = add;
			}
			add = add - tsize;
			fread(buf, 1, tsize, out.fp);
			fwrite(buf, 1, tsize, fp);
		}
	}
	fclose(fp);
}

int WriteJiLu(char type, struct SRCTABLE &src, char &msg[])
{
	struct OUTFILE fn;
	long len, add;
	char buf[256];

	Swin("信息", "请选择加载记录", SWIN_ONE);
	if (!SelectSrc(fn, "/", 0xff)) return(-1);
	if (!(fn.fp = fopen(fn.name, "r")))
	{
		Swin("错误！", "无法打开文件", SWIN_ONE);
		return(-1);
	}
	if (!out.fp)
	{
		if (ChPath(cpldata))
		{
			Swin("错误！", "无法进入目录", SWIN_ONE);
			return(-1);
		}
		if (!(out.fp = fopen("mem.tmp", "w+")))
		{
			Swin("错误！", "无法创建文件", SWIN_ONE);
			return(-1);
		}
	}
	Swin("信息", NULL, SWIN_COM);
	//TextOut(43, 46, "加载中...", 128);
	textout(43, 46, "加载中...", 128);
	Refresh();
	add = fseek(out.fp, 0, 2);
	len = strlen(msg) + 1;
	putc(len, out.fp);
	fwrite(msg, 1, len, out.fp);
	len = fseek(fn.fp, 0, 2);
	rewind(fn.fp);
	if (!type)
	{
		len++;
		if (!getc(fn.fp))
		{
			len = len - 24;
			fseek(fn.fp, 24, 0);
		}
		else
		{
			rewind(fn.fp);
		}
	}
	fwrite(&len, 1, 4, out.fp);
	while (!feof(fn.fp))
	{
		len=fread(buf, 1, 256, fn.fp);
		fwrite(buf, 1, len, out.fp);
	}
	fclose(fn.fp);
	if (!type) putc(0, out.fp);
	return(add);
}

void SrcFace(int size, char change)
{
	char str[25];

	strcpy(str, "资源");
	if (out.name[0])
	{
		strcat(str, ":");
		strcat(str, out.name);
	}
	if (change) strcat(str, "*");
	Dwin(str);
	if (!size)
	{
		TextOut(32, 28, "按F1插入记录", 0x81);
		TextOut(14, 48, "按L键载入资源文件", 0x81);
	}
}

int SrcGetType()//类型输入
{
	char key, value;

	for (value = 1;;)
	{
		Swin("输入", NULL, SWIN_COM);
		TextOut(17, 35, "请选择类型：", 1);
#if WQX == 0
		Boxw(32, 52, "字符串");
		Boxw(86, 52, "无类型");
		Block(value * 54 + 33, 53, value * 54 + 70, 64, 2);
#else
		Boxw(29, 52, "字符串");
		Boxw(83, 52, "无类型");
		Block(value * 54 + 30, 53, value * 54 + 71, 64, 2);
#endif
		Refresh();
		key = getchar();
		if (key == DOWN_KEY || key == RIGHT_KEY || key == UP_KEY || key == LEFT_KEY) value = value ^ 1;
		else if (key == CR_KEY) return(value);
	}
}

#if WQX == 0
void PrintSrc(int first, int value, struct SRCTABLE &src)/*资源索引显示*/
{
	int size;
	long add;
	char i, j;
	char str[SRC_D_LEN];
	char tmp[17];

	memcpy(&size, src.size, 2);
	if (!size) return;
	MyBox(49, 18, 149, 76, 4);
	MyLine(49, 36, 147, 36, 64);
	MyBox(152, 18, 157, 76, 1);
	for (i = 0; i < 4 && i + first < size; i++)
	{
		memcpy(&add, src.dat[i + first].id, 4);
		sprintf(str, "%d", add);
		Rectangle(4, i * 15 + 18, 46, i * 15 + 31, 1);
		TextOut(26 - strlen(str) * 3, i * 15 + 19, str, 1);
	}
	memcpy(&add, src.dat[value + first].id, 4);
	sprintf(str, "%d", add);
	TextOut(103 - strlen(str) * 5, 20, str, 128);
	Block(5, value * 15 + 19, 45, value * 15 + 30, 2);
	Block(154, (first * 54) / size + 20, 155, ((first + i) * 54) / size + 20, 1);//进度显示
	memcpy(&add, src.dat[value + first].add, 4);
	fseek(out.fp, add, 0);
	size = getc(out.fp);
	fread(str, 1, size, out.fp);
	for (i = add = 0; i < 3 && add < size; i++)//说明
	{
		memcpy(tmp, str + add, 16);
		j = 0;
		while (j < 16)
		{
			if (tmp[j++] >= 160)
			{
				if (j >= 16)
				{
					j--;
					break;
				}
				j++;
			}
		}
		tmp[j] = 0;
		TextOut(51, i * 13 + 37, tmp, 1);
		add = add + j;
	}
}
#else
void PrintSrc(int first, int value, struct SRCTABLE &src)/*资源索引显示*/
{
	int size;
	long add;
	char i, j;
	char str[SRC_D_LEN];
	char tmp[17];
 
	memcpy(&size, src.size, 2);
	if (!size) return;
	Block(2, 16, 158, 78, 0);
	Rectangle(48, 17, 150, 77, 1);
	Line(48, 34, 150, 34, 65);
	Rectangle(152, 17, 157, 77, 1);
	for (i = 0; i < 4 && i + first < size; i++)
	{
		memcpy(&add, src.dat[i + first].id, 4);
		sprintf(str, "%d", add);
		Rectangle(3, i * 15 + 18, 46, i * 15 + 31, 1);
		TextOut(25 - strlen(str) * 3, i * 15 + 19, str, 1);
	}
	memcpy(&add, src.dat[value + first].id, 4);
	sprintf(str, "%d", add);
	TextOut(103 - strlen(str) * 5, 18, str, 128);
	Block(4, value * 15 + 19, 45, value * 15 + 30, 2);
	Block(154, (first * 56) / size + 19, 155, ((first + i) * 56) / size + 19, 1);//进度显示
	memcpy(&add, src.dat[value + first].add, 4);
	fseek(out.fp, add, 0);
	size = getc(out.fp);
	fread(str, 1, size, out.fp);
	for (i = add = 0;i < 3 && add < size;i++)//说明
	{
		memcpy(tmp, str + add, 16);
		j = 0;
		while(j < 16)
		{
			if (tmp[j++] >= 160)
			{
				if (j >= 16)
				{
					j--;
					break;
				}
				j++;
			}
		}
		tmp[j] = 0;
		TextOut(51, i * 13 + 37, tmp, 1);
		add = add + j;
	}
}
#endif

void SrcHelp()
{
	char key;
	char s[5][30];

_S1:
	strcpy(s[0], "A、F1:添加一个记录");
	strcpy(s[1], "D、F2:删除一个记录");
	strcpy(s[2], "F3键 :查找记录");
	strcpy(s[3], "F4键 :修改记录ID号");
	strcpy(s[4], "L键  :载入资源文件");
	PrintMsg(s, 0);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
	if (key == ESC_KEY || key == 'q') return;
	strcpy(s[0], "S键  :保存当前资源");
	strcpy(s[1], "ESC键:退出资源管理系统");
	s[2][0] = 0;
	PrintMsg(s, 0);
	key = getchar();
	if (key == UP_KEY || key == UU_KEY || key == LEFT_KEY) goto _S1;
}
void LookDat(struct SRCTABLE &src)
{
	struct _SRCUNIT e;
	char msg[SRC_D_LEN];
	char key, change;
	int first, cur, size;
	long t;
 
	SRC_Op(src, 0, 0, 0);
	memset(out, 0, sizeof(struct OUTFILE));
	for (first = cur = change = 0;;)
	{
		memcpy(&size, src.size, 2);
		SrcFace(size, change);
		PrintSrc(first, cur - first, src);
		Refresh();//界面
		key = getchar();
		if ((key == UP_KEY || key == LEFT_KEY) && cur)
		{
			cur--;
			if (cur < first) first = cur;
		}
		else if ((key == DOWN_KEY || key == RIGHT_KEY) && cur + 1 < size)
		{
			cur++;
			if (cur > first + 3) first = cur - 3;
		}
		else if (key == UU_KEY)
		{
			if (first < 4)
			{
				cur = cur - first;
				first = 0;
			}
			else
			{
				first = first - 4;
				cur = cur - 4;
			}
		}
		else if (key == DD_KEY && first + 4 < size)
		{
			first = first + 4;
			cur = cur + 4;
			if (cur >= size) cur = size - 1;
		}
		else if (key == A_KEY || key == F1_KEY)//插入
		{
			if (size >= SRC_M_SIZE)
			{
				sprintf(msg, "记录已达%d个", SRC_M_SIZE);
				Swin("提醒！", msg, SWIN_ONE);
			}
			else if (Inputw("请输入id号:", msg, 7, 0))
			{
				e.id = atoi(msg);
				t = SRC_Op(src, e, 0, TABLE_SEK);
				if (t >= 0)
				{
					Swin("警告！", "存在同名的id", SWIN_ONE);
					continue;
				}
				Inputw("请输入描述:", msg, SRC_D_LEN, 14);
				e.add = WriteJiLu(SrcGetType(), src, msg);
				if (e.add >= 0)
				{
					SRC_Op(src, e, 0, TABLE_INS);
					change = 1;
				}
			}
		}
		else if (key == D_KEY || key == F2_KEY)//删除
		{
			if (!size)
			{
				Swin("警告！", "没有记录可删除", SWIN_ONE);
			}
			else
			{
				if (cfset.dat[2].tem[1].value)
				{
					if (!Swin("删除？", "真的要删除么", SWIN_TWO)) continue;
				}
				SRC_Op(src, 0, cur, TABLE_DEL);
				if (size&cur >= size)
				{
					cur = size - 1;
					if (cur < first) first = cur;
				}
				change = 1;
			}
		}
		else if (key == F3_KEY)//查找
		{
			if (!size)
			{
				Swin("警告！", "没有记录可查找", SWIN_ONE);
			}
			else if (Inputw("请输入id号:", msg, 7, 0))
			{
				e.id = atoi(msg);
				t = SRC_Op(src, e, 0, TABLE_SEK);
				if (t < 0) Swin("信息", "没有找到", SWIN_ONE);
				else first = cur = t;
			}
		}
		else if (key == F4_KEY)//修改
		{
			if (!size)
			{
				Swin("警告！", "没有记录可修改", SWIN_ONE);
			}
			else if (Inputw("请输入新的id号:", msg, 7, 0))
			{
				e.id=atoi(msg);
				t = SRC_Op(src, e, 0, TABLE_SEK);
				memcpy(&e.add, src.dat[cur].id, 4);
				if (t >= 0)
				{
					if (e.add != e.id) Swin("警告！", "存在同名的id", SWIN_ONE);
					continue;
				}
				memcpy(&e.add, src.dat[cur].add, 4);
				SRC_Op(src, 0, cur, TABLE_DEL);
				SRC_Op(src, e, 0, TABLE_INS);
				change = 1;
			}
		}
		else if (key == 'l')
		{
			Swin("信息", "请选择加载资源", SWIN_ONE);
			if (SelectSrc(out, "/", 0xfc))
			{
				if (!LoadSrcFile(src)) first = cur = change = 0;
			}
		}
		else if (key == S_KEY)
		{
			if (!size)
			{
				Swin("警告！", "没有记录可保存", SWIN_ONE);
				continue;
			}
			if (cfset.dat[2].tem[2].value)
			{
				if (!Swin("保存？", "真的要保存么", SWIN_TWO)) continue;
			}
			if (!Inputw("请输入文件名:", out.name, 11, 29)) continue;
			ChExt(out.name, "dat");
			if (!out.path[0])
			{
				if (ChDir("/LavaData"))
				{
					strcpy(out.path, "/LavaData");
				}
				else if (ChDir("/GVMdata"))
				{
					strcpy(out.path, "/GVMdata");
				}
			}
			if (!SaveSrcFile(src)) change = 0;//保存数据
		}
		else if (key == HELP_KEY) SrcHelp();
		else if (key == ESC_KEY || key == 'q')
		{
			if (change && !cfset.dat[2].tem[3].value)
			{
				if (!Swin("退出？", "警告:数据已更改", SWIN_TWO)) continue;
			}
			if (out.fp)//删除文件
			{
				fclose(out.fp);
				out.fp = 0;
				if (cfset.dat[0].tem[3].value)
				{
					ChDir(cpldata);
					if (!DeleteFile("mem.tmp")) Swin("错误！", "无法删除*.tmp", SWIN_ONE);
				}
			}
			return;
		}
		else if (!cfset.dat[0].tem[2].value) Beep();
	}
}
//******************************************************预处理系统******************************************************//
/* 文件缓冲操作 */
void CUSH_FlY(char &buf[])
{
	long addrs;//文件地址
	long n;//长度

	addrs = ftell(in.fp);
	*out.p = 0;
	if (fwrite(buf, 1, n = strlen(buf), out.fp) != n) Error(out.name, E_WRITE);//输出到文件
	in.p = buf + FY_C_REL;
	memset(buf, 0, FY_C_SIZE);
	out.p = buf;
	if ((n = fread(in.p, 1, (FY_C_SIZE-FY_C_REL) - 1, in.fp)) != (FY_C_SIZE-FY_C_REL) - 1) return;
	n = in.p + n + 1;//输出到缓冲
	if (!strchr(in.p, ';'))//断点分析
	{
		if (!strchr(in.p, ','))
		{
			if (!strchr(in.p, '\n'))
			{
				Error(0, E_SEEK);
			}
			else
			{
				do {} while (*(--n) != '\n');
			}
		}
		else
		{
			do {} while (*(--n) != ',');
		}
	}
	else
	{
		do {} while (*(--n) != ';');
	}
	memset(++n, 0, in.p - n + (FY_C_SIZE-FY_C_REL) - 1);
	fseek(in.fp, addrs + n - in.p, 0);
}

/* num to str */
void ChNum(char &str[], char num)
{
	char i;

	memset(str, 0, 4);
	do{
		i = num % 10;
		num = num / 10;
		memmove(str + 1, str, strlen(str));
		*str = i + '0';
	} while(num);
}

void Mac_Get(struct MACUNIT &e)/*提取宏*/
{
	char i;

	i = 0;
	while (*in.p == '_' | isalnum(*in.p))
	{
		if (i < MAC_N_LEN - 1) e.name[i++] = *in.p;
		in.p++;
	}
	e.name[i] = 0;
}

/* 删除宏 */
void Mac_Del(struct MACTABLE &mac, struct MACUNIT &e)
{
	int i;

	for (i = 0; i < mac.size; i++)
	{
		if (!strcmp(mac.dat[i].name, e.name))
		{
			e.id = i;
			MAC_Op(mac, e, TABLE_DEL);
			return;
		}
	}
	Error(e.name, E_UDEF);
}

/* 复制文件 */
void CopyFile(char &buf[], struct MACUNIT &e)
{
	char fp;
	long n;

	Progress("载入中...", "正在处理文件包含", 1);//消息框
	*out.p = 0;
	fwrite(buf, 1, n = strlen(buf), out.fp);
	out.p = buf;//输出到文件
	if (!(fp = fopen(e.name, "r"))) Error(e.name, E_OPEN);
	fseek(fp, 0, 2);//长度
	n = ftell(fp);
	rewind(fp);
	while (!feof(fp))//复制
	{
		Progress(ftell(fp), n, 0);
		fwrite(buf, 1, fread(buf, 1, FY_C_REL, fp), out.fp);
	}
	fclose(fp);
	Progress("提取中...", "预处理系统正在运行 ", 1);//消息框
}

long Num_Get();

int _PreCalc(char &buf[], struct MACTABLE &mac, struct MACUNIT &e, char &sign[])
{
	char i, j;//数据指针,符号指针
	char c, d, f, flag;
	long n[8];//数据堆栈
	char o[8][2];//符号堆栈

	//SetScreen(1);
	i = j = flag = 0;
	for (;;)
	{
		if (isdigit(*in.p))
		{
			n[i++] = Num_Get();
			flag = 0;
			//printf("n = %d\n", n[i - 1]);getchar();
		}
		else if (isalpha(*in.p) | *in.p == '_')//词汇分析
		{
			Mac_Get(e);
			if (MAC_Op(mac, e, TABLE_SEK) >= 0)//查找宏
			{
				memcpy(in.p = in.p - strlen(e.value), e.value, strlen(e.value));
			}
			else
			{
				Error(e.name, E_UVAR);
			}
		}
		else if (strchr(sign, *in.p))
		{
			if (*in.p == '+')
			{
				c = 1;//符号
				d = 4;//等级
			}
			else if (*in.p == '-')
			{
				if (flag | !i)
				{
					c = 21;
					d = 2;
				}
				else
				{
					c = 2;
					d = 4;
				}
			}
			else if (*in.p == '*')
			{
				c = d = 3;
			}
			else if (*in.p == '/')
			{
				if (*(in.p + 1) == '/' | *(in.p + 1) == '*') return(n[0]);
				c = 4;
				d = 3;
			}
			else if (*in.p == '<')
			{
				if (*(in.p + 1) == '<')
				{
					c = d = 5;
					in.p++;
				}
				else if (*(in.p + 1) == '=')
				{
					c = d = 6;
					in.p++;
				}
				else
				{
					c = 7;
					d = 6;
				}
			}
			else if (*in.p == '>')
			{
				if (*(in.p + 1) == '>')
				{
					c = 8;
					d = 5;
					in.p++;
				}
				else if (*(in.p + 1) == '=')
				{
					c = 9;
					d = 6;
					in.p++;
				}
				else
				{
					c = 10;
					d = 6;
				}
			}
			else if (*in.p == '=')
			{
				if (*(in.p + 1) == '=')
				{
					c = 11;
					d = 6;
					in.p++;
				}
			}
			else if (*in.p == '&')
			{
				if (*(in.p + 1) == '&')
				{
					c = 12;
					d = 8;
					in.p++;
				}
				else
				{
					c = 13;
					d = 7;
				}
			}
			else if (*in.p == '|')
			{
				if (*(in.p + 1) == '|')
				{
					c = 14;
					d = 8;
					in.p++;
				}
				else
				{
					c = 15;
					d = 7;
				}
			}
			else if (*in.p == '!')
			{
				if (*(in.p + 1) == '=')
				{
					c = 16;
					c = 6;
					in.p++;
				}
				else
				{
					c = 17;
					d = 2;
				}
			}
			else if (*in.p == '%')
			{
				c = 18;
				d = 3;
			}
			else if (*in.p == '^')
			{
				c = 19;
				d = 7;
			}
			else
			{
				c = 20;
				d = 2;
			}
			in.p++;
END:
			//printf("j = %d i = %d\nc = %d d = %d\n", j, i, c, d);getchar();
			if (j && i)
			{
				if (o[j - 1][1] == 2)
				{
					f = o[j - 1][0];
					if		(f == 17)	n[i - 1] = !n[i - 1];
					else if	(f == 20)	n[i - 1] = ~n[i - 1];
					else if	(f == 21)	n[i - 1] = -n[i - 1];
				}
				else
				{
					while (j && i >= 2)
					{
						if (o[j - 1][1] > d) break;
						f = o[--j][0];
						i--;
						if		(f == 1)	n[i - 1] = n[i - 1] +  n[i];
						else if (f == 2)	n[i - 1] = n[i - 1] -  n[i];
						else if (f == 3)	n[i - 1] = n[i - 1] *  n[i];
						else if (f == 4)	n[i - 1] = n[i - 1] /  n[i];
						else if (f == 5)	n[i - 1] = n[i - 1] << n[i];
						else if (f == 6)	n[i - 1] = n[i - 1] <= n[i];
						else if (f == 7)	n[i - 1] = n[i - 1] <  n[i];
						else if (f == 8)	n[i - 1] = n[i - 1] >> n[i];
						else if (f == 9)	n[i - 1] = n[i - 1] >= n[i];
						else if (f == 10)	n[i - 1] = n[i - 1] >  n[i];
						else if (f == 11)	n[i - 1] = n[i - 1] == n[i];
						else if (f == 12)	n[i - 1] = n[i - 1] && n[i];
						else if (f == 13)	n[i - 1] = n[i - 1] &  n[i];
						else if (f == 14)	n[i - 1] = n[i - 1] || n[i];
						else if (f == 15)	n[i - 1] = n[i - 1] |  n[i];
						else if (f == 16)	n[i - 1] = n[i - 1] != n[i];
						else if (f == 18)	n[i - 1] = n[i - 1] %  n[i];
						else if (f == 19)	n[i - 1] = n[i - 1] ^  n[i];
						else Error(0, E_CONSTS);
					}
				}
			}
			if (flag == 2)
			{
				if (i > 1) Error(0, E_CONSTS);
				return(n[0]);
			}
			o[j][0] = c;//压入符号
			o[j++][1] = d;
			flag = 1;
		}
		else if (*in.p == '(')
		{
			in.p++;
			n[i++] = _PreCalc(buf, mac, e, sign);
			//printf("%c %d\n", *in.p++, n[i - 1]);getchar();
			if (*in.p++ != ')') Error(0, E_CONSTS);
		}
		else if (*in.p == ' ' | *in.p == 9)//空白符分析
		{
			do {in.p++;} while (*in.p == ' ' | *in.p == 9);
		}
		else
		{
			d = 10;
			flag = 2;
			goto END;
		}
	}
}

int PreCalc(char &buf[], struct MACTABLE &mac, struct MACUNIT &e)
{
	char sign[14];

	strcpy(sign, "+-*/<>=&|!%^~");
	return(_PreCalc(buf, mac, e, sign));
}

int SkipProgram(char &buf[], struct MACUNIT &e, int depth, char flag)
{
	int p;
	int ifDepth, oldDepth;

	strcpy(e.name, "*/");
	memcpy(&ifDepth, depth, 2);
	oldDepth = ifDepth;
	for (;;)
	{
		if (!*in.p)
		{
			CUSH_FlY(buf);
			if (!*in.p) Error(0, E_PRE_IF);
		}
		if (*in.p == '/')//注释分析
		{
			if (*(in.p + 1) == '/')
			{
				for (;;)
				{
					if (p = strchr(in.p, 13))
					{
						in.p = p + 2;
						break;
					}
					else
					{
						CUSH_FlY(buf);
						if (!*in.p) break;
					}
				}
				continue;
			}
			else if (*(in.p + 1) == '*')
			{
				in.p = in.p + 2;
				for (;;)
				{
					if (p = strstr(in.p, e.name))
					{
						in.p = p + 2;
						break;
					}
					else
					{
						CUSH_FlY(buf);
						if (!*in.p) Error(0, E_NOTE);
					}
				}
				continue;
			}
		}
		if (*in.p == '#')
		{
			do {
				do {} while (isspace(*(++in.p)));
			} while (*in.p == '#');
			Mac_Get(e);
			if (!strcmp(e.name, "if") | !strcmp(e.name, "ifdef") | !strcmp(e.name, "ifndef")) ifDepth++;
			else if (!strcmp(e.name, "endif"))
			{
				ifDepth--;
				if (oldDepth == ifDepth + 1)
				{
					memcpy(depth, &ifDepth, 2);
					return(e.name[0] = 0);
				}
			}
			else if (!strcmp(e.name, "else"))
			{
				if (oldDepth == ifDepth && flag)
				{
					if (isspace(*in.p))
					{
						do {} while (isspace(*(++in.p)));
					}
					Mac_Get(e);
					if (isspace(*in.p))
					{
						do {} while (isspace(*(++in.p)));
					}
					if (!strcmp(e.name, "if") | !strcmp(e.name, "ifdef") | !strcmp(e.name, "ifndef"))
					{
						ifDepth--;
						memcpy(depth, &ifDepth, 2);
						return(1);
					}
					return(0);
				}
			}
		}
		in.p++;
	}
}

void MAC_Prt(char &buf[], struct DOCTABLE &doc, struct MACTABLE &mac)/*预处理操作:in,out [通用]*/
{
	int ifDepth;//条件编译命令深度
	struct MACUNIT e;
	char sign[24];//符号缓冲
	char psign1[5];
	char psign2[4];
	char psign3[3];
	char psign4[7];
	char psign5[3];
	char j, mrk[20];//符号堆栈,指针
	int i;//临时变量

	Progress("提取中...", "预处理系统正在运行 ", 1);//消息框
	i = DiskMacro(mac, doc, TABLE_RED);
	if (datfp)//关闭资源文件(可能被打开)
	{
		fclose(datfp);
		datfp = 0;
	}
	if (i == 1) Error("macro.dat", E_CREAT);
	if (i == 2) Error("macro.dat", E_WRITE);
	strcpy(sign, "([{)]},;+-*/<>=&|!%^~.:");//不能改变
	strcpy(psign1, "nrtb");
	psign2[0] = 10;
	psign2[1] = 13;
	psign2[2] = 9;
	psign2[3] = 8;
	strcpy(psign3, "*/");
	strcpy(psign4, "define");
	strcpy(psign5, "/*");
	in.p = buf + FY_C_REL;
	memset(buf, 0, FY_C_SIZE);
	out.p = buf;
	j = lib.size = ifDepth = 0;//初始化
	if (!ChDir(out.path)) Error(out.path, E_CATA);
	if (!(in.fp = fopen(out.name, "r"))) Error(out.name, E_OPEN);//打开文件
	fseek(in.fp, 0, 2);
	in.size = ftell(in.fp);//获取文件长度
	rewind(in.fp);
	if (!in.size) Error(out.name, E_ZERO);
	if (!getc(in.fp))//头定位
	{
		fseek(in.fp, 24, 0);
	}
	else
	{
		rewind(in.fp);
	}
	if (ChPath(fundata)) Error(fundata, E_CATA);
	ChExt(out.name, "h");
	if (!(out.fp = fopen(out.name, "w+"))) Error(out.name, E_CREAT);//创建h文件
	for (;;)
	{
		if (!*in.p)
		{
			CUSH_FlY(buf);
			if (!*in.p) break;
		}
		if (isalnum(*in.p) | *in.p == '_')//词汇分析
		{
			Mac_Get(e);
STR_PTR_IF:	//#else预读
			if (!isdigit(e.name[0]))
			{
				if (MAC_Op(mac, e, TABLE_SEK) >= 0)//查找宏
				{
					memcpy(in.p = in.p - strlen(e.value), e.value, strlen(e.value));
					if (in.p < out.p) Error(e.name, E_DEFOVER);
					continue;
				}
			}
ANAL_STR:	//loadall等编译命令
			strcpy(out.p, e.name);
			out.p = out.p + strlen(e.name);
			*out.p++ = ' ';
			continue;
		}
		if (*in.p == '/')//注释分析
		{
			if (*(in.p + 1) == '/')
			{
				for (;;)
				{
					if (i = strchr(in.p, 13))
					{
						in.p = i + 2;
						break;
					}
					else
					{
						CUSH_FlY(buf);
						if (!*in.p) break;
					}
				}
				continue;
			}
			else if (*(in.p + 1) == '*')
			{
				in.p = in.p + 2;
				for (;;)
				{
					if (i = strstr(in.p, psign3))
					{
						in.p = i + 2;
						break;
					}
					else
					{
						CUSH_FlY(buf);
						if (!*in.p) Error(0, E_NOTE);
					}
				}
				continue;
			}
		}
		if (i = strchr(sign, *in.p))//符号分析
		{
			if (i <= sign + 2)//{[(
			{
				mrk[j++] = *(i + 3);
			}
			else if (i <= sign + 5)//}])
			{
				if (!j) Error(0, E_SYMB);
				if (mrk[--j] != *in.p) Error(0, E_SYMB);
				if (!j) Progress(ftell(in.fp) - strlen(in.p), in.size, 0);
			}
			if (out.p == buf)
			{
				fseek(out.fp, -1, 1);
				if (getc(out.fp) == ' ') fseek(out.fp, -1, 1);
			}
			else if (*(out.p - 1) == ' ')
			{
				out.p--;
			}
			*out.p++ = *in.p++;
			continue;
		}
		if (isspace(*in.p))//空白符分析
		{
			do {} while (isspace(*(++in.p)));
			continue;
		}
		if (*in.p == '"')//字符串分析
		{
			*out.p++ = *in.p++;
			do {
				do {
					if (!*in.p)
					{
						CUSH_FlY(buf);//溢出判断
						if (!*in.p) Error(0, E_NOQMRK);
					}
					if (*in.p == 13)
					{
						Error(0, E_NOQMRK);
					}
					*out.p++ = *in.p;
				} while (*in.p++ != '"');
			} while (*(in.p - 2) == 92);
			continue;
		}
		if (*in.p == '\'')//'分析
		{
			if (*++in.p == '\'') Error(0, E_NONE);//空字符
			if (*in.p == 92)//转意
			{
				if (i = strchr(psign1, *++in.p)) *in.p = psign2[i - psign1];
			}
			ChNum(e.name, *in.p++);
			strcpy(out.p, e.name);
			out.p = out.p + strlen(e.name);
			if (!*in.p)//溢出判断
			{
				CUSH_FlY(buf);
				if (!*in.p) Error(0, E_GRAMMAR);
			}
			if (*in.p++ != '\'') Error(0, E_CBIG);//长字符
			continue;
		}
		if (*in.p == '#')//自定义宏
		{
			do {
				do {} while (isspace(*(++in.p)));
			} while (*in.p == '#');
			Mac_Get(e);
			if (isspace(*in.p))
			{
				do {} while (isspace(*(++in.p)));
			}
			if (!strcmp(e.name, psign4))//宏定义
			{
				Mac_Get(e);
				if (isspace(*in.p))
				{
					do {} while (isspace(*(++in.p)));
				}
				i = 0;
				memset(e.value, 0, MAC_V_LEN);//初始化
JUM://提取宏值
				do {
					if (i < MAC_V_LEN - 1) e.value[i++] = *in.p;
				} while (*++in.p != '/' && !isspace(*in.p))
				if (*in.p == '/')
				{
					if (!strchr(psign5, *(in.p + 1))) goto JUM;
				}
				else if (*in.p == ' ')
				{
					if (*(in.p + 1) == '\'') goto JUM;//补充
				}
				i = MAC_Op(mac, e, TABLE_INS);//写入宏
				if (i < 0)
				{
					if (i == -2) Error(0, E_MMAC);//溢出
					Error(e.name, E_RDEF);//重复
				}
				continue;
			}
			if (!strcmp(e.name, "include"))//文件包含
			{
				in.p++;
				i = 0;
				strcpy(e.value, "\">");
				while(!strchr(e.value, *in.p))//提取文件名
				{
					if (i < MAC_N_LEN - 1) e.name[i++] = *in.p;
					in.p++;
				}
				e.name[i] = 0;
				in.p++;
				if (!ChkExt(e.name, "h"))
				{
					if (ChkExt(e.name, "y"))
					{
						if (lib.size >= LIB_SIZE) Error(0, E_LINK);
						strcpy(lib.name[lib.size++], e.name);
					}
					else
					{
						Error(0, E_HEADFILE);
					}
				}
				else//复制文件
				{
					CopyFile(buf, e);
				}
				continue;
			}
			if (!strcmp(e.name, "undef"))
			{
				Mac_Get(e);
				Mac_Del(mac, e);
				continue;
			}
JMP_PRE_IF:
			if (!strcmp(e.name, "if"))//条件编译1
			{
				ifDepth++;
				if (PreCalc(buf, mac, e)) continue;
				if (SkipProgram(buf, e, &ifDepth, 1)) goto JMP_PRE_IF;
				if (e.name[0]) goto STR_PTR_IF;
				continue;
			}
			if (!strcmp(e.name, "ifdef"))//条件编译2
			{
				ifDepth++;
				Mac_Get(e);
				i = MAC_Op(mac, e, TABLE_SEK);//查找宏表
				if (i >= 0) continue;
				if (SkipProgram(buf, e, &ifDepth, 1)) goto JMP_PRE_IF;
				if (e.name[0]) goto STR_PTR_IF;
				continue;
			}
			if (!strcmp(e.name, "ifndef"))//条件编译3
			{
				ifDepth++;
				Mac_Get(e);
				i = MAC_Op(mac, e, TABLE_SEK);//查找宏表
				if (i < 0) continue;
				if (SkipProgram(buf, e, &ifDepth, 1)) goto JMP_PRE_IF;
				if (e.name[0]) goto STR_PTR_IF;
				continue;
			}
			if (!strcmp(e.name, "else"))
			{
				Mac_Get(e);//消除if,ifdef,ifndef
				SkipProgram(buf, e, &ifDepth, 0);
				continue;
			}
			if (!strcmp(e.name, "endif"))
			{
				ifDepth--;
				continue;
			}
			if (!strcmp(e.name, "loadall"))
			{
CPL_START:
				*out.p++ = '#';
				goto ANAL_STR;
			}
			if (!strcmp(e.name, "code"))	goto CPL_START;
			if (!strcmp(e.name, "begin"))	goto CPL_START;
			if (!strcmp(e.name, "end"))		goto CPL_START;
			if (!strcmp(e.name, "skip"))	goto CPL_START;
			if (!strcmp(e.name, "loaddata"))goto CPL_START;
			if (!strcmp(e.name, "delete"))	goto CPL_START;
			//if (!strcmp(e.name, "link"))	goto CPL_START;
			Error(e.name, E_PRETCMD);
		}
		Mac_Get(e);
		if (isprint(e.name[0]))
		{
			Error(e.name, E_STR);//非法字符
		}
		else
		{
			Error(*in.p, E_USIGN);
		}
	}
	if (j) Error(0, E_SYMB);
	if (ifDepth) Error(0, E_PRE_IF);
	Progress(1, 1, 0);
	fclose(in.fp);
	in.fp = out.fp;
	out.fp = 0;
	fseek(in.fp, 0, 2);
	in.size = ftell(in.fp);
	rewind(in.fp);
}
//*******************************************************链接系统*******************************************************//
long GetFileLen(char fp)
{
	long len;

	fseek(fp, 0, 2);
	len = ftell(fp);
	rewind(fp);
	if (!getc(fp))
	{
		fseek(fp, 24, 0);
	}
	else
	{
		rewind(fp);
	}
	return(len);
}

/* 获取说明 */
void ReadShow(char &buf[])
{
	int len;
	long filelen, jmp;
	long size;//文本大小

	Progress("载入中...", "链接生成系统正在运行", 1);//消息框
	ChDir(txtdata);
	if (!(in.fp = fopen("说明.txt", "r"))) Error("说明.txt", E_OPEN);
	filelen = GetFileLen(in.fp);//获取文件长度
	size = filelen - ftell(in.fp);
	if (ChPath(libdata)) Error(libdata, E_CATA);
	ChExt(out.name, "y");
	if (!(out.fp = fopen(out.name, "w"))) Error(out.name, E_CREAT);
	jmp = size + 7;
	if (fwrite(&jmp, 1, 4, out.fp) != 4) Error(out.name, E_WRITE);//写入跳转 1+2+4
	fwrite(&size, 1, 2, out.fp);//写入文本大小
	while (!feof(in.fp))//写入文本
	{
		len = fread(buf, 1, LIB_C_LEN, in.fp);
		if (fwrite(buf, 1, len, out.fp) != len) Error(out.name, E_WRITE);
		Progress(ftell(in.fp), filelen, 0);
	}
	putc(0, out.fp);
	fclose(in.fp);
	in.fp = 0;
	Progress(1, 1, 0);
}

/* 生成*.y */
void MakeLib(struct LIB &d)
{
	long c, end, offset, fadd;//临时变量 文件尾地址 偏移量 代码开始地址
	int i, j;
	char cmd;

	Progress("生成中...", "链接生成系统正在运行", 1);//消息框
	ChDir(out.path);
	ChExt(out.name, "lav");
	if (!(in.fp = fopen(out.name, "r"))) Error(out.name, E_OPEN);
	if (ChPath(libdata)) Error(libdata, E_CATA);
	ChExt(out.name, "y");
	memset(&c, 0, 21);
	fseek(in.fp, 16, 0);//调整
	fadd = ftell(out.fp);
	fwrite(&c, 1, 2, out.fp);//临时写入空的变量总空间
	for (;;)//lav头处理
	{
		cmd = getc(in.fp);
		if (cmd == 65)
		{
			putc(65, out.fp);//写入虚拟指令
			fread(&c, 1, 4, in.fp);
			fwrite(&c, 1, 4, out.fp);
			c = c >> 16;
			for (j = 0; j < c; j++) putc(getc(in.fp), out.fp);
		}
		else if (cmd == 60)//变量总空间
		{
			fread(&c, 1, 2, in.fp);
			cp.add[VGLOBOLE] = c;//记录总空间
			fseek(out.fp, fadd, 0);
			fwrite(&c, 1, 2, out.fp);
			fseek(out.fp, 0, 2);
		}
		else if (cmd == 59)
		{
			fread(&end, 1, 3, in.fp);
			if (!offset) offset = ftell(in.fp);
			fseek(in.fp, end, 0);
		}
		else if (cmd == 62)
		{
			fseek(in.fp, offset, 0);
			break;
		}
	}
	while (!feof(in.fp))
	{
		cmd = getc(in.fp);
		if (cmd == 62)//函数入口
		{
			if (ftell(in.fp) >= end)//结束
			{
				fseek(out.fp, 0, 2);
				in.size = ftell(out.fp);
				fclose(out.fp);
				fclose(in.fp);
				out.fp = in.fp = 0;
				Progress(1, 1, 0);
				if (i != d.size) Error(0, E_JKDIFF);
				return;
			}
			Progress(ftell(in.fp), end, 0);
			memset(cv, 0, sizeof(struct COM_VAR));
			c = 0;//初始化
			fread(&c, 1, 3, in.fp);
			putc(62, out.fp);
			fwrite(&c, 1, 3, out.fp);//写入函数头
			cv.d[1] = c >> 16;
			cv.t = LVM_SUB;
			strcpy(cv.n, d.f[i].n);
			cv.b = d.f[i].b;
			cv.v = ftell(in.fp) - offset - 4;
			if (d.f[i++].b == 0xff)
			{
				putc(0xff, out.fp);
				continue;
			}
			if (i > d.size) Error(0, E_INTER);//接口错误
			putc(0xfe, out.fp);
			fwrite(cv, 1, sizeof(struct COM_VAR), out.fp);
			continue;
		}
		putc(cmd, out.fp);
		if (cmd == 1) putc(getc(in.fp), out.fp);//1 Byte
		else if (cmd == 3 || cmd == 65)//4 Byte
		{
			fread(&c, 1, 4, in.fp);
			fwrite(&c, 1, 4, out.fp);
			if (cmd == 65)
			{
				c = c >> 16;
				for (j = 0; j < c; j++) putc(getc(in.fp), out.fp);
			}
		}
		else if (cmd == 13)//字符串
		{
			do {
				putc(cmd = getc(in.fp), out.fp);
			} while (cmd);
		}
		else if (!cmd) continue;
		else if (cmd <= 25 || cmd == 60 || (cmd >= 69 && cmd <= 81))//2 Byte
		{
			fread(&c, 1, 2, in.fp);
			fwrite(&c, 1, 2, out.fp);
		}
		else if (cmd >= 57 && cmd <= 61)//跳转
		{
			c = 0;
			fread(&c, 1, 3, in.fp);
			c = c - offset;
			fwrite(&c, 1, 3, out.fp);
		}
		else if ((cmd > 83 && cmd < 128) || cmd > 223) Error(out.name, E_OFFSET);//错误
	}
	Error(0, E_INTER);//接口错误
}

/* 获取接口 */
void GetFunName(struct LIB &d)
{
	char c, j;
	long filelen;
	int i;

	Progress("处理中...", "链接系统正在处理接口", 1);//消息框
	ChDir(txtdata);
	if (!(in.fp = fopen("接口.txt", "r"))) Error("接口.txt", E_OPEN);
	filelen = GetFileLen(in.fp);//获取文件长度
	memset(d, 0, sizeof(struct LIB));
	j = 0;
	while (!feof(in.fp))
	{
		c = getc(in.fp);
		if (isdigit(c))//数字
		{
			if (!j)
			{
				d.f[d.size].b = ~(c - '0');
				j++;
			}
			else if (j == 2)
			{
				if (d.f[d.size].b != 0xff) d.f[d.size].b = c - '0';
				j = 0;
				d.size++;
			}
			else Error(0, E_FORMAT);
			Progress(ftell(in.fp), filelen, 0);
		}
		else if (isalnum(c) || c == '_')//字符串
		{
			if (j == 1)
			{
				for (i = 0; isalnum(c) || c == '_'; i++)
				{
					d.f[d.size].n[i] = c;
					c = getc(in.fp);
				}
				j++;
			}
			else
			{
				Error(0, E_FORMAT);
			}
		}
	}
	fclose(in.fp);
	in.fp = 0;
	Progress(1, 1, 0);
}

/* [通用] */
void Lib_Op(struct LIB &d, char &buf[])
{
	GetFunName(d);//获取接口
	ReadShow(buf);//写入说明
	MakeLib(d);//写入函数
	Success(2);
}
//*******************************************************缓冲系统*******************************************************//
void CUSH_Sav()//写入剩余在缓冲区的代码
{
	fwrite(FB_CUSH, 1, out.p, out.fp);
	out.p = 0;
}

void CUSH_Get()/*缓冲输入操作*/
{
	long addrs;
	int n;

	addrs = ftell(in.fp);
	in.p = FB_CUSH + FB_C_REL;
	memset(in.p, 0, (FB_C_SIZE - FB_C_REL));//初始化文本缓冲区
	if ((n = fread(in.p, 1, (FB_C_SIZE - FB_C_REL) - 1, in.fp)) < (FB_C_SIZE - FB_C_REL) - 1) return;//读取文本到缓冲区
	n = in.p + n;
	if (!strchr(in.p, ';'))
	{
		if (!strchr(in.p, ','))
		{
			Error(0, E_SEEK);
		}
		else
		{
			while (*n != ',') n--;
		}
	}
	else
	{
		while (*n != ';') n--;
	}
	memset(++n, 0, in.p - n + (FB_C_SIZE - FB_C_REL) - 1);
	fseek(in.fp, addrs + n - in.p, 0);
}

void Put(long data, char len)/*缓冲输出操作*/
{
	if (out.p > FB_C_REL - 4)
	{
		if (fwrite(FB_CUSH, 1, out.p, out.fp) != out.p) Error(out.name, E_WRITE);
		out.p = 0;
	}
	memcpy(out.p + FB_CUSH, &data, len);
	out.p = out.p + len;
	cp.offset = cp.offset + len;
}

void Move(long len)/*移动输出指针(补0)*/
{
	if (len > 0)
	{
		CUSH_Sav();
		memset(FB_CUSH, 0, FB_C_REL);
		cp.offset = cp.offset + len;
		while (len)//写入len个0
		{
			if (len > FB_C_REL)
			{
				fwrite(FB_CUSH, 1, FB_C_REL, out.fp);
				len = len - FB_C_REL;
			}
			else
			{
				out.p = len;
				len = 0;
			}
		}
	}
	else if (len < 0)
	{
		cp.offset = cp.offset + len;
		out.p = out.p + len;
		if (out.p < 0)
		{
			fseek(out.fp, out.p, 1);
			out.p = 0;
		}
	}
}
//*******************************************************变量系统*******************************************************//
/* 把接口var插入变量表，成功则返回0，否则返回插入位置（指针）+1（非0） */
int SavVar()
{
	int low, mid, high, t, i;

	i = var.ph;
	high = var.pt - 1;
	while (i <= high)//局部查找
	{
		t = strcmp(var.ptr[mid = (i + high) >> 1], cv.n);
		if (t > 0)
		{
			high = mid - 1;
		}
		else if (t < 0)
		{
			i = mid + 1;
		}
		else
		{
			var.i = mid;
			return(1);
		}
	}
	if (var.ph)//全局查找
	{
		low = 0;
		high = var.ph - 1;
		while (low <= high)
		{
			t =strcmp(var.ptr[mid = (low + high) >> 1], cv.n);
			if (t > 0)
			{
				high = mid - 1;
			}
			else if (t < 0)
			{
				low = mid + 1;
			}
			else
			{
				var.i = mid;
				return(1);
			}
		}
	}
	memmove(&var.ptr[i + 1], &var.ptr[i], ((var.pt++) - i) << 1);
	var.ptr[i] = var.bt;//插入变量链表
//----------------------------------------------------插入变量存储表
	strcpy(var.bt, cv.n);//记录名称
	*(var.bt = var.bt + strlen(cv.n) + 1) = cv.t;//记录类型
	if (cv.t <= (VPART		+UNIT_ARR))//基本变量
	{
		*(var.bt + 1) = cv.b;//记录字节
		memcpy(var.bt + 2, &cv.v, 2);//记录地址
		var.bt = var.bt + 4;
		if (cv.t >= (VGLOBOLE	+UNIT_ARR))//数组下标
		{
			cv.d[cv.d[0]] = cv.d[DIM_MAX - 1];
			memcpy(var.bt, cv.d, DIM_MAX * 2);
			var.bt = var.bt + (cv.d[0] << 1) + 2;
		}
	}
	else if (cv.t == LVM_SUB)//子程序
	{
		memcpy(var.bt + 1, &cv.b, 10);
		var.bt = var.bt + 11;
	}
	else if (cv.t == LVM_LABEL)//标号
	{
		memcpy(var.bt + 1, &cv.v, 6);
		var.bt = var.bt + 7;
	}
	else if (cv.t <= (VPART		+UNIT_UNI+UNIT_ARR))//结构
	{
		memcpy(var.bt + 1, &cv.b, 6);
		var.bt = var.bt + 7;
		if (cv.t >= (VGLOBOLE	+UNIT_STU+UNIT_ARR))//数组下标
		{
			cv.d[cv.d[0]] = cv.d[DIM_MAX - 1];
			memcpy(var.bt, cv.d, DIM_MAX * 2);
			var.bt = var.bt + (cv.d[0] << 1) + 2;
		}
	}
	else if (cv.t <= (VPART		+UNIT_UNI+UNIT_QFM))//类型名
	{
		memcpy(var.bt + 1, &cv.b, 4);
		var.bt = var.bt + 5;
	}
	else if (cv.t <= V_POINT + (VPART		+UNIT_ARR))//变量指针
	{
		*(var.bt + 1) = cv.b;//记录字节
		memcpy(var.bt + 2, &cv.v, 2);//记录地址
		var.bt = var.bt + 4;
		if (cv.t >= V_POINT + (VGLOBOLE	+UNIT_ARR))//数组下标
		{
			cv.d[cv.d[0]] = cv.d[DIM_MAX - 1];
			memcpy(var.bt, cv.d, DIM_MAX * 2);
			var.bt = var.bt + (cv.d[0] << 1) + 2;
		}
	}
	else if (cv.t <= V_POINT + (VPART		+UNIT_UNI+UNIT_ARR))//结构指针
	{
		memcpy(var.bt + 1, &cv.b, 6);
		var.bt = var.bt + 7;
		if (cv.t >= V_POINT + (VGLOBOLE	+UNIT_STU+UNIT_ARR))//数组下标
		{
			cv.d[cv.d[0]] = cv.d[DIM_MAX - 1];
			memcpy(var.bt, cv.d, DIM_MAX * 2);
			var.bt = var.bt + (cv.d[0] << 1) + 2;
		}
	}
	else
	{
		Error(cv.t, E_UNCODE);//错误的定义码
	}
	if (var.pt >= VAR_SIZE | var.bt >= cv) Error(0, E_MVAR);//溢出判断
	//{SetScreen(0);printf("变量太多!\n链表剩余:%d\n空间剩余:%d",VAR_SIZE-var.pt,cv-var.bt);getchar();exit(0);}
}

/* 把指针i指向的变量从变量表中载入到接口var */
void ReadVar(int i)
{
	int p;

	strcpy(cv.n, var.ptr[i]);//读取名称
	cv.t = *(p = var.ptr[i] + strlen(cv.n) + 1);//读取类型
	if (cv.t <= (VPART		+UNIT_ARR))//基本变量
	{
		cv.b = *(p + 1);
		cv.v = *(p + 2)|(*(p + 3) << 8);
		if (cv.t >= (VGLOBOLE	+UNIT_ARR)) memcpy(cv.d, p + 4, DIM_MAX * 2);
		return;
	}
	if (cv.t == LVM_FUN)//函数
	{
		cv.b = *(p + 1);
		cv.v = *(p + 2);
		cv.d[1] = *(p + 3);
		return;
	}
	if (cv.t == LVM_SUB)//子程序
	{
		memcpy(&cv.b, p + 1, 10);
		return;
	}
	if (cv.t == LVM_LABEL)//标号
	{
		memcpy(&cv.v, p + 1, 6);
		return;
	}
	if (cv.t <= (VPART		+UNIT_UNI+UNIT_ARR))//结构
	{
		memcpy(&cv.b, p + 1, 6);
		if (cv.t >= (VGLOBOLE	+UNIT_STU+UNIT_ARR)) memcpy(cv.d, p + 7, DIM_MAX * 2);
		return;
	}
	if (cv.t <= (VPART		+UNIT_UNI+UNIT_QFM))
	{
		memcpy(&cv.b, p + 1, 4);//引用
		return;
	}
	if (cv.t <= V_POINT + (VPART		+UNIT_ARR))
	{
		cv.b = *(p + 1);
		cv.v = *(p + 2)|(*(p + 3) << 8);
		if (cv.t >= V_POINT + (VGLOBOLE	+UNIT_ARR)) memcpy(cv.d, p + 4, DIM_MAX * 2);
		return;
	}
	if (cv.t <= V_POINT + (VPART		+UNIT_UNI+UNIT_ARR))//指针
	{
		memcpy(&cv.b, p + 1, 6);
		if (cv.t >= V_POINT + (VGLOBOLE	+UNIT_STU+UNIT_ARR)) memcpy(cv.d, p + 7, DIM_MAX * 2);
		return;
	}
	Error(cv.t, E_UNCODE);//错误的定义码
}

/* 查找变量表，成功则返回0并把变量载入到接口var，否则返回1。（先查找内部变量表，没有时再查找外部的） */
int SeekVar()
{
	int low, mid, high, t;

	if (var.i < var.pt)
	{
		if (!strcmp(var.ptr[var.i], cv.n))
		{
			ReadVar(var.i);
			return(0);
		}
	}
	low = var.ph;
	high = var.pt - 1;//局部查找
	while (low <= high)
	{
		t = strcmp(var.ptr[mid = (low + high) >> 1], cv.n);
		if (t > 0)
		{
			high = mid - 1;
		}
		else if (t < 0)
		{
			low = mid + 1;
		}
		else
		{
			ReadVar(var.i = mid);
			return(0);
		}
	}
	if (var.ph)//全局查找
	{
		low = 0;
		high = var.ph - 1;
		while (low <= high)
		{
			t = strcmp(var.ptr[mid = (low + high) >> 1], cv.n);
			if (t > 0)
			{
				high = mid - 1;
			}
			else if (t < 0)
			{
				low = mid + 1;
			}
			else
			{
				ReadVar(var.i = mid);
				return(0);
			}
		}
	}
	return(1);//查找失败，返回1
}

int DeleteVar()//将与接口var匹配的变量从变量表中删除
{
	int p, q, t;

	if (!SeekVar())
	{
		p = var.ptr[var.i];//头指针
		t = *(q = p + strlen(p) + 1);
		if (t <= (VPART		+UNIT_ARR))
		{
			q = q + 4;
			if (t >= (VGLOBOLE	+UNIT_ARR))
			{
				memcpy(&t, q, 2);
				q = q + (t << 1) + 2;
			}
		}
		else if (t == LVM_FUN)
		{
			q = q + 4;
		}
		else if (t == LVM_SUB)
		{
			q = q + 11;
		}
		else if (t == LVM_LABEL)
		{
			q = q + 7;
		}
		else if (t <= (VPART		+UNIT_UNI+UNIT_ARR))
		{
			q = q + 7;
			if (t >= (VGLOBOLE	+UNIT_STU+UNIT_ARR))
			{
				memcpy(&t, q, 2);
				q = q + (t << 1) + 2;
			}
		}
		else if (t <= (VPART		+UNIT_UNI+UNIT_QFM))
		{
			q = q + 5;
		}
		else if (t <= V_POINT + (VPART		+UNIT_ARR))
		{
			q = q + 4;
			if (t >= V_POINT + (VGLOBOLE	+UNIT_ARR))
			{
				memcpy(&t, q, 2);
				q = q + (t << 1) + 2;
			}
		}
		else if (t <= V_POINT + (VPART		+UNIT_UNI+UNIT_ARR))
		{
			q = q + 7;
			if (t >= V_POINT + (VGLOBOLE	+UNIT_STU+UNIT_ARR))
			{
				memcpy(&t, q, 2);
				q = q + (t << 1) + 2;
			}
		}
		else
		{
			Error(t, E_UNCODE);//错误的定义码
		}
		memmove(p, q, var.bt - q);
		var.bt = var.bt - (t = q - p);
		memset(var.bt, 0, cv - var.bt);
		memmove(&var.ptr[var.i], &var.ptr[var.i + 1], ((--var.pt) - var.i) << 1);
		memset(&var.ptr[var.pt], 0, (VAR_SIZE - var.pt) << 1);
		if (var.bh > p)
		{
			var.bh = var.bh - t;
			var.ph = var.ph - 2;
		}
		for (q = 0; q < var.pt; q++)
		{
			if (var.ptr[q] >= p) var.ptr[q] = var.ptr[q] - t;
		}
		return(1);
	}
}

/* 更新变量表，i:变量表指针，add:新值地址，rel:偏移量 */
void RenewVar(int i, int add, char rel)
{
	memcpy(var.ptr[i] + strlen(var.ptr[i]) + rel, add, 3);
}

/* 更新成员数据(结构) p:成员内存地址 */
void RenewMember(int p)
{
	char type;//类型
	int d;//数组大小

	while (p < var.bt)
	{
		type = *(p = p + strlen(p) + 1);//跳过名称
		if (type <= (VPART		+UNIT_ARR))//基本变量
		{
			p = p + 4;
			if (type >= (VGLOBOLE	+UNIT_ARR))
			{
				memcpy(&d, p, 2);
				p = p + d + 2;
			}
			continue;
		}
		if (type <= (VPART		+UNIT_UNI+UNIT_ARR))//结构(更新)
		{
			memcpy(p + 1, &cv.b, 2);
			p = p + 7;
			if (type >= (VGLOBOLE	+UNIT_STU+UNIT_ARR))
			{
				memcpy(&d, p, 2);
				p = p + d + 2;
			}
			continue;
		}
		if (type <= V_POINT + (VPART		+UNIT_ARR))//变量指针
		{
			p = p + 4;
			if (type >= V_POINT + (VGLOBOLE	+UNIT_ARR))
			{
				memcpy(&d, p, 2);
				p = p + d + 2;
			}
			continue;
		}
		if (type <= V_POINT + (VPART		+UNIT_UNI+UNIT_ARR))//结构指针
		{
			memcpy(p + 1, &cv.b, 2);
			p = p + 7;
			if (type >= V_POINT + (VGLOBOLE	+UNIT_STU+UNIT_ARR))
			{
				memcpy(&d, p, 2);
				p = p + d + 2;
			}
			continue;
		}
		Error(type, E_UNCODE);//错误的定义码
	}
}

void LoadVFun()//初始化变量表，载入函数文件
{
	char fp;
	int i, size;

	if(!ChDir(cpldata)) Error(cpldata, E_CATA);
	if (!(fp = fopen(cfset.fun, "r"))) Error(cfset.fun, E_OPEN);//无法打开文件
	memset((FB_CUSH + FB_C_SIZE), 0, var - (FB_CUSH + FB_C_SIZE));
	memset(var, 0, sizeof(struct VAR_LINK));//初始化
	fseek(fp, 4, 0);
	fread(&var.pt, 1, 2, fp);
	fread(&size, 1, 2, fp);//读取长度
	fread(var.ptr, 1, (var.pt) << 1, fp);
	fread(var.bh = (FB_CUSH + FB_C_SIZE), 1, size, fp);//读取两个表
	fclose(fp);
	var.bt = size + (FB_CUSH + FB_C_SIZE);
	for (var.ph = i = 0; i < var.pt; i++)//调整
	{
		var.ptr[i] = var.ptr[i] + (FB_CUSH + FB_C_SIZE);
	}
}
//*******************************************************跳转系统*******************************************************//
/* 跳转写入 */
void W_Jmp(long addrs, long data, int len)
{
	if (addrs + out.p >= cp.offset)
	{
		memcpy(addrs + out.p - cp.offset + FB_CUSH, &data, len);
	}
	else
	{
		fseek(out.fp, addrs, 0);
		fwrite(&data, 1, len, out.fp);
		fseek(out.fp, 0, 2);
	}
}

/* 把源跳转地址插入跳转表 */
void SavJmp(int type, long data)
{
	int low, mid, high;
	long t;

	low = 0;
	high = jp.size - 1;
	while (low <= high)
	{
		t = jp.d[mid = (low + high) >> 1].t - type;
		if (t > 0)
		{
			high = mid - 1;
		}
		else if (t < 0)
		{
			low = mid + 1;
		}
		else
		{
			low = mid;
			break;
		}
	}
	if (jp.size >= JP_SIZE) Error(0, E_JMPM);//溢出判断
	memmove(jp.d[low + 1], jp.d[low], ((jp.size++) - low) * sizeof(struct UNIT_JUMP));
	jp.d[low].t = type;
	jp.d[low].a = data;//插入跳转
}

/* 查找跳转表，成功则返回1并写入跳转目的地址，否则返回0 */
int SeekJmp(int type, long data)
{
	int low, mid, high;
	long t;

	low = 0;
	high = jp.size - 1;
	while (low <= high)
	{
		t = jp.d[mid = (low + high) >> 1].t - type;
		if (t > 0)
		{
			high = mid - 1;
		}
		else if (t < 0)
		{
			low = mid + 1;
		}
		else
		{
			W_Jmp(jp.d[mid].a, cp.offset + data, 3);//跳转
			memmove(jp.d[mid], jp.d[mid + 1],((jp.size--) - mid) * sizeof(struct UNIT_JUMP));
			jp.d[jp.size].t = 0;//删除
			return(1);
		}
	}
}

/* 初始化局部跳转 */
void DelJmp()
{
	int i;

	for (i = 0; i < jp.size; i++)
	{
		if ((jp.d[i].t >> 16 - JP_TYP) != JP_SUB) Error(0, E_JMPE);
	}
}
//*****************************************************临时文件系统*****************************************************//
/* 导出临时文件 */
void Loadtmp()
{
	CUSH_Sav();
	rewind(cp.fp);//调整
	while (!feof(cp.fp))
	{
		out.p = fread(FB_CUSH, 1, FB_C_REL, cp.fp);
		if (fwrite(FB_CUSH, 1, out.p, out.fp) != out.p) Error(out.name, E_WRITE);
		cp.offset = cp.offset + out.p;//地址增加
		cp.ary = cp.ary + out.p;//#loadall内存空间增加
	}
	out.p = 0;
}

/* 写入剩余在缓冲区的代码到临时文件 */
void Savtmp()
{
	fwrite(FB_CUSH, 1, out.p, cp.fp);
	out.p = 0;
}

/* 写入临时文件 */
void tPut(long data, char len)
{
	if (out.p > FB_C_REL - 4)
	{
		if (fwrite(FB_CUSH, 1, out.p, cp.fp) != out.p) Error("cpl.tmp", E_WRITE);
		out.p = 0;
	}
	memcpy(out.p + FB_CUSH, &data, len);
	out.p = out.p + len;
}

/* 移动临时输出指针(补0) */
void tMove(long len)
{
	Savtmp();
	memset(FB_CUSH, 0, FB_C_REL);
	while (len)//写入len个0
	{
		if (len > FB_C_REL)
		{
			fwrite(FB_CUSH, 1, FB_C_REL, out.fp);
			len = len - FB_C_REL;
		}
		else
		{
			out.p = len;
			len = 0;
		}
	}
}
//*******************************************************链接系统*******************************************************//
/* 恢复打开文件 */
void Recover(long fadd)
{
	if (!ChDir(fundata)) Error(fundata, E_CATA);
	ChExt(out.name, "h");
	if (!(in.fp = fopen(out.name, "r"))) Error(out.name, E_OPEN);//重新打开源程序文件
	fseek(in.fp, fadd, 0);
	ChExt(out.name, "lav");
}

void LoadLib()
{
	struct COM_VAR t;//临时接口
	char fp, cmd;//句柄
	long add, c, fadd;//当前文件地址偏移量 y文件入口 源程序(*.h)当前地址
	int tv;//当前变量地址偏移量
	int i;//临时变量
	int j, type;//临时变量[j,type位置不能换]

	fadd = ftell(in.fp);//关闭输出文件
	fclose(in.fp);
	in.fp = 0;
	memcpy(t, cv, sizeof(struct COM_VAR));//保护现场
	for (i = 0;i < lib.size; i++)
	{
		if (!ChDir(libdata)) Error(libdata, E_CATA);
		if (!(fp = fopen(lib.name[i], "r"))) Error(lib.name[i], E_OPEN);//消息框
		fread(&add, 1, 4, fp);
		fseek(fp, add, 0);//调转到代码区
		fread(&j, 1, 2, fp);
		cp.add[VGLOBOLE] = (tv=cp.add[VGLOBOLE] - 0x2000) + j;//偏移
		add = cp.offset;
		while (!feof(fp))
		{
			if ((cmd = getc(fp)) == 65)
			{
				fread(&c, 1, 4, fp);
				if ((c&0xffff) < 0x7000 && (c&0xffff) >= 0x2000) c = c + tv;
				if (!cp.fp)
				{
					if (ChPath(cpldata)) Error(cpldata, E_CATA);
					if (!(cp.fp = fopen("cpl.tmp","w+")))
					{
						fclose(fp);
						Error("cpl.tmp", E_CREAT);//创建临时文件
					}
				}
				putc(65, cp.fp);
				fwrite(&c, 1, 4, cp.fp);
				c = (c >> 16)&0xffff;
				for (j = 0; j < c; j++)
				{
					putc(getc(fp), cp.fp);
				}
				continue;
			}
			if (cmd == 62)
			{
				fseek(fp, -1, 1);
				break;
			}
			fclose(fp);
			Error(lib.name[i], E_OFFSET);//错误
		}
		while (!feof(fp))
		{
			Put(cmd = getc(fp), 1);
			if (cmd == 1)
			{
				Put(getc(fp), 1);//1 Byte
				continue;
			}
			if (cmd == 3)//4 B
			{
				fread(&j, 1, 4, fp);
				if ((type == 1 | type == 2 | type == 4) && (j >= 0x2000 && j <= 0x7000)) j = j + tv;
				Put((j&0xffff)|(type << 16), 4);
				continue;
			}
			if (cmd == 65)//4 Byte
			{
				fread(&c, 1, 4, fp);
				if ((c&0xffff) < 0x7000 && (c&0xffff) >= 0x2000)
				{
					Put(c + tv, 4);
				}
				else
				{
					Put(c, 4);
				}
				c = (c >> 16)&0xffff;
				for (j = 0; j < c; j++)
				{
					Put(getc(fp), 1);
				}
				continue;
			}
			if (cmd == 13)//字符串
			{
				do{
					Put(cmd = getc(fp), 1);
				} while (cmd);
				continue;
			}
			if (!cmd)
			{
				continue;
			}
			if (cmd <= 25 | cmd == 60 | (cmd >= 69 && cmd <= 81))//2 Byte
			{
				fread(&j, 1, 2, fp);
				if ((cmd <= 12 | cmd == 23) && cmd != 2)
				{
					if (j >= 0x2000 && j <= 0x7000) j = j + tv;
				}
				Put(j, 2);
				continue;
			}
			if (cmd >= 57 && cmd <= 61)//跳转
			{
				c = 0;
				fread(&c, 1, 3, fp);
				c = c + add;
				Put(c, 3);
				continue;
			}
			if (cmd == 62)//函数头
			{
				fread(&c, 1, 3, fp);
				Put(c, 3);
				if (getc(fp) == 0xff) continue;
				fread(cv, 1, sizeof(struct COM_VAR), fp);
				cv.v = cv.v + add;
				cv.d[0] = ++cp.fn;
				if (SavVar())
				{
					fclose(fp);
					Error(cv.n, E_RVAR);
				}
				continue;
			}
			if ((cmd > 83 && cmd < 128) | cmd > 223)//错误
			{
				fclose(fp);
				Error(lib.name[i], E_OFFSET);
			}
		}
		fclose(fp);
	}
	memcpy(cv, t, sizeof(struct COM_VAR));//恢复现场
	Recover(fadd);//恢复打开文件
}
//*******************************************************提取系统*******************************************************//
void Str_Get()/*词汇提取 保存到cv.n*/
{
	char i;

	i = 0;
	while (*in.p == '_' | isalnum(*in.p))
	{
		cv.n[i++] = *in.p++;
	}
	cv.n[i] = 0;
}

long Num_Get()/*数字提取*/
{
	char ch, rad;
	int sign;
	long num;

	num = 0;
	sign = 1;
	if (*in.p == '+')//符号判断
	{
		in.p++;
	}
	else if (*in.p == '-')
	{
		sign = -1;
		in.p++;
	}
	if (*in.p == '0')//进制
	{
		if (tolower(*++in.p) == 'x')
		{
			rad = 16;
			in.p++;
		}
		else
		{
			rad = 8;
		}
	}
	else
	{
		rad = 10;
	}
	while (isxdigit(*in.p))
	{
		ch = *in.p++;
		if (isdigit(ch))
		{
			num = num * rad + (ch&0xf);
		}
		else if (isxdigit(ch))
		{
			if (rad == 16)
			{
				num = num * rad + tolower(ch) - 87;
			}
			else
			{
				Error(0, E_CONST);
			}
		}
	}
	if (isalnum(*in.p)) Error(0, E_CONST);
	return(num * sign);
}

long Calc()//简单计算器
{
	long n[3];//数据堆栈
	char o[3];//符号堆栈
	char i, j;//数据指针,符号指针

	i = j = 0;
	if (*in.p != '(') n[i++] = Num_Get();
	for (;;)
	{
		if (isdigit(*in.p))
		{
			n[i++] = Num_Get();
		}
		else if (*in.p == '(')//压入数据
		{
			in.p++;
			n[i++] = Calc();
			if (*in.p++ != ')') Error(0, E_CONSTS);
		}
		else
		{
			while(j && i >= 2)//弹栈
			{
				if ((o[j - 1] == '+' | o[j - 1] == '-') && strchr(sign4 + 2, *in.p)) break;
				i--;
				if		(o[--j] == '+')	n[i - 1] = n[i - 1] + n[i];
				else if	(o[j] == '-')	n[i - 1] = n[i - 1] - n[i];
				else if	(o[j] == '*')	n[i - 1] = n[i - 1] * n[i];
				else if	(o[j] == '/')	n[i - 1] = n[i - 1] / n[i];
				else if	(o[j] == '%')	n[i - 1] = n[i - 1] % n[i];
			}
			if (strchr(sign4, *in.p))//压入符号
			{
				o[j++] = *in.p++;
			}
			else
			{
				return(n[0]);
			}
		}
	}
}

void LoadFile()
{
	char fp;
	long start, size, fadd;
	char i, s[60];

	if (*in.p++ != '(' | *in.p++ != '"') Error(0, E_GRAMMAR);
	start = size = i = 0;
	while (*in.p != '"' && i < ' ') s[i++] = *in.p++;
	s[i] = 0;//提取文件名
	if (*++in.p == ',')
	{
		in.p++;
		start = Calc();
		if (*in.p == ',')
		{
			in.p++;
			size = Calc();
		}
	}
	if (*in.p++ != ')') Error(0, E_GRAMMAR);
//--------------------------------------------------------------
	fadd = ftell(in.fp);//关闭输出文件
	fclose(in.fp);
	in.fp = 0;
	if (!(fp = fopen(s, "r"))) Error(s, E_OPEN);
	if (size <= 0)
	{
		size = fseek(fp, 0, 2);
		if (start > 0) size = size - start;
		rewind(fp);
	}
	if (start > 0) fseek(fp, start, 0);
	Put(size, 2);
	CUSH_Sav();//写入剩余在缓冲区的代码
	cp.offset = cp.offset + size;
	while (size)//拷贝
	{
		if (size >= FB_C_REL)
		{
			out.p = FB_C_REL;
		}
		else
		{
			out.p = size;
		}
		size = size - out.p;
		fread(FB_CUSH, 1, out.p, fp);
		if (fwrite(FB_CUSH, 1, out.p, out.fp) != out.p)
		{
			fclose(fp);
			Error(out.name, E_WRITE);
		}
	}
	fclose(fp);
	out.p = 0;
	Recover(fadd);//恢复打开文件
}

void LoadData()
{
	long offset;

	if (*in.p++ != '=') Error(0, E_GRAMMAR);
	if (isalpha(*in.p))
	{
		Str_Get();
		if (!strcmp(cv.n, "load"))
		{
			LoadFile();
		}
		else
		{
			Error(0, E_GRAMMAR);
		}
	}
	else
	{
		offset = cp.offset;
		Put(cv.b, 2);
		if (cv.t == (VGLOBOLE	+UNIT_VAR) | isdigit(*in.p))
		{
			Put(Calc(), cv.b);
		}
		else
		{
			W_Jmp(offset, Var_Init(), 2);
		}
		if (cp.i == VGLOBOLE) cp.ary = cp.ary + cp.offset - offset + 3;
	}
}

long Sign_Get()/*符号提取*/
{
	char s[3];//缓冲
	int p;//地址值或位置

	if (p = strchr(sig, *in.p))//."{}[](),;
	{
		cp.o.g = 10;
		if (p == sig + 3) cp.o.g = 1;
		if (!*++in.p) CUSH_Get();//调整
		return(p - sig + POINT);
	}
	memcpy(s, in.p++, 2);
	s[2] = 0;
	if (p = strstr(bol, s))
	{
		in.p++;
	}
	else
	{
		s[1] = '@';
		if (!(p = strstr(bol, s)))
		{
			if (s[0] == '#')//编译命令处理
			{
				Str_Get();
				if (!strcmp(cv.n,"loadall"))
				{
					cp.la = 1;
					if (*in.p == ' ') in.p++;
					return(LVM_NULL);
				}
				if (!strcmp(cv.n, "code"))
				{
					if (*in.p != '{') Error(0, E_GRAMMAR);//语法错误
					while(*in.p++ != '}')
					{
						if (*in.p == '"')//字符串
						{
							while(*++in.p != '"')
							{
								if (!*in.p) CUSH_Get();
								if (*in.p == 92)
								{
									if (p = strchr(sign2, *++in.p))
									{
										Put(sign3[p - sign2], 1);
										continue;
									}
								}
								Put(*in.p, 1);
							}
							in.p++;
						}
						else
						{
							Put(Calc(), 1);//数字
						}
						if (!*in.p) CUSH_Get();//调整
					}
					if (*in.p++ != ';') Error(0, E_GRAMMAR);//语法错误
					if (!*in.p) CUSH_Get();//调整
					return(LVM_NULL);
				}
				if (!strcmp(cv.n, "loaddata"))
				{
					if (*in.p++ != ' ') Error(0, E_NOPARA);
					Put(65, 1);
					if (*in.p == '_' | isalpha(*in.p))//变量
					{
						Str_Get();
						if (!SeekVar())
						{
							if (cv.t&1) Error(0, E_GRAMMAR);
						}
						else
						{
							Error(cv.n, E_UVAR);
						}
					}
					else
					{
						cv.v = Calc();
						cv.b = 1;
						cv.t = 255;
					}
					Put(cv.v, 2);
					LoadData();
					if (*in.p++ != ';') Error(0, E_GRAMMAR);//语法错误
					if (!*in.p) CUSH_Get();//调整
					return(LVM_NULL);
				}
				if (!strcmp(cv.n, "begin"))
				{
					if (*in.p++ != ' ') Error(0,E_NOPARA);
					cp.add[VBACKUP] = cp.add[cp.i];
					cp.add[cp.i] = Calc();
					if (*in.p == ' ') in.p++;
					return(LVM_NULL);
				}
				if (!strcmp(cv.n, "end"))
				{
					cp.add[cp.i] = cp.add[VBACKUP];
					if (*in.p == ' ') in.p++;
					return(LVM_NULL);
				}
				if (!strcmp(cv.n, "skip"))
				{
					if (*in.p++ != ' ') Error(0, E_NOPARA);
					cp.add[cp.i] = cp.add[cp.i] + Calc();
					if (*in.p == ' ') in.p++;
					return(LVM_NULL);
				}
				if (!strcmp(cv.n, "delete"))
				{
					if (*in.p++ != ' ') Error(0, E_NOPARA);
					if (*in.p != '_' && !isalpha(*in.p)) Error(0, E_SENTE);
					Str_Get();
					if (!DeleteVar()) Error(cv.n, E_UVAR);
					if (*in.p == ' ') in.p++;
					return(LVM_NULL);
				}
				//if (!strcmp(cv.n, "linkfile"))
				//{
					
				//}
			}
			if (s[0] == ' ') Error(0, E_ANALY);//解析错误
			Error(*(in.p - 1), E_USIGN);//不支持的符号
		}
	}
	p = (p - bol) / 3;
	cp.o.g = grad[p];
	cp.o.c = code[p];
	if (p == 2 | p == 3)//a++,a--与++a,--a分离
	{
		if ((isalnum(p = *(in.p - 3)) | strchr(sign1, p)) && !isalnum(*in.p)) cp.o.c = cp.o.c + 2;
	}
	return(LVM_SIGN);//*,-和&在Exp_deal()中分离
}
//"!@$~@$++$--$*@$/@$%@$+@$-@$<<$>>$==$!=$<=$>=$>@$<@$&@$|@$^@$&$||$=$";//符号表
//  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
//  2  2  2  2  3  3  3  4  4  5  5  6  6  6  6  6  6  7  7  7  8  8  9
//-------------------------------------------------------变量注册
int Var_Init()
{
	long start;//起始地址(用来计算当前维个数)
	int m;//临时变量

	start = cp.offset;//初始化
	if (*in.p == '"')//字符串
	{
		while (*++in.p != '"')
		{
			if (!*in.p) CUSH_Get();
			if (*in.p == 92)
			{
				if (m = strchr(sign2, *++in.p))
				{
					Put(sign3[m - sign2], 1);
					continue;
				}
			}
			Put(*in.p, 1);
		}
		Put(0, 1);
		if (cv.d[0] > 1)//补充
		{
			m = cv.d[cv.d[0] - 1] + start - cp.offset;
			if (m > 0) Move(m);
		}
	}
	else
	{
		for (in.p++;;)
		{
			if (!isdigit(*in.p))
			{
				if (*in.p == ',')
				{
					if (!*++in.p) CUSH_Get();
					continue;
				}
				if (*in.p == '-')
				{
					Put(Num_Get(), cv.b);
					continue;
				}
				if (strchr(sign26, *in.p))
				{
					Var_Init();
					continue;
				}
				if (*in.p == '}')
				{
					break;
				}
			}
			Put(Num_Get(), cv.b);
		}
	}
	in.p++;//跳过}",
	return(cp.offset - start);
}

int tVar_Init()
{
	long start;//起始地址(用来计算当前维个数)
	int m;//临时变量

	start = ftell(cp.fp) + out.p;//初始化
	if (*in.p == '"')//字符串
	{
		while(*++in.p != '"')
		{
			if (!*in.p) CUSH_Get();
			if (*in.p == 92)
			{
				if (m = strchr(sign2, *++in.p))
				{
					tPut(sign3[m - sign2], 1);
					continue;
				}
			}
			tPut(*in.p, 1);
		}
		tPut(0, 1);
		if (cv.d[0] > 1)//补充
		{
			m = cv.d[cv.d[0] - 1] + start - ftell(cp.fp) - out.p;
			if (m > 0) tMove(m);
		}
	}
	else
	{
		for (in.p++;;)
		{
			if (!isdigit(*in.p))
			{
				if (*in.p == ',')
				{
					if (!*++in.p) CUSH_Get();
					continue;
				}
				if (*in.p == '-')
				{
					tPut(Num_Get(), cv.b);
					continue;
				}
				if (strchr(sign26, *in.p))
				{
					tVar_Init();
					continue;
				}
				if (*in.p == '}')
				{
					break;
				}
			}
			tPut(Num_Get(), cv.b);
		}
	}
	in.p++;//跳过}",
	return(ftell(cp.fp) + out.p - start);
}

void Var_Write(char flag, char mode, int sn)/*结构成员标志(0:普通变量),类型 结构标志(声明)*/
{
	char def;//数组下标缺省标志
	long offset;//数组下标缺省地址(配合def)
	char type;//变量/数组
	int len, i;//变量长度,临时变量

	if (*in.p == '&') mode = mode + V_POINT;
 //else if (*in.p == '*')
	do{
		in.p++;
		Str_Get();//提取变量
		if (*in.p != '(')//变量
		{
			len = 1;
			def = 0;//初始化(长度:1,没有缺省)
			if (*in.p == '[')//数组
			{
				type = UNIT_ARR;
				memset(cv.d, 0, DIM_MAX * 2);
				if (*++in.p == ']')//提取最高维
				{
					def = 1;
				}
				else
				{
					len = Calc();
				}
				for (cv.d[0] = 1; *++in.p == '['; cv.d[0]++)
				{
					if (cv.d[0] > DIM_MAX - 2) Error(cv.n, E_WBIG);
					in.p++;
					len = (cv.d[cv.d[0]] = Calc()) * len;
				}
			}
			else
			{
				type = UNIT_VAR;//变量
			}
			if (*in.p == '=')//赋值
			{
				in.p++;//跳过=
				if (mode&1)
				{
					if (!cp.sf)
					{
						if (type != UNIT_VAR) Error(cv.n, E_PVAR);//内部不是变量的不能初始化
						i = cv.b;
						if (mode >= V_POINT) i = 2;//指针
						Put(3, 1);
						Put(cp.add[cp.i]|((i|0x80) << 16), 4);
						if (i > 2)
						{
							Put(3, 1);
						}
						else
						{
							Put(i, 1);
						}
						Put(Calc(), i);
						Put(0x3835, 2);
						goto VAR_SET;
					}
				}
				if (jp_var)//不是在顶部初始化的
				{
					if (!cp.fp)
					{
						if (ChPath(cpldata)) Error(cpldata, E_CATA);
						if (!(cp.fp = fopen("cpl.tmp", "w+"))) Error("cpl.tmp", E_CREAT);//创建临时文件
					}
					CUSH_Sav();//写入剩余在缓冲区的代码(底下程序要用到缓冲区)
					tPut(65, 1);
					tPut(cp.add[cp.i], 2);
					offset = ftell(cp.fp) + out.p;
					tPut(cv.b * len, 2);
					if (type == UNIT_VAR)
					{
						tPut(Calc(), cv.b);
					}
					else
					{
						i = tVar_Init();//写入数据
						Savtmp();//写入剩余在缓冲区的代码到临时文件
						fseek(cp.fp, offset, 0);
						fwrite(&i, 1, 2, cp.fp);
						fseek(cp.fp, 0, 2);//写入大小
						if (def)
						{
							len = i / cv.b;
						}
						else if (i > len * cv.b)
						{
							Error(cv.n, E_LONG);
						}
					}
					Savtmp();//写入剩余在缓冲区的代码到临时文件
				}
				else
				{
					Put(65, 1);
					Put(cp.add[cp.i], 2);
					offset = cp.offset;
					Put(cv.b * len, 2);
					if (type == UNIT_VAR)
					{
						Put(Calc(), cv.b);
					}
					else
					{
						W_Jmp(offset,i = Var_Init(), 2);
						if (def)
						{
							len = i / cv.b;
						}
						else if (i > len * cv.b)
						{
							Error(cv.n, E_LONG);
						}
					}
					cp.ary = cp.ary + cp.offset - offset + 3;
				}
			}
			else if (def)
			{
				if (mode < V_POINT) Error(cv.n, E_SIZE);
			}
VAR_SET:
			cv.d[DIM_MAX - 1] = len = cv.b * len;
			if (mode >= V_POINT) len = 2;//变量占用空间
			cv.t = mode + type;//cv.type
			cv.v = (sn << 16)|cp.add[cp.i];//cv.value
			if (cp.i == VTEMP)
			{
				cv.n[i = strlen(cv.n)] = cp.sn;
				cv.n[i + 1] = 0;//标记名称
				if (flag == UNIT_STU) goto ADD;
				cv.v = cv.v&0xffff0000;//只是清除地址部分
				if (len > cp.add[cp.i]) cp.add[cp.i] = len;
			}
			else
			{
ADD:
				cp.add[cp.i] = cp.add[cp.i] + len;//地址增加
			}
		}
		else//子程序声明
		{
			i = in.p++;
			cv.t = LVM_SUB;
			cv.d[cv.v=0] = ++cp.fn;//函数模式,标志
			for (cv.d[1] = 0; *in.p++ != ')';)//参数个数(cv.d)
			{
				if (*in.p == ',' | *in.p == ')') cv.d[1]++;
			}
			if (*in.p != ';')//子程序
			{
				in.p = i;
				return;
			}
		}
		if (SavVar()) Error(cv.n, E_RVAR);//注册
	} while (*in.p == ',');
	while (*in.p == ';')//调整
	{
		if (!*++in.p) CUSH_Get();
	}
	Progress(ftell(in.fp) - strlen(in.p), in.size, 0);//进度
}

int ChkByte()/*判断字节*/
{
	if (!strcmp(cv.n, sign21))			return(1);
	else if (!strcmp(cv.n, sign22))		return(2);
	else if (!strcmp(cv.n, sign23))		return(4);
	else if (!strcmp(cv.n, sign24))		return(0);
	else if (!strcmp(cv.n, sign25))		return(UNIT_STU);
	else if (!strcmp(cv.n, "union"))	return(UNIT_UNI);
	else if (!strcmp(cv.n, "static"))	return(-1);
	else								return(-2);
}

void Par_Write(char mode, int sn)/*类型 结构标志(声明)*/
{
	char type;//变量/数组

	if (*in.p++ == '&') mode = mode + V_POINT;
	Str_Get();//提取变量
	if (*in.p == '[')//数组
	{
		type = UNIT_ARR;//数组
		memset(cv.d, 0, DIM_MAX * 2);
		if (*++in.p != ']') Calc();//初始化
		for (cv.d[0] = 1; *++in.p == '['; cv.d[0]++)
		{
			if (cv.d[0] > DIM_MAX - 2) Error(cv.n, E_WBIG);
			in.p++;
			cv.d[cv.d[0]] = Calc();
		}
	}
	else
	{
		type = UNIT_VAR;//变量
	}
	cv.t = mode + type;//cv.type
	cv.v = (sn << 16)|cp.add[cp.i];//cv.value
	cp.add[cp.i] = cp.add[cp.i] + 4;//地址增加
	if (SavVar()) Error(cv.n, E_RVAR);//注册
}

void Head_Write()
{
	struct COM_VAR e;//引用体,函数
	char type;//类型(外,内)
	char def, flag;//引用名缺省标志,(普通,结构成员)标志
	int pmem;//临时成员地址

	for (type = cp.i;;)//类型(外,内)
	{
		if ((cv.b = ChkByte()) < -1) break;//记录字节(cv.byte)
		if (cv.b < 0)//static
		{
			cp.sf = type|(cp.i << 4);
			type = cp.i = VGLOBOLE;//切换变量空间
			in.p++;
			Str_Get();
			continue;
		}
		if (cv.b <= 4)
		{
			Var_Write(0, type, 0);//普通变量
			if (*in.p == '(')//子程序
			{
				if (!jp_var)
				{
					if (cp.la) Put(68, 1);//#loadall
					jp_var = cp.offset + 1;
					Put(0x3b00003c, 7);//变量总空间
					if (lib.size) LoadLib();//链接库
				}
				cp.sub = cv.b;//记录当前fun是否有返回值
				cp.ma = 0;
				if (!strcmp(cv.n, sign5))//当前函数是否是main
				{
					cp.ma = cp.mai = 1;
					W_Jmp(jp_var + 3, cp.offset, 3);
				}
				cv.v = cp.offset;//记录函数地址(cv.value)
				if (SavVar())//插入新函数
				{
					cp.fn--;
					memcpy(e, cv, sizeof(struct COM_VAR));
					ReadVar(var.i);//调整 保存cv
					if (cv.v) Error(cv.n, E_RSUB);
					if (cv.b != e.b | cv.d[1] != e.d[1]) Error(cv.n, E_DEFI);//合法性检查
					RenewVar(var.i, &e.v, 4);//更新变量表
					do {} while (SeekJmp(cv.d[0] + (JP_SUB << 16 - JP_TYP), 0));//写入函数入口地址
				}
				var.bh = var.bt;
				var.ph = var.pt;
				var.ptr[var.ph] = var.bh;//建立变量表的分界线
				cp.ts = cp.sn;
				type = cp.i = VPART;
				in.p++;//进入函数内部
				e.d[1] = cv.d[1];//保护
				while (*in.p != ')')//函数参数个数(e.d)
				{
					Str_Get();
					cv.b = ChkByte();//读取类型
					if (cv.b < 0) Error(cv.n, E_UTYPE);//未定义的类型
					if (cv.b <= 4) Par_Write(type, 0);//基本变量
					else//构造体
					{
						in.p++;
						Str_Get();//提取引用名
						if (SeekVar()) Error(cv.n, E_USTU);//未定义
						Par_Write((cv.t&0xfe) + type - UNIT_QFM, cv.v);
					}
					if (*in.p != ')') in.p++;//跳过逗号,调整
				}
				jp_sub = cp.offset + 1;
				Put(62, 3);
				Put(e.d[1], 1);
				in.p = in.p + 2;//记录函数头 跳过{
			}
		}
		else//结构
		{
			if (*in.p == ' ')
			{
				in.p++;
				Str_Get();//提取引用名
				if (*in.p == ' ' | *in.p == '&')//结构声明(变量,指针)
				{
					if (SeekVar()) Error(cv.n, E_USTU);//未定义
					Var_Write(0, (cv.t&0xfe) + type - UNIT_QFM, cv.v);
					goto END;
				}
				strcpy(e.n, cv.n);
				e.t = type + cv.b + UNIT_QFM;
				def = 1;//保存引用名,类型 没有缺省
			}
			else//记录类型 缺省引用名
			{
				e.t = type + cv.b;
				def = 0;
			}
			type = cp.i;
			cp.add[cp.i = VTEMP] = pmem = 0;
			flag = cv.b;
			cp.sn++;//保存cp.i 初始化 增加
			for (in.p++; *in.p != '}';)
			{
				Str_Get();
				cv.b = ChkByte();//提取类型
				if (cv.b < 0) Error(cv.n,E_UTYPE);//未定义的类型
				if (cv.b <= 4) Var_Write(flag, type, 0);//普通变量
				else
				{
					in.p++;
					Str_Get();//提取引用名
					if (SeekVar())
					{
						if (strcmp(e.n, cv.n)) Error(cv.n, E_USTU);//未定义
						if (!pmem) pmem = var.bt;//留着底下更新
						cv.v = cp.sn;
						cv.t = e.t;
					}
					Var_Write(flag, (cv.t&0xfe) + type - UNIT_QFM, cv.v);
				}
			}
			cv.b = cp.add[cp.i];
			cp.i = type;//恢复cp.i
			if (pmem) RenewMember(pmem);//更新成员数据
			if (def)//没有缺省
			{
				e.b = cv.b;
				e.v = cp.sn;
				memcpy(cv, e, sizeof(struct COM_VAR));//切换
				if (SavVar()) Error(cv.n, E_RSTU);//重复定义
				if (*(in.p + 1) != ';')
				{
					e.t = e.t - UNIT_QFM;
					goto W_STU;
				}
				if (!*(in.p = in.p + 2)) CUSH_Get();//调整
			}
			else
			{
W_STU:
				Var_Write(0,e.t,cp.sn);//记录结构
			}
		}
END:
		if (cp.sf)//static标志清0
		{
			cp.i = cp.sf >> 4;
			type = cp.sf&0xf;
			cp.sf = 0;
		}
		Str_Get();//提取类型
	}
	in.p = in.p - strlen(cv.n);//调整
}

int Get_Mark()/*词汇提取模块*/
{
START:
	memset(cp.o, 0, sizeof(struct OPERATOR));//初始化运算符
	if (*in.p == '_' | isalpha(*in.p))//词汇
	{
		Str_Get();
		if (ChkByte() != -2)//变量注册
		{
			Head_Write();
			goto START;
		}
		if (*in.p == ':')//标号
		{
			in.p++;
			cv.t = LVM_LABEL;
			cv.v = cp.offset;
			cv.d[0] = cp.ln++;//记录标号
			if (SavVar())//插入
			{
				cp.ln--;
				ReadVar(var.i);
				if (cv.v) Error(cv.n, E_RLAB);//合法性检查
				RenewVar(var.i, &cp.offset, 3);//更新变量表（记录标号地址）
				do {} while(SeekJmp(cv.d[0] + (JP_LABEL << 16 - JP_TYP), 0));//写入标号地址
			}
			goto START;
		}
		if (!SeekVar())					return(cv.t);//变量,函数,子程序
		if (!strcmp(cv.n, sign6))		return(LVM_IF);//if
		if (!strcmp(cv.n, sign7))		return(LVM_ELSE);//else
		if (!strcmp(cv.n, sign8))		return(LVM_WHILE);//while
		if (!strcmp(cv.n, sign9))		return(LVM_FOR);//for
		if (!strcmp(cv.n, sign10))		return(LVM_RET);//return
		if (!strcmp(cv.n, sign11))		return(LVM_DO);//do
		if (!strcmp(cv.n, sign12))		return(LVM_BRK);//break
		if (!strcmp(cv.n, sign13))		return(LVM_CONT);//continue
		if (!strcmp(cv.n, sign14))		return(LVM_GOTO);//goto
		if (!strcmp(cv.n, "sizeof"))	return(LVM_SIZE);//sizeof
		if (!strcmp(cv.n, "_TEXT"))		return((26	+	_LVM_T));
		if (!strcmp(cv.n, "_GRAPH"))	return((27	+	_LVM_T));
		if (!strcmp(cv.n, "_GBUF"))		return((66	+	_LVM_T));
#if WQX == 0
		if (!strcmp(cv.n, "System"))
		{
			in.p++;
			Str_Get();
			cv.t = LVM_FUN;
			cv.b = 1;
			cv.v = 211;
			cv.d[1] = 0;
			if (!strcmp(cv.n, "GetPID"))
			{
				cv.d[0] = 0x0001;
			}
			else if (!strcmp(cv.n, "SetBrightness"))
			{
				cv.d[1] = 1;
				cv.d[0] = 0x0101;
			}
			else if (!strcmp(cv.n, "GetBrightness"))
			{
				cv.d[0] = 0x0201;
			}
			else if (!strcmp(cv.n, "ComOpen"))
			{
				cv.d[0] = 0x0301;
			}
			else if (!strcmp(cv.n, "ComClose"))
			{
				cv.d[0] = 0x0401;
			}
			else if (!strcmp(cv.n, "ComWaitReady"))
			{
				cv.d[0] = 0x0501;
			}
			else if (!strcmp(cv.n, "ComSetTimer"))
			{
				cv.d[1] = 1;
				cv.d[0] = 0x0601;
			}
			else if (!strcmp(cv.n, "ComGetc"))
			{
				cv.d[0] = 0x0701;
			}
			else if (!strcmp(cv.n, "ComPutc"))
			{
				cv.d[1] = 1;
				cv.d[0] = 0x0801;
			}
			else if (!strcmp(cv.n, "ComRead"))
			{
				cv.d[1]=2;
				cv.d[0]=0x0901;
			}
			else if (!strcmp(cv.n, "ComWrite"))
			{
				cv.d[1] = 2;
				cv.d[0] = 0x0a01;
			}
			else if (!strcmp(cv.n, "ComXor"))
			{
				cv.d[1] = 2;
				cv.d[0] = 0x0b01;
			}
			else if (!strcmp(cv.n, "RamRead"))
			{
				cv.d[1] = 3;
				cv.d[0] = 0x0c01;
			}
			else if (!strcmp(cv.n, "DiskReclaim"))
			{
				cv.d[0] = 0x0d01;
			}
			else if (!strcmp(cv.n, "DiskCheck"))
			{
				cv.d[0] = 0x0e01;
			}
			else if (!strcmp(cv.n, "FlmDecode"))
			{
				cv.d[1] = 2;
				cv.d[0] = 0x0f01;
			}
			else if (!strcmp(cv.n, "SndPlay"))
			{
				cv.d[1] = 2;
				cv.d[0] = 0x1001;
			}
			else if (!strcmp(cv.n, "SndOpen"))
			{
				cv.d[0] = 0x1101;
			}
			else if (!strcmp(cv.n, "SndClose"))
			{
				cv.d[0] = 0x1201;
			}
			else if (!strcmp(cv.n, "SndIfEnd"))
			{
				cv.d[0] = 0x1301;
			}
			else if (!strcmp(cv.n, "PY2GB"))
			{
				cv.d[1] = 3;
				cv.d[0] = 0x1401;
			}
			else if (!strcmp(cv.n, "SndPlayFile"))
			{
				cv.d[1] = 3;
				cv.d[0] = 0x1501;
			}
			else if (!strcmp(cv.n, "SndSetVolume"))
			{
				cv.d[1] = 1;
				cv.d[0] = 0x1601;
			}
			else if (!strcmp(cv.n, "SndGetVolume"))
			{
				cv.d[0] = 0x1701;
			}
			else if (!strcmp(cv.n, "SndStop"))
			{
				cv.d[0] = 0x1801;
			}
			else if (!strcmp(cv.n, "SndPause"))
			{
				cv.d[0] = 0x1901;
			}
			else if (!strcmp(cv.n, "SndResume"))
			{
				cv.d[0] = 0x1a01;
			}
			else if (!strcmp(cv.n, "SndGetPlay"))
			{
				cv.d[0] = 0x1b01;
			}
			else if (!strcmp(cv.n, "Idle"))
			{
				cv.d[0] = 0x1c01;
			}
			else
			{
				Error(cv.n,E_UVAR);//变量未定义
			}
			return(LVM_FUN);
		}
#endif
		Error(cv.n,E_UVAR);//变量未定义
	}
	else if (isdigit(*in.p))//数字
	{
		cv.v = Num_Get();
		return(NUMBER);
	}
	else
	{
		return(Sign_Get());
	}
}

//******************************************************表达式分析******************************************************//
void Exp_deal(char cmd)/*表达式编译模块*/
{
	struct TMP_VAR e;//临时接口
	long ev;//结构地址
	int vi;//临时变量链表指针
	char i, j, k, f;//临时变量
	char tv, sv, so;//当前临时变量栈指针,当前变量栈指针,运算栈指针
	struct OPERATOR o[8];//运算栈

	memset(e, 0, sizeof(struct COM_VAR) + 8 * sizeof(struct OPERATOR) + 13);//初始化
START:
//---------------------------------------------------------监视---------------------------------------------------------//
 //if (5*in.size<6*(ftell(in.fp)-strlen(in.p)))Look(sv,so,o,cmd,0);
//---------------------------------------------------------变量---------------------------------------------------------//
	if (cmd <= V_POINT + (VPART		+UNIT_UNI+UNIT_ARR))//变量,数组,结构体,共用体,引用
	{
		if (cmd <= (VPART		+UNIT_VAR))//cmd:0 全局变量,1:局部变量[用到的临时变量:k,j]
		{
			j = cmd;
			cmd = Get_Mark();//保护,读取下一个符号
VAR_DEAL:
			cp.hp++;//堆栈加1
			sv++;
			if (so)//等级转换
			{
				if (strchr(sign18, k = o[so - 1].c)) goto VAR_GIVE;//++a,--a
				if (k == 20)//&
				{
					so--;
					Put((j * 23 + 2)|(cv.v << 8), 3);
					goto POP;
				}
				if (k == 54 && cp.o.g == 9)//*a=
				{
					Put(((cv.b >> 1) + j * 10 + 4)|(cv.v << 8), 3);
					goto POP;
				}
			}
			if (strchr(sign19, cp.o.g))//赋值,a++,a--
			{
VAR_GIVE:
				Put(3, 1);
				Put(cv.v|(cv.b << 16)|(j << 23), 4);
				if (cp.o.g == 2)
				{
					Put(cp.o.c, 1);
					cmd = Get_Mark();
				}
				goto POP;
			}
			Put(((cv.b >> 1) + j * 10 + 4)|(cv.v << 8), 3);
			goto POP;
		}
		if (cmd <= (VPART		+UNIT_ARR))//cmd:4 全局数组,5:局部数组[用到的临时变量:vi,j,i,k]
		{
			if (*in.p != '[')
			{
				if (cmd == (VGLOBOLE	+UNIT_ARR)) goto NUM_DEAL;//当成数字处理
				cp.hp++;//堆栈加1
				sv++;
				Put(25|(cv.v << 8), 3);
				cmd = Get_Mark();
				goto POP;
			}
			in.p++;
			memcpy(e, cv, sizeof(struct TMP_VAR));
			vi = var.i;
			j = cmd;//保护,读取下一个符号
			sv++;//堆栈加1
			i = 0;
			do {
				Exp_deal(Get_Mark());//下标分析
				if (i)
				{
					Put(33, 1);
					cp.hp--;
				}
				if (++i < e.d[0])
				{
					Put(71, 1);
					Put(e.d[i], 2);
				}
				else if (i > e.d[0])
				{
					Error(var.ptr[vi], E_OARR);
				}
			} while ((cmd = Get_Mark()) == L_M_BRAC);
			if (i == e.d[0])
			{
				if (e.b > 1) Put(74|(e.b << 7), 3);
				if (so)//等级转换
				{
					if (strchr(sign18, k = o[so - 1].c)) goto ARR_GIVE;//++a,--a
					if (k == 20)//&
					{
						so--;
						Put((j + 19)|(e.v << 8), 3);
						goto POP;
					}
					if (k == 54 && cp.o.g == 9)//*
					{
						Put(((e.b >> 1) + j * 10 - 33)|(e.v << 8), 3);
						goto POP;
					}
				}
				if (strchr(sign19, cp.o.g))//赋值,a++,a--
				{
ARR_GIVE:
					Put(((e.b >> 1) + j * 10 - 30)|(e.v << 8), 3);
					if (cp.o.g == 2)
					{
						Put(cp.o.c, 1);
						cmd = Get_Mark();
					}
					goto POP;
				}
				Put(((e.b >> 1) + j * 10 - 33)|(e.v << 8), 3);
				goto POP;
			}
			for (k = i + 1; k < e.d[0]; k++)
			{
				e.d[i] = e.d[i] * e.d[k];
			}
			Move(-2);
			Put(e.d[i] * e.b, 2);
			Put((j + 19)|(e.v << 8), 3);
			goto POP;
		}
		if (cmd <= (VPART		+UNIT_UNI+UNIT_ARR) | cmd >= V_POINT + (VGLOBOLE	+UNIT_STU+UNIT_VAR))
		//cmd:6~13 24~31 结构体(指针)和共用体(指针)[用到的临时变量:ev,vi,j,i,k,f,tv]
		{
			j = cmd&1;//转换
			if (!strchr(sign20, *in.p))
			{
				cv.v = cv.v&0xffff;
				if (cmd >= V_POINT + (VGLOBOLE	+UNIT_STU+UNIT_VAR)) goto ADPT_GET;//指针
				if (j)
				{
					cp.hp++;//堆栈加1
					sv++;
					Put(25|(cv.v << 8), 3);
					cmd = Get_Mark();
					goto POP;
				}
				goto NUM_DEAL;//当成数字处理
			}
			memcpy(e, cv, sizeof(struct TMP_VAR));//保护
			ev = e.v;
			e.v = f = 0;
			tv = sv;
STU_LOOP:
			if (e.t >= V_POINT)//指针
			{
				f = f|1;//标志
				if (!strchr(sign20, *in.p))
				{
					if (so && !i)
					{
						if (o[so - 1].c == 20)
						{
							so--;
							e.b = 2;
							e.t = (VPART		+UNIT_VAR);
							goto SPT_START;
						}
					}
				}
				if (sv == tv)
				{
					cp.hp++;
					sv++;
					Put(j * 10 + 5, 1);
				}
				else Put(8, 1);
				Put(ev, 2);
				ev = ev&0xffff0000;
				e.t = e.t - V_POINT;//变为普通变量
			}
SPT_START:
			cmd = Get_Mark();//读取下一个符号
			i = 0;
			vi = var.i;//初始化
			if (cmd == L_M_BRAC)//下标分析
			{
				do {
					Exp_deal(Get_Mark());//下标分析
					if (i)
					{
						Put(33, 1);
						cp.hp--;
					}
					if (++i < e.d[0])
					{
						Put(71, 1);
						Put(e.d[i], 2);
					}
					else if (i > e.d[0])
					{
						Error(var.ptr[vi], E_OARR);
					}
				} while ((cmd = Get_Mark()) == L_M_BRAC);
				sv++;//堆栈加1
				if (i == e.d[0])
				{
					if (e.t <= (VPART		+UNIT_ARR))//数组
					{
						if (e.b > 1) Put(74|(e.b << 7), 3);
					}
					else if (e.b)
					{
						Put(71|(e.b << 8), 3);//结构
					}
					i = 2;
				}
				else
				{
					for (k = i + 1; k < e.d[0]; k++)
					{
						e.d[i] = e.d[i] * e.d[k];
					}
					Move(-2);
					Put(e.d[i] * e.b, 2);
					i = 1;
				}
			}
			while (sv > tv + 1)//堆栈操作
			{
				Put(33, 1);
				sv--;
				cp.hp--;
			}
			if (cmd == POINT)//结构分析
			{
				Str_Get();
				cv.n[k = strlen(cv.n)] = ev >> 16;
				cv.n[k + 1] = 0;
				if (SeekVar()) Error(cv.n, E_UMEM);//读取成员
				ev = (ev&0xffff) + cv.v;//偏移迭加
				memcpy(e, cv, sizeof(struct TMP_VAR));//保护
				goto STU_LOOP;
			}
//===========================================循环结束=============================================
			if (sv == tv && e.t <= (VPART		+UNIT_VAR))//当作变量看待(非引用且非数组，  或引用：&t)
			{
				cv.b = e.b;
				cv.v = ev&0xffff;
				goto VAR_DEAL;
			}
			if (e.t <= (VPART		+UNIT_VAR) | (i == 2 && e.t <= (VPART		+UNIT_ARR)))//只有指针本身，变量，全维数组
			{
				if (f) j = 0;//指针初始化类型为0
				if (so)//等级转换
				{
					if (strchr(sign18, k = o[so - 1].c)) goto STU_GIVE;//++a,--a
					if (k == 20)//&
					{
						so--;
						if (f)
						{
							Put(69|(ev << 8), 3);
						}
						else
						{
							Put((j + 23)|(ev << 8), 3);
						}
						goto POP;
					}
					if (k == 54 && cp.o.g == 9) goto STU_GET;//*
				}
				if (strchr(sign19, cp.o.g))//赋值,a++,a--
				{
STU_GIVE:
					if (f && e.b == 1)
					{
						Put(69|(ev << 8), 3);
						Put(55, 1);
					}
					else
					{
						Put(((e.b >> 1) + j * 10 + 10)|(ev << 8), 3);
					}
					if (cp.o.g == 2)
					{
						Put(cp.o.c, 1);
						cmd = Get_Mark();
					}
					goto POP;
				}
STU_GET:
				if (f && e.b == 1)
				{
					Put(69|(ev << 8), 3);
					Put(54, 1);
				}
				else
				{
					Put(((e.b >> 1) + j * 10 + 7)|(ev << 8), 3);
				}
				goto POP;
			}
			if (i)//a[]
			{
				if (f | !j)
				{
					Put(69, 1);
				}
				else
				{
					Put(24, 1);
				}
			}
			else//a
			{
				if (sv == tv)
				{
					cp.hp++;
					sv++;
					Put(j * 23 + 2, 1);
				}
				else
				{
					Put(69, 1);
				}
			}
			Put(ev, 2);
			goto POP;
		}
		if (cmd <= V_POINT + (VPART		+UNIT_VAR))//cmd:18 全局变量指针,19:局部变量指针[用到的临时变量:k,j]
		{
			j = cmd&1;
			cmd = Get_Mark();//保护,读取下一个符号
			cp.hp++;//堆栈加1
			sv++;
			if (so)//等级转换
			{
				if (strchr(sign18, k = o[so - 1].c)) goto VPT_GIVE;//++a,--a
				if (k == 20)//& 当变量处理
				{
					so--;
					cp.hp--;
					sv--;
					cv.b = 2;
					goto VAR_DEAL;
				}
				if (k == 54 && cp.o.g == 9) goto VPT_GET;//*a=
			}
			if (strchr(sign19, cp.o.g))//赋值,a++,a--
			{
VPT_GIVE:
				Put((j * 10 + 5)|(cv.v << 8), 3);
				if (cv.b == 1)
				{
					Put(55, 1);
				}
				else
				{
					Put((cv.b >> 1) + 10, 3);
				}
				if (cp.o.g == 2)
				{
					Put(cp.o.c, 1);
					cmd = Get_Mark();
				}
				goto POP;
			}
VPT_GET:
			Put((j * 10 + 5)|(cv.v << 8), 3);
			if (cv.b == 1)
			{
				Put(54, 1);
			}
			else
			{
				Put((cv.b >> 1) + 7, 3);
			}
			goto POP;
		}
		if (cmd <= V_POINT + (VPART		+UNIT_ARR))//cmd:22 全局数组指针,23:局部数组指针[用到的临时变量:vi,j,i,k]
		{
			j = cmd&1;//转换
			if (*in.p != '[')
			{
ADPT_GET:
				cmd = Get_Mark();//读取下一个符号
				if (so)//& 当变量处理
				{
					if (o[so - 1].c == 20)
					{
						so--;
						cv.b = 2;
						goto VAR_DEAL;
					}
				}
				cp.hp++;
				sv++;//堆栈加1
				Put((j * 10 + 5)|(cv.v << 8), 3);
				goto POP;
			}
			in.p++;
			memcpy(e, cv, sizeof(struct TMP_VAR));
			vi = var.i;//保护,读取下一个符号
			sv++;//堆栈加1
			i = 0;
			do {
				Exp_deal(Get_Mark());//下标分析
				if (i)
				{
					Put(33, 1);
					cp.hp--;
				}
				if (++i < e.d[0])
				{
					Put(71, 1);
					Put(e.d[i], 2);
				}
				else if (i > e.d[0])
				{
					Error(var.ptr[vi], E_OARR);
				}
			} while ((cmd = Get_Mark()) == L_M_BRAC);
			if (i == e.d[0])
			{
				if (e.b > 1) Put(74|(e.b << 7), 3);
				if (so)//等级转换
				{
					if (strchr(sign18, k = o[so - 1].c)) goto APT_GIVE;//++a,--a
					if (k == 20)//&
					{
						so--;
						Put((j * 10 + 5)|(e.v << 8), 3);
						Put(33, 1);
						goto POP;
					}
					if (k == 54 && cp.o.g == 9) goto APT_GET;//*
				}
				if (strchr(sign19, cp.o.g))//赋值,a++,a--
				{
APT_GIVE:
					Put((j * 10 + 5)|(e.v << 8), 3);
					Put(33, 1);
					if (e.b == 1)
					{
						Put(55, 1);
					}
					else
					{
						Put((e.b >> 1) + 10, 3);
					}
					if (cp.o.g == 2)
					{
						Put(cp.o.c, 1);
						cmd = Get_Mark();
					}
					goto POP;
				}
APT_GET:
				Put((j * 10 + 5)|(e.v << 8), 3);
				Put(33, 1);
				if (e.b == 1)
				{
					Put(54, 1);
				}
				else
				{
					Put((e.b >> 1) + 7, 3);
				}
				goto POP;
			}
			for (k = i + 1; k < e.d[0]; k++)
			{
				e.d[i] = e.d[i] * e.d[k];
			}
			Move(-2);
			Put(e.d[i] * e.b,2);
			Put((j * 10 + 5)|(e.v << 8), 3);
			Put(0x1721, 4);
			goto POP;
		}
	}
//---------------------------------------------------------数字---------------------------------------------------------//
	if (cmd == NUMBER)//数字
	{
NUM_DEAL:
		if (cv.v < -32768 | cv.v >= 32768)
		{
			Put(3, 1);
			Put(cv.v, 4);
		}
		else
		{
			if (so)//双目运算符
			{
				i = o[so - 1].c;
				if (so > sv)//*1,!1,~1
				{
					if (i == 41)//!1
					{
						cv.v = !cv.v;
						so--;
					}
					else if (i == 37)//~1
					{
						cv.v = ~cv.v;
						so--;
					}
					goto NUM;
				}
				if (i == 33)
				{
					i = 69;//+1
				}
				else if (i == 34)
				{
					i = 70;//-1
				}
				else if (i >= 42 && i <= 52)
				{
					if (i <= 47)		i = i + 29;
					else if (i == 48)	i = 77;
					else if (i <= 50)	i = 130 - i;
					else				i = i + 27;
				}
				else
				{
					goto NUM;
				}
				e.v = cv.v;
				cmd = Get_Mark();
				if (cp.o.g < o[so - 1].g)
				{
					if (e.v >> 8)
					{
						Put(2|(e.v << 8), 3);
					}
					else
					{
						Put(1|(e.v << 8), 2);
					}
					cp.hp++;
					sv++;//堆栈+1
					goto START;
				}
				Put(i|(e.v << 8), 3);
				so--;
				goto START;
			}
NUM:
			if (cv.v >> 8)
			{
				Put(2|(cv.v << 8), 3);
			}
			else
			{
				Put(1|(cv.v << 8), 2);
			}
		}
		cp.hp++;//堆栈+1
		sv++;
		cmd = Get_Mark();
		goto POP;//堆栈操作
	}
//---------------------------------------------------------函数---------------------------------------------------------//
	if (strchr(sign17, cmd))//子程序,函数
	{
		memcpy(e, cv, sizeof(struct TMP_VAR));
		vi = var.i;//保存cv
		i = 0;//参数分析
		if (*++in.p != ')')
		{
			do {
				Exp_deal(Get_Mark());
				i++;
			} while (*(in.p - 1) == ',');
		}
		else
		{
			in.p++;
		}
		if (e.d[1] != i)//参数合法性检查
		{
			if (!strchr(sign16, e.v)) Error(var.ptr[vi], E_PARA);
		}
		if (cmd == LVM_FUN)
		{
			if (strchr(sign16, e.v))
			{
				Put(1, 1);
				Put(i, 1);
			}
#if WQX == 0
			else if (e.v == 211)
			{
				Put(e.d[0], 2);
			}
#endif
			Put(e.v, 1);
		}
		else//子程序
		{
			Put(61, 1);
			if (e.v)
			{
				Put(e.v, 3);
			}
			else
			{
				SavJmp(e.d[0] + (JP_SUB << 16 - JP_TYP), cp.offset);
				Put(0, 3);
			}
		}
		if (e.b) sv++;
		cp.hp = cp.hp + !e.b - i + 1;//堆栈操作
		cmd = Get_Mark();
		goto POP;
	}
//---------------------------------------------------------符号---------------------------------------------------------//
	if (cmd == LVM_SIGN)//运算符
	{
		if (strchr(sign15, cp.o.c))//*,-,&分离
		{
			if ((!isalnum(i = *(in.p - 2)) && !strchr(sign1, i)) | !sv)
			{
				if (cp.o.c == 34)//负数
				{
					if (isdigit(*in.p))
					{
						cv.v = -Num_Get();
						goto NUM_DEAL;
					}
					cp.o.c = 28;
				}
				else if (cp.o.c == 35)
				{
					cp.o.c = 20;
				}
				else
				{
					cp.o.c = 54;
				}
				cp.o.g = 2;
			}
		}
		while (so && sv >= 2)//双目
		{
			if (o[--so].g == 9) o[so].g = 10;
			if (o[so].g <= cp.o.g)
			{
				Put(o[so].c, 1);
				sv--;
				cp.hp--;
			}
			else
			{
				so++;
				break;
			}
		}
		memcpy(o[so++], cp.o, sizeof(struct OPERATOR));
		goto END;
	}
	if (cmd == L_S_BRAC)//(
	{
		Exp_deal(Get_Mark());
		sv++;
		cmd = Get_Mark();
		goto POP;
	}
	if (cmd >= R_M_BRAC && cmd <= R_B_BRAC)//括号]),;}
	{
		while (so && sv > 1)//双目
		{
			if (o[so - 1].g <= cp.o.g)
			{
				Put(o[--so].c, 1);
				if (o[so].g != 2)
				{
					sv--;
					cp.hp--;
				}
			}
			else
			{
				break;
			}
		}
		if (cp.hp && cmd == LVM_SEMI)
		{
			cp.hp = 0;
			Put(56, 1);
		}
		if (so | sv > 1) Error(0, E_HEAP);
		return;
	}
//---------------------------------------------------------其它---------------------------------------------------------//
	if (cmd == STRING)//字符串
	{
		Put(13, 1);
		while (*in.p != '"')
		{
			if (*in.p == 92)
			{
			
				if (vi = strchr(sign2, *++in.p))
				{
					Put(sign3[vi - sign2], 1);
					in.p++;
					continue;
				}
			}
			Put(*in.p, 1);
			if (!*++in.p) CUSH_Get();//调整
		}
		Put(0, 1);
		in.p++;
		cp.hp++;
		sv++;
		goto END;
	}
	if (cmd == LVM_SIZE)//sizeof
	{
		in.p++;
		Str_Get();
		in.p++;
		cv.v = ChkByte();//读取类型
		if (cv.v > 4)//引用
		{
			Str_Get();
			in.p++;
			if (SeekVar()) Error(cv.n, E_USTU);
			cv.v = cv.b;
		}
		else if (cv.v < 0)//变量
		{
			if (SeekVar()) Error(cv.n,E_UVAR);
			if (cv.t == (VGLOBOLE	+UNIT_ARR) | cv.t == (VPART		+UNIT_ARR))
			{
				cv.v = cv.d[cv.d[0]] * cv.b;
			}
			else
			{
				cv.v = cv.b;
			}
		}
		goto NUM_DEAL;
	}
	if (cmd >= (26	+	_LVM_T) && cmd <= (66	+	_LVM_T))//_TEXT,_GRAPH,_GBUF
	{
		Put(cmd - _LVM_T, 1);
		sv++;
		cp.hp++;
		goto END;
	}
//-------------------------------------------------------非法语法-------------------------------------------------------//
	if (cmd == POINT | cmd == L_M_BRAC | cmd == L_B_BRAC)	Error(*(in.p - 1), E_SIGN);//.[{
	if (cmd >= LVM_BRK && cmd <= LVM_DO)					Error(cv.n, E_SENTE);//语句
	if (cmd != LVM_NULL)									Error(cmd, E_CMD);//未定义的内码
//---------------------------------------------------------提取---------------------------------------------------------//
END:
	cmd = Get_Mark();
	goto START;
//---------------------------------------------------------堆栈---------------------------------------------------------//
POP:
	while (so)//单目:!,~,-,*,--,++
	{
		k = o[--so].c;
		if (o[so].g == 2)
		{
			if (k == 54)
			{
				if (cp.o.g == 9)
				{
					k = 55;
				}
				else if (cmd == R_S_BRAC)
				{
					if ((*in.p == '+' && *(in.p + 1) == '+') | (*in.p == '-' && *(in.p + 1) == '-')) k = 55;
				}
				else if (so)
				{
					if (o[so - 1].c == 29 | o[so - 1].c == 30) k = 55;
				}
			}
			Put(k, 1);
		}
		else
		{
			so++;
			break;
		}
	}
	goto START;
}
//*******************************************************语句分析*******************************************************//
void Fun_deal()/*函数编译模块*/
{
	char cmd, dp;//特征码 当前嵌套指针

	dp = jp.j;
START:
	cmd = Get_Mark();//读取词汇
	if (cmd <= LVM_SEMI)//表达式处理
	{
		Exp_deal(cmd);
		if (cp.hp) Error(0, E_HEAP);//堆栈错误
		goto END;
	}
	if (cmd == LVM_IF)//if
	{
		jp.f[++jp.j] = cmd;
		in.p++;
		Exp_deal(Get_Mark());//嵌套堆栈 条件
		if (cp.hp)
		{
			cp.hp = 0;
			Put(56, 1);
		}
		else
		{
			Error(0, E_HEAP);
		}
		SavJmp(jp.j + (JP_IF << 16 - JP_TYP), cp.offset + 1);
		Put(57, 4);//转移写入
		goto START;
	}
	if (cmd == LVM_WHILE)//while
	{
		jp.f[++jp.j] = cmd;
		jp.t[jp.i++] = cp.offset;//压入嵌套堆栈 记录首地址
		in.p++;
		Exp_deal(Get_Mark());//条件写入
		if (cp.hp)
		{
			cp.hp = 0;
			Put(56, 1);
		}
		else
		{
			Error(0, E_HEAP);
		}
		SavJmp(jp.j + (JP_WHILE << 16 - JP_TYP), cp.offset + 1);
		Put(57, 4);//转移写入
		goto START;
	}
	if (cmd == LVM_DO)//压入嵌套堆栈 记录首地址
	{
		jp.f[++jp.j] = cmd;
		jp.t[jp.i++] = cp.offset;
		if (*in.p == ' ') in.p++;
		goto START;
	}
	if (cmd == LVM_FOR)//for
	{
		jp.f[++jp.j] = cmd;
		in.p++;
		Exp_deal(Get_Mark());
		jp.t[jp.i++] = cp.offset;//压入嵌套堆栈 参数1 记录临时转移1
		lib.name[0].t2 = 0;//初始化
		if (*in.p != ';')//第2个;
		{
			Exp_deal(Get_Mark());//参数2 标记
			cmd = 0;
			SavJmp(jp.j + (JP_FOR << 16 - JP_TYP), cp.offset + 1);
			Put(57, 4);//条件写入
		}
		else if (!*++in.p)//跳过分号,调整
		{
			CUSH_Get();
		}
		if (*in.p != ')')
		{
			lib.name[0].t2 = cp.offset + 1;//记录临时转移2
			Put(59, 4);
			lib.name[0].t1 = jp.t[--jp.i];
			jp.t[jp.i++] = cp.offset;//记录for首地址
			Exp_deal(Get_Mark());//参数3
			if (cp.hp)
			{
				cp.hp = 0;
				Put(56, 1);
			}
			else
			{
				Error(0, E_HEAP);
			}
			if (!cmd)//写入临时转移1
			{
				Put(59, 1);
				Put(lib.name[0].t1, 3);
			}
		}
		else
		{
			in.p++;
		}
		if (lib.name[0].t2) W_Jmp(lib.name[0].t2, cp.offset, 3);//写入临时转移2
		goto START;
	}
	if (cmd == R_B_BRAC)//}
	{
		return;
	}
	if (cmd == L_B_BRAC)//{
	{
		Fun_deal();
	}
	else if (cmd == LVM_BRK)//break
	{
		if (jp.i)//转移写入
		{
			SavJmp(jp.i + (JP_BRK << 16 - JP_TYP), cp.offset + 1);
			Put(59, 4);
		}
		else
		{
			Error(0, E_NBRK);
		}
		goto MOV;
	}
	else if (cmd == LVM_CONT)//continue
	{
		for (lib.name[0].t1 = jp.j; jp.f[lib.name[0].t1] <= LVM_ELSE && lib.name[0].t1; lib.name[0].t1--);
		if (jp.f[lib.name[0].t1] == LVM_DO)//转移写入(do)
		{
			SavJmp(jp.i + (JP_CONT << 16 - JP_TYP), cp.offset + 1);
			Put(59, 4);
		}
		else if (jp.i)//continue跳转
		{
			Put(59, 1);
			Put(jp.t[jp.i - 1], 3);
		}
		else
		{
			Error(0, E_NCON);
		}
		goto MOV;
	}
	else if (cmd == LVM_GOTO)//goto
	{
		in.p++;
		cv.v = 0;
		Str_Get();//提取标号
		if (SeekVar())
		{
			cv.t = LVM_LABEL;
			cv.d[cv.v = 0] = cp.ln++;
			SavVar();//记录标号
			SavJmp(cv.d[0] + (JP_LABEL << 16 - JP_TYP), cp.offset + 1);
			Put(59, 4);//跳转写入
		}
		else if (!cv.v)
		{
			SavJmp(cv.d[0] + (JP_LABEL << 16 - JP_TYP), cp.offset + 1);
			Put(59, 4);
		}
		else
		{
			Put(59, 1);
			Put(cv.v, 3);
		}
MOV:
		if (!*++in.p) CUSH_Get();//跳过分号,调整
	}
	else if (cmd == LVM_RET)//return
	{
		if (cp.sub)//有返回值
		{
			if (*in.p != ';')
			{
				if (*in.p == ' ') in.p++;
				Exp_deal(Get_Mark());//参数
				if (!cp.hp)//调整
				{
					in.p--;
					Move(-1);
					if (!cp.hp)
					{
						if (*(out.p + FB_CUSH) != 56) Error(0, E_HEAP);
					}
				}
				cp.hp = 0;
				Put(63, 1);
			}
			else
			{
				Error(0, E_NRET);
			}
		}
		else if (*in.p == ';')//无返回值
		{
			if (cp.ma)
			{
				Put(64, 1);
			}
			else
			{
				Put(63, 1);
			}
		}
		else
		{
			Error(0, E_HRET);
		}
		if (!*++in.p) CUSH_Get();//跳过分号,调整
	}
	else if (cmd != LVM_NULL)
	{
		Error(cmd, E_CMD);//未定义的内码
	}
//-------------------------------------------------------跳转分析-------------------------------------------------------//
END:
	while (jp.j > dp)
	{
		if (jp.f[jp.j] <= LVM_ELSE)
		{
			if (*in.p == 'e')
			{
				Str_Get();
				if (!strcmp(cv.n, sign7) && jp.f[jp.j] != LVM_ELSE)
				{
					SeekJmp(jp.j + (JP_IF << 16 - JP_TYP), 4);
					SavJmp(jp.j + (JP_IF << 16 - JP_TYP), cp.offset + 1);
					Put(59, 4);
					if (*in.p == ' ') in.p++;
					jp.f[jp.j] = LVM_ELSE;
					goto START;
				}
				in.p = in.p - strlen(cv.n);
			}
			SeekJmp(jp.j + (JP_IF << 16 - JP_TYP), 0);
		}
		else
		{
			if (jp.f[jp.j] <= LVM_WHILE)
			{
				Put(59, 1);//首地址写入
				Put(jp.t[--jp.i], 3);
				if (jp.f[jp.j] == LVM_FOR) SeekJmp(jp.j + (JP_FOR << 16 - JP_TYP), 0);//for跳转
				else SeekJmp(jp.j + (JP_WHILE << 16 - JP_TYP), 0);//while跳转
			}
			else
			{
				do {} while(SeekJmp(jp.i + (JP_CONT << 16 - JP_TYP), 0));//continue跳转
				Get_Mark();
				in.p++;//跳过while
				Exp_deal(Get_Mark());
				if (cp.hp)
				{
					cp.hp = 0;
					Put(56, 1);
				}
				else Error(0, E_HEAP);//参数
				Put(58, 1);
				Put(jp.t[--jp.i], 3);//do跳转
			}
			do {} while(SeekJmp(jp.i + (JP_BRK << 16 - JP_TYP) + 1, 0));//break跳转
		}
		jp.j--;
	}
	goto START;
}
//*******************************************************编译接口*******************************************************//
void Compile()/*编译模块*/
{
	Progress("编译中...", "编译系统正在运行 ", 1);//消息框
	//优化字符串初始化开始
	strcpy(sign1, "_])");
	strcpy(sign2, "nrtb");
	sign3[0] = 10;
	sign3[1] = 13;
	strcpy(sign4, "+-*/%");
	strcpy(sign5, "main");
	strcpy(sign6, "if");
	strcpy(sign7, "else");
	strcpy(sign8, "while");
	strcpy(sign9, "for");
	strcpy(sign10, "return");
	strcpy(sign11, "do");
	strcpy(sign12, "break");
	strcpy(sign13, "continue");
	strcpy(sign14, "goto");
	strcpy(sign15, "*\"#");
	strcpy(sign16, "");
	sign17[0] = LVM_SUB;
	sign17[1] = LVM_FUN;
	sign18[0] = 29;
	sign18[1] = 30;
	sign17[2] = sign18[2] = sign19[2] = 0;
	strcpy(sign20, ".[");
	strcpy(sign21, "char");
	strcpy(sign22, "int");
	strcpy(sign23, "long");
	strcpy(sign24, "void");
	strcpy(sign25, "struct");
	strcpy(sign26, "\"{");
	strcpy(sig, ".\"[(]),;}{");
	strcpy(bol, "!@$~@$++$--$*@$/@$%@$+@$-@$<<$>>$==$!=$<=$>=$>@$<@$&@$|@$^@$&&$||$=@");
	strcpy(code, ")%");
	code[2] = 0x1d;
	code[3] = 0x1e;
	strcpy(code + 4, "*+,!\"-./01234#$&'(5");
	sign19[0] = grad[0] = grad[1] = grad[2] = grad[3] = 2;
	grad[4] = grad[5] = grad[6] = 3;
	grad[7] = grad[8] = 4;
	grad[9] = grad[10] = 5;
	grad[11] = grad[12] = grad[13] = grad[14] = grad[15] = grad[16] = 6;
	grad[17] = grad[18] = grad[19] = 7;
	sign3[3] = grad[20] = grad[21] = 8;
	sign3[2] = sign19[1] = grad[22] = 9;
	//优化字符串初始化结束
	LoadVFun();//初始化变量表，载入函数文件
	ChExt(out.name, "lav");
	if (ChPath(cfset.lav)) Error(cfset.lav, E_CATA);
	if (!(out.fp = fopen(out.name, "w"))) Error(out.name, E_CREAT);//创建lav文件
	memset(FB_CUSH, 0, FB_C_REL);//缓冲初始化
	CUSH_Get();
	strcpy(FB_CUSH, "LAV");
	*(FB_CUSH + 3) = 18;
	strcpy(FB_CUSH + 11, "yan22");
	out.p = 16;
	memset(jp, 0, sizeof(struct JUMP_LINK));//跳转表初始化
	jp_var = 0;
	memset(cp, 0, sizeof(struct COMPILE));//设置初始化
	cp.add[VGLOBOLE] = 0x2000;
	cp.offset = 16;
	do {
		cp.i = VGLOBOLE;//变量类型初始化
		cp.add[VPART] = 5;
		Fun_deal();//函数分析
		W_Jmp(jp_sub, cp.add[VPART], 2);//写入子程序总变量地址
		if (cp.sub) Put(1, 2);
		if (cp.ma) Put(64, 1);
		else Put(63, 1);
		Progress(ftell(in.fp) - strlen(in.p), in.size, 0);//进度
		memset(var.bh, 0, var.bt - var.bh);//去除局部变量空间表
		var.bt = var.bh;
		var.bh = (FB_CUSH + FB_C_SIZE);
		memset(&var.ptr[var.ph], 0, (var.pt - var.ph) << 1);//去除局部变量链表
		var.pt = var.ph;
		var.ph = cp.ln = 0;
		cp.sn = cp.ts;//标号个数初始化 结构体个数初始化
		DelJmp();//去除局部跳转表
	} while (*in.p);
	CUSH_Sav();//写入剩余在缓冲区的代码
	if (jp.size) Error(jp.size, E_DJMP);//含有未完成的跳转
	if (!cp.mai) Error(0, E_MAIN);//没有main函数
	if (cp.add[VGLOBOLE] > 0x7800) Error(cp.add[VGLOBOLE] - 0x7800, E_KVAR);//变量总空间太大
	W_Jmp(jp_var, cp.add[VGLOBOLE], 2);//写入变量总空间
	if (cp.la)//#loadall
	{
#if WQX == 0
		if ((cv.v = ftell(out.fp) - cp.ary) + cp.add[VGLOBOLE] > 0x7c01) Error(0, E_LOAD);
		W_Jmp(5, 0x80 - ((cv.v + 0xfe) >> 8), 1);
#else
		0;if ((cv.v = ftell(out.fp) - cp.ary) + cp.add[VGLOBOLE] > 0x7001) Error(0, E_LOAD);
		W_Jmp(5, 0x74 - ((cv.v + 0xfe) >> 8), 1);
#endif
		W_Jmp(6, cp.ary + 0x11, 2);
	}
	if (cp.fp)//写入剩余信息
	{
		W_Jmp(jp_var + 3, cp.offset, 3);
		Loadtmp();//写入初始化信息
		strcpy(cv.n, "main");
		SeekVar();
		cv.v = (cv.v << 8)|0x3b;
		fwrite(&cv.v, 1, 4, out.fp);//写入跳转
		fclose(cp.fp);//删除临时文件
		cp.fp = 0;
		if (cfset.dat[0].tem[3].value)
		{
			if (!ChDir(cpldata))
			{
				Swin("错误！", "无法进入目录", SWIN_ONE);
			}
			else if (!DeleteFile("cpl.tmp"))
			{
				Swin("错误！", "无法删除*.tmp", SWIN_ONE);
			}
		}
	}
	fclose(in.fp);
	fclose(out.fp);
	in.fp = out.fp = 0;
	if (cfset.dat[1].tem[1].value)//删除h文件
	{
		ChExt(out.name, "h");
		if (!ChDir(fundata))
		{
			Swin("错误！", "无法进入目录", SWIN_ONE);
		}
		else if (!DeleteFile(out.name))
		{
			Swin("错误！", "无法删除*.h", SWIN_ONE);
		}
	}
	Progress(1, 1, 0);//进度
}
void Login()/*登入*/
{
	strcpy(cfset.fun, "common.fun");
	strcpy(cfset.lav, "/LAVA");
	cfset.dat[0].tem[0].value =		//退出程序是否确认？
	cfset.dat[0].tem[3].value =		//是否删除临时文件？
	cfset.dat[1].tem[3].value =		//编译后是否自动退出?
	cfset.dat[2].tem[0].value =		//删除文件夹是否确认?
	cfset.dat[2].tem[1].value =		//删除宏定义是否确认?
	cfset.dat[2].tem[2].value = 1;	//保存设置是否确认？
	cfset.dat[1].tem[2].value = 2;	//选择载入的函数文件
	cfset.dat[3].tem[0].value = 60;	//按键暂停时间设置
	cfset.dat[3].tem[1].value = 12;	//光标闪动速度调整
	ClearScreen();
	ConfigRW(CON_READ);
	if (!ChDir(cfset.lav))
	{
		if (ChDir("/LAVA"))
		{
			strcpy(cfset.lav, "/LAVA");
		}
		else if (ChDir("/LAVA2"))
		{
			strcpy(cfset.lav, "/LAVA2");
		}
		else if (ChDir("/GVmaker"))
		{
			strcpy(cfset.lav, "/GVmaker");
		}
		else
		{
			SetScreen(0);
			printf("\n   找不到程序目录！\n\n\n按任意键选择.......");
			getchar();
			if (SelectDir(cfset.lav, "/")) exit(0);
		}
		ConfigRW(CON_SETE);
	}
}

#if DEBUG == 1
/*
void TestError()
{char s;
 funjmp=&s-5;strcpy(0x2000,"1234567890");in.p=0x2000;
 Error("test",code[0]);
}
*/
#endif
void main()
{
	char cmd, value;

#if WQX == 0
 	SetGraphMode(4);
#endif
	ClearScreen();
	TextOut(1, 0, "正在读取设置...", 1);
	Refresh();
 	Login();
#if DEBUG == 1
 	//for(code[0]=0;;){TestError();if(code[0]==43)exit(0);printf("%d\n",code[0]);getchar();code[0]++;}//Error测试
 	Debug();
 	Batch();
#endif

 	for (value = 0;;)
 	{
		value = Menu(value);
		if (value >= 6 && value <= 8)
		{
			memset(out, 0, sizeof(struct OUTFILE));
			memset(in, 0, sizeof(struct INFILE));//初始化
			if (value != 8)//选择文件
			{
				if (!(cmd = SelectSrc(out, txtdata, value))) continue;
			}
			if (value >= 7)
			{
				memset(TXT_CUSH, 0, (((TXT_CUSH+TXT_SIZE+1)+TXT_T_SIZE*8+6)+CLI_SIZE) + sizeof(struct SKFUNTABLE) - TXT_CUSH);//初始化
				cmd = Edit(TXT_CUSH, (TXT_CUSH+TXT_SIZE+1), ((TXT_CUSH+TXT_SIZE+1)+TXT_T_SIZE*8+6), (((TXT_CUSH+TXT_SIZE+1)+TXT_T_SIZE*8+6)+CLI_SIZE));
				if (!funjmp || cmd) continue;
				cmd = 1;
			}
			if (datfp)
			{
				fclose(datfp);//关闭所有文件
				datfp = 0;
			}
			if (cmd == 1)//txt
			{
				MAC_Prt(FY_CUSH, DOCUM_LOAD, (FY_CUSH+FY_C_SIZE));
				if (!funjmp) continue;
				if (cfset.dat[1].tem[0].value)
				{
					fclose(in.fp);
					in.fp = 0;
					Success(0);
					continue;
				}
			}
			else if (cmd == 2)//h
			{
				if (!(in.fp = fopen(out.name, "r"))) Error(out.name, E_OPEN);//打开文件
				if (!funjmp) continue;//Error跳转处
				in.size = fseek(in.fp, 0, 2);
				rewind(in.fp);//获取长度
			}
			else
			{
				Lib_Op(LIB_LOAD, (LIB_LOAD+LIB_N_LEN*17+1));
				continue;
			}
			Compile();//编译(已打开in.fp)
			if (!funjmp) continue;
#if DEBUG == 0
			Success(1);
#endif
		}
		else if (value == 1)	CON_Set(CONFG_TABLE);
		else if (value == 3)	Help();
		else if (value == 9) 	LookDoc((DOCUM_TABLE+(DOC_N_LEN+1)*DOC_D_SIZE+1), DOCUM_TABLE);
		else if (value == 10)	LookLib();
		else if (value == 11)	LookDat(SRC_TABLE);
	}
}